[
{
	"uri": "https://yo-sarawut.github.io/tutorials/learning-python/0_intro/",
	"title": "Introduction",
	"tags": [],
	"description": "MarcusCode เป็นเว็บไซต์ที่ให้คุณสามารถเรียนการเขียนโปรแกรมคอมพิวเตอร์ โดยบทเรียนนั้นเป็นเนื้อหาพื้นฐานและเข้าใจง่าย และที่สำคัญมันฟรี มีบทเรียนในการเขียนโปรแกรมในภาษา Python ในพื้นฐานจนถึงระดับสูงแยกตามบท ซึ่งเนื้อหาที่เว็บไซต์นี้สอนนั้นจะกระชับและตรงประเด็น ทำให้ผู้ที่ศึกษาตามสามารถเข้าใจถึงหลักการของภาษาไพธอนได้อย่างรวดเร็ว ตัวอย่างของเนื้อหาที่สอน เช่น โครงสร้างของภาษาไพธอน ตัวแปรและประเภทข้อมูล ตัวดำเนินการ อาเรย์และฟังก์ชัน",
	"content": "MarcusCode เป็นเว็บไซต์ที่ให้คุณสามารถเรียนการเขียนโปรแกรมคอมพิวเตอร์ โดยบทเรียนนั้นเป็นเนื้อหาพื้นฐานและเข้าใจง่าย และที่สำคัญมันฟรี มีบทเรียนในการเขียนโปรแกรมในภาษา Python ในพื้นฐานจนถึงระดับสูงแยกตามบท ซึ่งเนื้อหาที่เว็บไซต์นี้สอนนั้นจะกระชับและตรงประเด็น ทำให้ผู้ที่ศึกษาตามสามารถเข้าใจถึงหลักการของภาษาไพธอนได้อย่างรวดเร็ว ตัวอย่างของเนื้อหาที่สอน เช่น โครงสร้างของภาษาไพธอน ตัวแปรและประเภทข้อมูล ตัวดำเนินการ อาเรย์และฟังก์ชัน\nIntroduction Python Python เป็นภาษาเขียนโปรแกรมระดับสูงที่ใช้กันอย่างกว้างขวางในการเขียนโปรแกรมสำหรับวัตถุประสงค์ทั่วไป ภาษา Python นั้นสร้างโดย Guido van Rossum และถูกเผยแพร่ครั้งแรกในปี 1991 Python นั้นเป็นภาษาแบบ interprete ที่ถูกออกแบบโดยมีปรัญชาที่จะทำให้โค้ดอ่านได้ง่ายขึ้น และโครงสร้างของภาษานั้นจะทำให้โปรแกรมเมอร์สามารถเข้าใจแนวคิดการเขียนโค้ดโดยใช้บรรทัดที่น้อยลงกว่าภาษาอย่าง C++ และ Java ซึ่งภาษานั้นถูกกำหนดให้มีโครงสร้างที่ตั้งใจให้การเขียนโค้ดเข้าใจง่ายทั้งในโปรแกรมเล็กไปจนถึงโปรแกรมขนาดใหญ่\nPython นั้นมีคุณสมบัติเป็นภาษาเขียนโปรแกรมแบบไดนามิกส์ และมีระบบการจัดการหน่วยความจำอัตโนมัติ และสนับสนุนการเขียนโปรแกรมหลายรูปแบบ ที่ประกอบไปด้วย การเขียนโปรแกรมเชิงวัตถุ imperative การเขียนโปรแกรมแบบฟังก์ชัน และการเขียนโปรแกรมแบบขั้นตอน มันมีไลบรารี่ที่ครอบคลุมการทำงานอย่างหลากหลาย ตัวแปรภาษา (Interpreter) ของภาษา Python นั้นมีให้ใช้ในหลายระบบปฏิบัติการ ทำให้โค้ดของภาษา Python สามารถรันในระบบต่างๆ ได้อย่างกว้างขวาง CPython นั้นเป็นการพัฒนาในขั้นตั้นของ Python ซึ่งเป็นโปรแกรมแบบ open source และมีชุมชนสำหรับเป็นต้นแบบในการพัฒนา เนื่องจากมันได้มีการนำไปพัฒนากระจายไปอย่างหลากหลาย CPython นั้นจึงถูกจัดการโดยองค์กรไม่แสวงหาผลกำไรอย่าง Python Software Foundation\nภาษา Python นั้นกำเนิดขึ้นในปลายปี 1980 และการพัฒนาของมันนั้นเริ่มต้นในเดือนธันวาคม 1989 โดย Guido van Rossum ที่ Centrum Wiskunde \u0026amp; Informatica (CWI) ในประเทศเนเธอร์แลนด์ เนื่องในผู้ประสบความสำเร็จในการสร้างภาษา ABC ที่มีความสามารถสำหรับการ exception handling และการติดต่อผสานกับระบบปฏิบัติการ Amoeba ซึ่ง Van Rossum นั้นเป็นผู้เขียนหลักของภาษา Python และเขาทำหน้าเป็นกลางในการตัดสินใจสำหรับทิศทางการพัฒนาของภาษา Python\nหลังจากคุณได้เสร็จสิ้นบทเรียนของภาษา Python นี้ คุณจะรู้จักกับภาษา Python และโครงสร้างของภาษา และคุณจะสามารถเขียนโปรแกรมด้วยภาษา Python ตั้งแต่การสร้างแอพพลิเคชันอย่างง่ายไปจนถึงโปรแกรมการคำนวณที่ซับซ้อน และเข้าใจหลักการที่สำคัญในการเขียนโปรแกรมทั้งในพื้นฐานและในขั้นสูงที่เป็นการเขียนโปรแกรมแบบเชิงวัตถุ เราจะพาคุณติดตั้งภาษา Python และแนะนำให้คุณรู้จักกับเครื่องมือที่ใช้ในการพัฒนาโปรแกรมอย่างเช่น IDLE ซึ่งเนื้อหาเหล่านี้เป็นพื้นฐานที่สำคัญที่จะทำให้คุณสามารถนำไปพัฒนาทักษะการเขียนโปรแกรมภาษา Python ของคุณในขั้นสูงต่อไป เช่น การพัฒนาเว็บไซต์ การสร้างเกม ฐานข้อมูล เน็ตเวิร์ค การจัดการกราฟฟิค เป็นต้น.\n Reference : http://marcuscode.com/lang/python\n "
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/learning-python/",
	"title": "Python by MascusCode",
	"tags": [],
	"description": "MarcusCode เป็นเว็บไซต์ที่ให้คุณสามารถเรียนการเขียนโปรแกรมคอมพิวเตอร์ โดยบทเรียนนั้นเป็นเนื้อหาพื้นฐานและเข้าใจง่าย และที่สำคัญมันฟรี มีบทเรียนในการเขียนโปรแกรมในภาษา Python ในพื้นฐานจนถึงระดับสูงแยกตามบท ซึ่งเนื้อหาที่เว็บไซต์นี้สอนนั้นจะกระชับและตรงประเด็น ทำให้ผู้ที่ศึกษาตามสามารถเข้าใจถึงหลักการของภาษาไพธอนได้อย่างรวดเร็ว ตัวอย่างของเนื้อหาที่สอน เช่น โครงสร้างของภาษาไพธอน ตัวแปรและประเภทข้อมูล ตัวดำเนินการ อาเรย์และฟังก์ชัน",
	"content": "  Introduction MarcusCode เป็นเว็บไซต์ที่ให้คุณสามารถเรียนการเขียนโปรแกรมคอมพิวเตอร์ โดยบทเรียนนั้นเป็นเนื้อหาพื้นฐานและเข้าใจง่าย และที่สำคัญมันฟรี มีบทเรียนในการเขียนโปรแกรมในภาษา Python ในพื้นฐานจนถึงระดับสูงแยกตามบท ซึ่งเนื้อหาที่เว็บไซต์นี้สอนนั้นจะกระชับและตรงประเด็น ทำให้ผู้ที่ศึกษาตามสามารถเข้าใจถึงหลักการของภาษาไพธอนได้อย่างรวดเร็ว ตัวอย่างของเนื้อหาที่สอน เช่น โครงสร้างของภาษาไพธอน ตัวแปรและประเภทข้อมูล ตัวดำเนินการ อาเรย์และฟังก์ชัน\n  3. โครงสร้างของภาษา Python ในบทนี้ คุณจะได้เรียนรู้และทำความเข้าใจเกี่ยวกับโครงของภาษา Python ในภาษาคอมพิวเตอร์นั้นมีโครงสร้างของภาษาเช่นเดียวกับภาษาของมนุษย์เรา ซึ่งสิ่งเหล่านี้ถูกกำหนดเพื่อเป็นรูปแบบและวิธีในการเขียนโปรแกรมในภาษา Python มันใช้สำหรับควบคุมวิธีที่คุณจะเขียนโค้ดของคุณเพื่อให้เข้าใจโดยตัวแปรภาษาหรือคอมไพเลอร์.\n  4. ตัวแปรและประเภทข้อมูล นบทนี้ คุณจะได้เรียนรู้เกี่ยวกับตัวแปรและประข้อมูลในภาษา Python เราจะพูดถึงการประกาศตัวแปรและการนำตัวแปรไปใช้งานในโปรแกรม และเราจะอธิบายถึงข้อมูลประเภทต่างๆ ที่เป็นประเภทข้อมูลพื้นฐาน (Primitive data type) ในภาษา Python และรวมทั้งฟังก์ชันสำหรับการใช้งานกับตัวแปร\n  9. ฟังก์ชัน (Function) ในบทนี้ คุณจะได้เรียนรู้เกี่ยวกับฟังก์ชันในภาษา Python เราจะพูดถึงการสร้างและการใช้งานฟังก์ชันในเบื้องต้น และการเรียกใช้งานฟังก์ชันในรูปแบบต่างๆ ที่สำคัญ เช่น Default Argument และ Keyword Augment และมากไปกว่านั้น เราจะแนะนำให้คุณรู้จักกับ built-in ฟังก์ชันในภาษา Python\n  10. String ในบทนี้ คุณจะได้เรียนรู้เกี่ยวกับ String ในภาษา Python เราจะพูดเกี่ยวกับการประกาศและใช้งาน String ในรูปแบบต่างๆ เพราะว่าเนื้อหาเกี่ยวกับ String นั้นมีค่อนข้างมาก ดังนั้นเราจึงได้รวบรวมเนื้อหาทั้งหมดไว้ในบทนี้ และเราจะแนะนำการใช้งาน built-in function ในภาษา Python ที่สำคัญในการจัดการกับข้อมูลประเภท String การประกาศตัวแปร String String เป็นลำดับของตัวอักษรหลายตัวเรียงต่อกัน ซึ่งในภาษา Python นั้นการที่จะประกาศ String ค่าของมันจะอยู่ในเครื่องหมาย Double quote หรือ Single quote เท่านั้น มาดูตัวอย่างการประกาศตัวแปรของ String name = \u0026#34;Mateo\u0026#34; site = \u0026#39;marcuscode.com\u0026#39; str1 = \u0026#34;This is my string\u0026#34; str2 = \u0026#39;This is my string\u0026#39; ในตัวอย่าง เราได้ประกาศ 4 ตัวแปรของ String คุณจะสังเกตว่าในการกำหนดค่าให้กับตัวแปรนั้น String literal จะถูกภายในเครืองหมาย Double quote (\u0026quot;\u0026quot;) หรือ Single quote ('') เท่านั้น ซึ่งได้ผลการทำงานที่เหมือนกัน ขนาดของ String นั้นจะขึ้นกับจำนวนตัวอักษรภายใน String\n  11. String methods ในบทก่อนหน้า เราได้พูดเกี่ยวกับการใช้งาน String ในเบื้องต้นไปแล้ว ในบทนี้ เราจะแนะนำเมธอดและการใช้งานเมธอดในคลาส String ในภาษา Python นั้น String เป็นคลาสมาตรฐานสำหรับจัดการข้อมูลประเภทข้อความ และในคลาสจะมีเมธอดสำหรับจัดการข้อมูลและอำนวยความสะดวกในการเขียนโปรแกรมเป็นอย่างมากและช่วยลดเวลาในการเขียนโปรแกรมของคุณ Find and search ในคลาสของ String มีเมธอดประเภทต่างๆ ในการจัดการกับ String เมธอดกลุ่มแรกที่เราจะแนะนำให้คุณรู้จักคือเมธอดเกี่ยวกับการค้นหาและตรวจสอบตำแหน่งภายใน String มาดูตัวอย่างของการใช้เมธอดดังกล่าวในภาษา Python s = \u0026#39;mountain\u0026#39; print(s.startswith(\u0026#39;moun\u0026#39;)) print(s.endswith(\u0026#39;in\u0026#39;)) print(s.find(\u0026#39;n\u0026#39;)) print(s.rfind(\u0026#39;n\u0026#39;)) print(s.replace(\u0026#39;moun\u0026#39;, \u0026#39;con\u0026#39;)) print(s.count(\u0026#39;a\u0026#39;)) ในตัวอย่าง เป็นการใช้งานเมธอดในการค้นหาและการทำงานกับตำแหน่งใน String โดยเมธอด startswith() เป็นเมธอดในการตรวจสอบว่า String นั้นเริ่มต้นด้วย 'moun' หรือไม่ และเมธอด endswith() เพื่อตรวจสอบว่า String นั้นจบด้วย 'in' หรือไม่ เพราะว่าข้อมูลใน String นั้นตรงกับเงื่อนไขดังกล่าวซึ่งมีค่าเป็นจริง print(s.find(\u0026#39;n\u0026#39;)) print(s.rfind(\u0026#39;n\u0026#39;)) ต่อไปเป็นการใช้เมธอด find() เพื่อค้นหาตำแหน่ง Index ของ Sub string 'n' ที่พบครั้งแรกใน String และเมธอด rfind() เป็นการค้นหาจากด้านหลังจากตำแห่งแรกที่พบเช่นกัน ซึ่งจะได้ Index เป็น 3 และ 7 ตามลำดับ\n  12. List (ลิสต์) ในบทนี้ คุณจะได้เรียนรู้เกี่ยวกับโครงสร้างข้อมูลแบบ List ในภาษา Python เราจะพูดถึงการสร้างและใช้งาน List ในเบื้องต้น การใช้งานเมธอดและฟังก์ชันเพื่อจัดการข้อมูลภายใน List และการใช้งานคำสั่ง For loop กับ List รวมถึงการ slicing List (ลิสต์) คือโครงสร้างข้อมูลชนิดหนึ่งในภาษา Python ที่ใช้เก็บข้อมูลแบบลำดับ (Sequence) โดยมี Index เป็นตัวระบุตำแหน่งในการเข้าถึงข้อมูล เราสามารถใช้ List เพื่อเก็บข้อมูลจำนวนมากและหลากหลายประเภทในเวลาเดียวกัน List เป็นประเภทข้อมูลที่ใช้อย่างหลากหลายในการเขียนโปรแกรม นอกจากนี้ ในภาษา Python ยังมี built-in function ที่สามารถทำงานกับ List และใน List ออบเจ็คเองก็มีเมธอดต่างๆ เป็นจำนวนมากที่ช่วยอำนวยความสะดวกในการเขียนโปรแกรม การประกาศและใช้งาน List List นั้นเป็นตัวแปรประเภทหนึ่ง การใช้งานของมันจะเหมือนกันอาเรย์ในภาษาอื่นๆ ในการประกาศ List นั้นข้อมูลของมันจะอยู่ภายในเครื่องหมาย [] และคั่นสมาชิกแต่ละตัวด้วยเครื่องหมายคอมมา , มาดูตัวอย่างการประกาศ List ในภาษา Python numbers = [-1, 2, 5, 8, 10, 13] names = [\u0026#39;Mateo\u0026#39;, \u0026#39;Danny\u0026#39;, \u0026#39;James\u0026#39;, \u0026#39;Thomas\u0026#39;, \u0026#39;Luke\u0026#39;] mixed_type = [-2, 5, 84.\n  13. List Methods (ลิสต์ เมธอด) ในบทนี้ เราจะพูดถึงการใช้งาน List เมธอด ในภาษา Python เนื่องจาก List เป็นออบเจ็ค ดังนั้น Python จึงได้ให้เมธอดต่างๆ สำหรับทำงานพื้นฐานกับ List ที่ช่วยอำนวยความสะดวกในการทำงานเป็นอย่างมาก นอกจากนี้ เรายังจะพูดถึงการใช้งาน built-in function กับ List ถึงแม้ในภาษา Python นั้นมีเมธอดและฟังก์ชันเป็นจำนวนมาก แต่เราจะมาดูตัวอย่างการใช้งานเฉพาะที่สำคัญ การใช้งานเมธอดของ List ตัวอย่างแรกของการใช้เมธอดของ List นั้นจะเป็นการใช้งานเมธอดเพื่อทำงานพื้นฐานกับ List คือการเพิ่มและลบข้อมูลออกจาก List โปรแกรมของเราเป็นการใช้ List เพื่อเก็บรายชื่อ หลังจากนั้นเราใช้เมธอดต่างๆ กับเพื่อจัดการกับข้อมูลภาย List นี่เป็นโค้ดการทำงานของโปรแกรม names = [\u0026#39;David\u0026#39;, \u0026#39;Johnny\u0026#39;, \u0026#39;Dennis\u0026#39;, \u0026#39;Jason\u0026#39;] # add 2 names to the end of the list names.append(\u0026#39;Andy\u0026#39;) names.append(\u0026#39;Rene\u0026#39;) print(names) # add a name at position 3 names.insert(2, \u0026#39;Mike\u0026#39;) print(names) # remove 2 specific names names.\n  15. Dictionary ในบทนี้ คุณจะได้เรียนรู้เกี่ยวกับโครงสร้างข้อมูล Dictionary ในภาษา Python เราจะแนะนำให้คุณรู้จักกับ Dictionary คืออะไร และการประกาศและใช้งานสำหรับเก็บข้อมูลในการเขียนโปรแกรม นอกจากนี้ เรายังจะพูดถึงการใช้งานเมธอดและ built-in functions ของ Dictionary และตัวอย่างการใช้งานกับการเขียนโปรแกรมใบรูปแบบต่างๆ ในภาษา Python Dictionary คือประเภทข้อมูลที่เก็บข้อมูลในรูปแบบคู่ของ Key และ Value โดยที่ Key ใช้สำหรับเป็น Index ในการเข้าถึงข้อมูลและ Value เป็นค่าข้อมูลที่สอดคล้องกับ Key ของมัน การเข้าถึงข้อมูลใน Dictionary นั้นรวดเร็วเพราะว่าข้อมูลได้ถูกทำ Index ไว้อัตโนมัติโดยใช้ Key นอกจากนี้ Dictionary ยังมีเมธอดและฟังก์ชันอำนวยความสะดวกสำหรับการทำงานทั่วไป การประกาศ Dictionary ในภาษา Python ในการใช้งาน Dictionary เรามักจะใช้เก็บข้อมูลที่สามารถใช้บางอย่างที่สามารถจำแนกข้อมูลออกจากกันได้ โดยกำหนดให้สิ่งนั้นเป็น Key ในการประกาศ Dictionary สมาชิกของมันจะอยู่ภายในวงเล็บปีกกา {} มาดูตัวอย่างในการประกาศ Dictionary ในภาษา Python scores = {\u0026#39;james\u0026#39;: 1828, \u0026#39;thomas\u0026#39;: 3628, \u0026#39;danny\u0026#39;: 9310} scores[\u0026#39;bobby\u0026#39;] = 4401 numbers = {1: \u0026#39;One\u0026#39;, 2: \u0026#39;Two\u0026#39;, 3: \u0026#39;Three\u0026#39;} print(scores) print(numbers) ในตัวอย่าง เราได้ประกาศตัวแปร Dictionary ที่มีชื่อว่า scores สำหรับเก็บคะแนนของแต่ละคนโดยใช้ชื่อเป็น Key และค่าของมันก็คือคะแนน สมาชิกของ Dictionary แต่ละตัวจะถูกกำหนดในรูปแบบ key: value และคั่นสมาชิกแต่ละตัวด้วยเครื่องหมายคอมมา เราได้กำหนดค่าเริ่มต้นสามค่าให้กับ Dictionary และสามารถกำหนดค่าให้กับ Dictionary ในรูปแบบ scores['bobby'] ได้หลังจากที่ตัวแปรถูกสร้างแล้ว สังเกตว่าเราสามารถใช้ Key เป็น String หรือประเภทข้อมูลอื่นๆ ได้ ต่อมาตัวแปร numbers เป็น Dictionary ที่มี Key เป็นตัวเลข\n  17. โมดูล (Module) ในการเขียนโปรแกรมในภาษา Python โมดูล (Module) คือไฟล์ของโปรแกรมที่กำหนดตัวแปร ฟังก์ชัน หรือคลาสโดยแบ่งย่อยออกไปจากโปรแกรมหลัก และสามารถนำมาใช้งานได้โดยการนำเข้ามาในโปรแกรม (Import) กล่าวอีกนัยหนึ่ง โมดูลก็คือไลบรารี่ที่สร้างไว้และนำมาใช้งานในโปรแกรม ในบทนี้ เราจะพูดถึงความหมายของโมดูล การสร้าง และการใช้งานโมดูลในการเขียนโปรแกรม นอกจากนี้ เราจะแนะนำให้คุณรู้จักกับ Package ซึ่งเป็นแนวคิดในการจัดการกับโมดูลในรูปแบบของ Namespace โมดูล คืออะไร โมดูล (Module) คือไฟล์หรือส่วนของโปรแกรมที่ใช้สำหรับกำหนดตัวแปร ฟังก์ชัน หรือคลาสโดยแบ่งย่อยอีกหน่วยหนึ่งจากโปรแกรมหลัก และในโมดูลยังสามารถประกอบไปด้วยคำสั่งประมวลผลการทำงานได้ ยกตัวอย่างเช่น เมื่อคุณเขียนโปรแกรมในภาษา Python คุณอาจจะมีฟังก์ชันสำหรับทำงานและจัดการกับตัวเลขเป็นจำนวนมาก และในขณะเดียวกัน คุณไม่ต้องการให้โปรแกรมหลักนั้นมีขนาดใหญ่เกินไป นั่นหมายความว่าคุณสามารถนำฟังก์ชันเหล่านี้มาสร้างเป็นโมดูล และในการใช้งานนั้นจะต้องนำเข้ามาในโปรแกรมโดยวิธีที่เรียกว่า Import คุณจะเห็นว่าโมดูลก็คือการแยกส่วนของโปรแกรมออกไปเป็นอีกส่วนและสามารถเรียกใช้ได้เมื่อต้องการ หรือกล่าวอีกนัยหนึ่ง โมดูลก็เหมือนไลบรารีของฟังก์ชันและคลาสต่างๆ นั่นเป็นเพราะว่าเมื่อโปรแกรมของคุณมีขนาดใหญ่ คุณสามารถแบ่งส่วนต่างๆ ของโปรแกรมออกเป็นโมดูลย่อยๆ เพื่อให้ง่ายต่อการจัดการและการใช้งาน ในภาษา Python โมดูลที่ถูกสร้างขึ้นมานั้นจะเป็นไฟล์ในรูปแบบ module_name.py และนอกจากนี้ Python ยังมี Built-in module เป็นจำนวนมาก เช่น math เป็นโมดูลเกี่ยวกับฟังก์ชันทางคณิตศาสตร์ หรือ random เป็นโมดูลเพื่อจัดการและสุ่มตัวเลข เป็นต้น การสร้างโมดูลในภาษา Python ในการสร้างโมดูลในภาษา Python คุณต้องนำโค้ดของโปรแกรม โดยทั่วไปแล้วจะประกอบไปด้วย ตัวแปร ฟังก์ชัน หรือคลาส ไปรวมไว้ในไฟล์ใหม่ที่ไม่ใช้ไฟล์หลักของโปรแกรม ในรูปแบบ module_name.\n  21. Classes \u0026amp; Objects ในบทนี้ คุณได้เรียนรู้เกี่ยวกับโมดูลในภาษา Python และได้ทราบว่าการใช้งานโมดูลนั้นสามารถช่วยแบ่งโค้ดออกเป็นส่วนๆ และเรียกใช้งานได้เมื่อต้องการ เราได้พูดถึงการสร้างและการใช้งานโมดูลโดยการนำเข้าโมดูลด้วยคำสั่ง import และคำสั่ง from import การจัดหมวดหมู่ของโมดูลด้วย Package นี่เป็นสิ่งที่สำคัญเมื่อโปรแกรมของคุณมีขนาดใหญ่ขึ้น คุณอาจจะแบ่งมันออกเป็นส่วนๆ โดยแยกเป็นโมดูล และจัดกลุ่มของโมดูลด้วยการใช้ Package และนอกจากนี้ คุณยังสามารถสร้างไลบรารี่ของคุณ เพื่อให้นักพัฒนาคนอื่นๆ ได้ใช้งาน ก่อนที่จะเริ่มต้น มาทำความเข้าใจกับคำศัพท์ที่จำเป็นต้องทราบสำหรับการเขียนโปรแกรมเชิงวัตถุในภาษา Python คลาส คือประเภทข้อมูลที่สร้างโดยผู้ใช้ โดยจะนำไปใช้สร้างออบเจ็ค กล่าวอีกนัยหนึ่ง คลาสคือประเภทข้อมูลของออบเจ็ค ออบเจ็ค คือสิ่งที่สร้างมาจากคลาสหรือ class instances แอตทริบิวต์ (instance attributes) คือข้อมูลที่เป็นสมาชิกของแต่ละออบเจ็ค โดยมักจะกำหนดไว้ในเมธอด __init__() ของคลาส เมธอด คือฟังก์ชันการทำงานที่กำหนดไว้ในคลาส คลาสแอตทริบิวต์ (class attributes) คือตัวแปรที่ประกาศไว้ในคลาส ซึ่งจะแชร์กับออบเจ็คทั้งหมดที่สร้างจากคลาสนั้นๆ คลาสคืออะไร คลาส คือสิ่งที่ใช้กำหนดรูปแบบของข้อมูล (Attributes) และเมธอด (Methods) การทำงานเข้าด้วยกัน การสร้างคลาส หมายถึงการสร้างประเภทของออบเจ็คขึ้นมา กล่าวอีกนัยหนึ่ง คลาสคือประเภทข้อมูลของออบเจ็คโดยคลาสนั้นสร้างขึ้นโดยผู้ใช้ (User-defined type) โดยปกติแล้ว ประเภทข้อมูลพื้นฐานในภาษา Python นั้นคือคลาส เมื่อคุณสร้างตัวแปรใดๆ ขึ้นมา ตัวแปรเหล่านั้นเป็นออบเจ็คของคลาส เพื่อทำให้คุณเข้าใจมากขึ้นมาดูตัวอย่างต่อไปนี้\n  22. Inheritance ในบทก่อนหน้า คุณได้เรียนรู้พื้นฐานการเขียนโปรแกรมเชิงวัตถุในการสร้างคลาสและออบเจ็คไปแล้ว และในบทนี้ คุณจะได้เรียนรู้เกี่ยวกับคุณสมบัติอีกอย่างหนึ่งของ OOP คือการสืบทอดคลาส (Inheritance) ซึ่งเป็นความสามารถที่สำคัญในภาษา Python ที่จะทำให้สามารถนำคลาสที่เขียนไว้แล้วมาใช้อีกครั้งและเพิ่มความสามารถเพิ่มเติมเข้ามา ก่อนที่จะเริ่ม มาทำความเข้าใจกับแนวคิดของการสืบทอดก่อน Inheritance คืออะไร Inheritance หรือการสืบทอด คือการที่คลาสหรือออบเจ็ค ได้รับการถ่ายทอดแอตทริบิวต์และเมธอดจากคลาสอื่น นั่นจะทำให้คลาสดังกล่าวมีแอตทริบิวต์และเมธอดเหมือนคลาสที่มันสืบทอดมาเรียกคลาสนั้นว่า super class หรือ base class ส่วนคลาสที่ได้รับการสืบทอดเรียกว่า sub class หรือ child class นอกจากนี้ เรายังสามารถขยายความสามารถโดยการเพิ่มแอตทริบิวต์หรือเมธอด หรือทำการ override เมธอดของ super class ได้ นี่เป็นแนวคิดในการนำโค้ดเดิมกลับมาใช้โดยไม่ต้องเขียนขึ้นใหม่ และเพิ่มความสามารถของเดิมที่มีอยู่ ในภาษา Python นั้นยังสนับสนุน Multiple inheritance ซึ่งอนุญาติให้คลาสสืบทอดจากคลาสหลายๆ คลาสได้ในเวลาเดียวกัน นี่เป็นรูปแบบของการสืบทอดคลาสในภาษา Python class DerivedClassName(BaseClassName): pass class DerivedClassName(BaseClassName1, BaseClassName2, ...): pass ในตัวอย่าง เป็นรูปแบบการสืบทอดคลาส โดยแบบแรกเป็นการสืบทอดจากคลาสเดียว ซึ่งชื่อของ super class จะอยู่ในวงเล็บ (BaseClassName) และสำหรับตัวอย่างต่อมา คือการสืบทอดแบบหลายคลาส โดยจะมีเครื่องหมายคอมมา (,) แยกระหว่างแต่ละคลาสออกจากกัน ต่อไปมาดูตัวอย่างการสร้างคลาสที่สืบทอดจากคลาสอื่นในภาษา Python\n  23. Thread ในบทนี้ คุณจะได้เรียนรู้เกี่ยวกับ Thread ในภาษา Python เราจะพูดเกี่ยวกับการสร้างและใช้งาน Thread และวิธีการนำ Thread มาช่วยเพื่อเพิ่มประสิทธิภาพให้กับโปรแกรมของเรา Thread คืออะไร Thread (เทร็ด) คือลำดับการทำงานของชุดคำสั่งโปรแกรมที่เล็กที่สุดซึ่งโดยทั่วไปแล้วจะอยู่ภายใน Process โดยที่ในหนึ่ง Process นั้นจะสามารถมีได้หลาย Thread การใช้งาน Thread จะทำให้เราสามารถเขียนโปรแกรมที่ทำงานแบบคู่ขนานและใช้ทรัพยากรบางอย่างร่วมกัน ยกตัวอย่างเช่น หน่วยความจำ เมื่อมีหลาย Thread ทำงานพร้อมกัน เราจะเรียกการเขียนโปรแกรมในรูปแบบนี้ว่า Multi-thread รูปภาพแสดงการทำงานของ Thread และ Process โดยทั่วไปแล้ว โปรแกรมที่เราเขียนในภาษา Python นั้นจะรันอยู่ภายใน Thread หลัก ซึ่งเป็น Thread เริ่มต้นเมื่อโปรแกรมของภาษา Python เริ่มทำงาน ซึ่งภายใน Thread หลักนี้เอง เราสามารถสร้าง Thread อื่นๆ เพื่อใช้ประโยชน์จากมันได้ การสร้าง Thread ในภาษา Python ในการสร้าง Thread นั้นเราสามารถสร้างได้จากคลาส Thread ที่อยู่ภายในโมดูล threading ซึ่งโมดูลนี้ประกอบไปด้วยคลาสต่างๆ ที่ใช้สำหรับสร้างและทำงานเกี่ยวกับ Thread นี่เป็นตัวอย่างการสร้าง Thread ในภาษา Python thread1.py\n  24. Date \u0026amp; Time (วันที่และเวลา) ในบทนี้ คุณจะได้เรียนรู้เกี่ยวกับวันที่และเวลาในภาษา Python เราจะพูดถึงการทำงานพื้นฐานเกี่ยวกับวันที่และเวลา เช่น การแสดงเวลาปัจจุบัน การบวกลบเวลา เขตเวลา และแนะนำคลาสและเมธอดเกีี่ยวกับวันที่และเวลา นี่เป็นเนื้อหาในบทนี้ วันที่และเวลาปัจจุบัน การสร้างออบเจ็ควันที่และเวลา Unix timestamp การบวกลบวันที่และเวลา คลาสและโมดูลเกี่ยวกับวันที่และเวลา วันที่และเวลาปัจจุบัน ในการเขียนโปรแกรมเกี่ยวกับเวลา สิ่งแรกที่เรามักทำคือการแสดงวันที่และเวลาปัจจุบันออกทางหน้าจอเพื่อแจ้งให้ผู้ใช้งานโปรแกรมได้ทราบ สำหรับตัวอย่างแรกในบทนี้ เราจะมาเขียนโปรแกรมเพื่อแสดงวันที่และเวลาปัจจุบันออกทางหน้าจอในภาษา Python current_time.py from datetime import datetime # Get current date and time now = datetime.today() # Display using difference formats print(now) print(now.isoformat()) print(now.ctime()) นี่เป็นผลลัพธ์การทำงานของโปรแกรม 2020-11-05 02:23:48.841250 2020-11-05T02:23:48.841250 Thu Nov 5 02:23:48 2020 ในตัวอย่างนี้ เราได้แสดงวันที่และเวลาปัจจุบันของระบบออกทางหน้าจอ เมื่อคุณรันตัวอย่างนี้ เวลาที่ได้จะเป็นเวลาปัจจุบันบนคอมพิวเตอร์ของคุณ from datetime import datetime เพื่อเข้าถึงวันที่และเวลาในภาษา Python เราสามารถใช้คลาส datetime ซึ่งเป็นคลาสจากโมดูล datetime คลาสนี้เป็นคลาสที่เราสามารถนำมาสร้างออบเจ็คของวันที่ที่ประกอบไปด้วยข้อมูลของวันที่และเวลาที่สามารถนำมาใช้งานในโปรแกรมได้\n  "
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/phyblas/beginer/",
	"title": "ผู้เริ่มต้น (Beginer)",
	"tags": [],
	"description": "",
	"content": "ระดับพื้นฐาน\nบทที่ ๑: รู้จักกับภาษาไพธอน\n※\nบทที่ ๒: การติดตั้งและเริ่มเขียนโปรแกรม\n※ print\nบทที่ ๓: ตัวแปรและชนิดของข้อมูล\n※ int float complex str bool type\nบทที่ ๔: ฟังก์ชันพื้นฐาน\n※ input len\nบทที่ ๕: นิพจน์และการคำนวณ\n※ + - * / // % ** pow abs\nบทที่ ๖: ความเป็นจริงเท็จและการตั้งเงื่อนไข\n※ if elif else or and not == \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= !=\nบทที่ ๗: การทำซ้ำด้วย while\n※ while break continue\nบทที่ ๘: ข้อมูลชนิดลำดับ\n※ list tuple range append insert remove pop\nบทที่ ๙: การทำซ้ำด้วย for\n※ for in\nบทที่ ๑๐: การแสดงผลตัวอักษร\n※ \\n \\t \\b \\a %d %f %e %x %s\nบทที่ ๑๑: การจัดการกับสายอักขระ\n※ split join splitlines lower upper strip lstrip rstrip find rfind index rindex count startswith endswith replace\nบทที่ ๑๒: การจัดการกับลิสต์\n※ sort sorted reverse reversed max min\nบทที่ ๑๓: เซ็ต\n※ set add update remove discard issubset issuperset union intersection difference symmetric_difference\nบทที่ ๑๔: ดิกชันนารี\n※ dict keys values items\nบทที่ ๑๕: การเรียกใช้มอดูล\n※ from import as\nบทที่ ๑๖: ฟังก์ชันที่เกี่ยวข้องกับคณิตศาสตร์\n※ math\nเนื้อหาเพิ่มเติม ⊟ [2015/12/17] ความแตกต่างระหว่าง python 2.x และ 3.x\n⊟ [2015/12/18] range และ xrange ใน python 2.x และ 3.x\n⊟ [2015/12/19] unicode และ ASCII ใน python 2.x และ 3.x\n⊟ [2019/01/06] วิธีการติดตั้ง anaconda ใน linux\n⊟ [2019/01/14] การใช้ pip เพื่อติดตั้งแพ็กเกจเสริมใน python\n⊟ [2019/01/18] การใช้ conda เพื่อติดตั้งแพ็กเกจและสร้างสภาพแวดล้อมแบ่งแยก\n⊟ [2019/01/21] การถอนการติดตั้ง anaconda\n⊟ [2019/07/05] การใช้คำสั่ง python รันโปรแกรมในคอมมานด์ไลน์\n⊟ [2019/07/14] การใช้ f-string เพื่อจัดรูปแบบสายอักขระใน python\n⊟ [2020/06/29] วิธีการพิมพ์อักษรกรีกหรืออักษรพิเศษเพิ่มเติมโดยใช้ ipython\nเกร็ดเล็กน้อย ⊟ [2016/04/30] สร้างแอตทริบิวต์ที่มีคุณสมบัติพิเศษในคลาสด้วย property\n⊟ [2018/05/31] ข้อควรระวังเมื่อใช้ try และ except แล้วต้องการหยุดโปรแกรมกลางคัน\n⊟ [2019/01/07] วิธีทำให้ import มอดูลที่ต้องการทุกครั้งเมื่อเริ่มโปรแกรม\n⊟ [2019/01/08] วิธีการรันไพธอนโดยตรงใน unix shell ใน mac และ linux\n⊟ [2019/01/12] ข้อควรระวังเมื่อมีการแก้ไขลิสต์ขณะใช้ for อาจทำให้เกิดการวนซ้ำไม่สิ้นสุดได้\n⊟ [2019/06/24] ทำความเข้าใจ and และ or ให้มากขึ้น\n⊟ [2019/07/13] เปรียบเทียบระหว่างการใช้ %, ใช้ format และใช้ f-string ใน python\nการประยุกต์ใช้ \u0026raquo; สารบัญแนะนำมอดูลต่างๆ \u0026raquo; สารบัญการเรียนรู้ของเครื่อง \u0026raquo; สารบัญโครงข่ายประสาทเทียม จิปาถะ ⊟ [2017/02/23] สร้างแฟร็กทัลอย่างง่าย\n⊟ [2018/03/26] ใช้ opencv (cv2) เพื่อค้นหาใบหน้าอนิเมะ\n⊟ [2018/03/29] ค้นหาภาพใบหน้าอนิเมะจากเว็บ safebooru\n⊟ [2018/07/14] สร้างเส้นโค้งฮิลแบร์ทสองมิติ\n"
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/phyblas/",
	"title": "phyblas",
	"tags": [],
	"description": "phyblas กำลังศึกษาต่ออยู่ที่มหาวิทยาลัยในไต้หวัน มีความสนใจในหลาย ๆ ด้าน เนื้อหาที่เขียนภายในบล็อกนี้ก็มีอยู่หลากหลาย ขึ้นอยู่กับความสนใจในแต่ละช่วง มีทั้งเรื่องราวท่องเที่ยว ซึ่งเน้นที่จีนและญี่ปุ่นเป็นหลัก นอกจากนี้ก็เขียนบันทึกประจำวัน ความรู้ทั่วไป ประสบการณ์ต่างๆ เรื่องราวรอบๆตัว แล้วก็เกี่ยวกับอนิเมะที่ดู เกมที่ได้เคยเล่นเป็นต้น",
	"content": "phyblas กำลังศึกษาต่ออยู่ที่มหาวิทยาลัยในไต้หวัน มีความสนใจในหลาย ๆ ด้าน เนื้อหาที่เขียนภายในบล็อกนี้ก็มีอยู่หลากหลาย ขึ้นอยู่กับความสนใจในแต่ละช่วง มีทั้งเรื่องราวท่องเที่ยว ซึ่งเน้นที่จีนและญี่ปุ่นเป็นหลัก นอกจากนี้ก็เขียนบันทึกประจำวัน ความรู้ทั่วไป ประสบการณ์ต่างๆ เรื่องราวรอบๆตัว แล้วก็เกี่ยวกับอนิเมะที่ดู เกมที่ได้เคยเล่นเป็นต้น\nReference : https://phyblas.hinaboshi.com/\n"
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/phyblas/intermediate/",
	"title": "ระดับกลาง(Intermediate)",
	"tags": [],
	"description": "",
	"content": "บทที่ ๑๗: การอ่านข้อมูลจากไฟล์\n※ open close read readlines readline seek tell with\nบทที่ ๑๘: การเขียนข้อมูลลงไฟล์\n※ write writelines shutil\nบทที่ ๑๙: การสร้างฟังก์ชัน\n※ def return global\nบทที่ ๒๐: ฟังก์ชันเวียนเกิด\n※\nบทที่ ๒๑: คำสั่งพิเศษบางตัวที่เกี่ยวข้องกับฟังก์ชัน\n※ lambda map filter any all\nบทที่ ๒๒: การสร้างคลาส\n※ class init\nบทที่ ๒๓: การรับทอด\n※ super\nบทที่ ๒๔: เมธอดและแอตทริบิวต์พิเศษของคลาส\n※ len str bool isinstance issubclass setattr getattr hasattr delattr\nบทที่ ๒๕: การจัดการกับข้อยกเว้น\n※ raise try except\nเกร็ดเล็กน้อย ⊟ [2016/04/30] สร้างแอตทริบิวต์ที่มีคุณสมบัติพิเศษในคลาสด้วย property\n⊟ [2018/05/31] ข้อควรระวังเมื่อใช้ try และ except แล้วต้องการหยุดโปรแกรมกลางคัน\n⊟ [2019/01/07] วิธีทำให้ import มอดูลที่ต้องการทุกครั้งเมื่อเริ่มโปรแกรม\n⊟ [2019/01/08] วิธีการรันไพธอนโดยตรงใน unix shell ใน mac และ linux\n⊟ [2019/01/12] ข้อควรระวังเมื่อมีการแก้ไขลิสต์ขณะใช้ for อาจทำให้เกิดการวนซ้ำไม่สิ้นสุดได้\n⊟ [2019/06/24] ทำความเข้าใจ and และ or ให้มากขึ้น\n⊟ [2019/07/13] เปรียบเทียบระหว่างการใช้ %, ใช้ format และใช้ f-string ใน python\nการประยุกต์ใช้ \u0026raquo; สารบัญแนะนำมอดูลต่างๆ \u0026raquo; สารบัญการเรียนรู้ของเครื่อง \u0026raquo; สารบัญโครงข่ายประสาทเทียม จิปาถะ ⊟ [2017/02/23] สร้างแฟร็กทัลอย่างง่าย\n⊟ [2018/03/26] ใช้ opencv (cv2) เพื่อค้นหาใบหน้าอนิเมะ\n⊟ [2018/03/29] ค้นหาภาพใบหน้าอนิเมะจากเว็บ safebooru\n⊟ [2018/07/14] สร้างเส้นโค้งฮิลแบร์ทสองมิติ\n"
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/learning-python/3_structure/",
	"title": "3. โครงสร้างของภาษา Python",
	"tags": [],
	"description": "ในบทนี้ คุณจะได้เรียนรู้และทำความเข้าใจเกี่ยวกับโครงของภาษา Python ในภาษาคอมพิวเตอร์นั้นมีโครงสร้างของภาษาเช่นเดียวกับภาษาของมนุษย์เรา ซึ่งสิ่งเหล่านี้ถูกกำหนดเพื่อเป็นรูปแบบและวิธีในการเขียนโปรแกรมในภาษา Python มันใช้สำหรับควบคุมวิธีที่คุณจะเขียนโค้ดของคุณเพื่อให้เข้าใจโดยตัวแปรภาษาหรือคอมไพเลอร์.",
	"content": "ในบทนี้ คุณจะได้เรียนรู้และทำความเข้าใจเกี่ยวกับโครงของภาษา Python ในภาษาคอมพิวเตอร์นั้นมีโครงสร้างของภาษาเช่นเดียวกับภาษาของมนุษย์เรา ซึ่งสิ่งเหล่านี้ถูกกำหนดเพื่อเป็นรูปแบบและวิธีในการเขียนโปรแกรมในภาษา Python มันใช้สำหรับควบคุมวิธีที่คุณจะเขียนโค้ดของคุณเพื่อให้เข้าใจโดยตัวแปรภาษาหรือคอมไพเลอร์.\nSimple Python program เพื่อเริ่มต้นการเรียนรู้ภาษา Python มาดูตัวอย่างของโปรแกรมอย่างง่าย โดยเป็นโปรแกรมที่ถามชื่อผู้ใช้และแสดงข้อความทักทายทางหน้าจอ มาเริ่มเขียนโปรแกรมแรกในภาษา Python ของคุณ ให้คัดลอกโปรแกรมข้างล่างแล้วนำไปรันใน IDE\nfirst.py\n# My first Python program name = input(\u0026#39;What is your name?\\\\n\u0026#39;) print (\u0026#39;Hi, %s.\u0026#39; % name) print (\u0026#39;Welcome to Python.\u0026#39;) ในตัวอย่าง เป็นโปรแกรมในการรับชื่อและแสดงข้อความทักทายออกทางหน้าจอ ในการรันโปรแกรม คุณสามารถรันได้หลายวิธี แต่ที่แนะนำคือการใช้ Python shell ให้คุณเปิด Python shell ขึ้นมาแล้วกดสร้างไฟล์ใหม่โดยไปที่ File -\u0026gt; New File จะปรากฏกล่อง Text editor ของภาษา Python ขึ้นมา เพื่อรันโปรแกรม Run -\u0026gt; Run Module หรือกด F5 โปรแกรมจะเปลี่ยนกลับไปยัง Python shell และเริ่มต้นทำงาน\nนี่เป็นผลลัพธ์การทำงานในการรันโปรแกรม first.py จาก Python shell ในตัวอย่างเราได้กรอกชื่อเป็น \u0026quot;Mateo\u0026quot; หลังจากนั้นโปรแกรมได้แสดงข้อความทักทายและจบการทำงาน ในตอนนี้คุณยังไม่ต้องกังวลว่าโปรแกรมในแต่ละบรรทัดทำงานอย่างไร ซึ่งเราจะอธิบายในต่อไป\nอีกวิธีหนึ่งสำหรับการรันโปรแกรมในภาษา Python อย่างที่เราได้บอกไปในบทก่อนหน้าคือรันผ่าน Command line ด้วยคำสั่งต่อไปนี้\npython first.py Module ในตัวอย่างโปรแกรมรับชื่อ เป็นโปรแกรมแรกของเราในบทเรียน Python นี้ เราได้บันทึกเป็นไฟล์ที่ชื่อว่า first.py ซึ่งไฟล์ของภาษา Python นั้นจะเรียกว่า Module ซึ่ง Module จะประกอบไปด้วยคลาส ฟังก์ชัน และตัวแปรต่างๆ และนอกจากนี้เรายังสามารถ import โมดูลอื่นเข้ามาในโปรแกรมได้ ซึ่งโมดูลอาจจะอยู่ภายใน package ซึ่งเป็นเหมือนโฟล์เดอร์ที่เอาไว้จัดกลุ่มของ Module ในตัวอย่าง first.py จึงเป็นโมดูลของโปรแกรมแรกของเรา\nComment คอมเมนต์ในภาษา Python นั้นเริ่มต้นด้วยเครื่องหมาย # คอมเมนต์สามารถเริ่มต้นที่ตำแหน่งแรกของบรรทัดและหลังจากนั้นจะประกอบไปด้วย Whilespace หรือโค้ดของโปรแกรม หรือคำอธิบาย ซึ่งโดยทั่วไปแล้วคอมเมนต์มักจะใช้สำหรับอธิบายซอสโค้ดที่เราเขียนขึ้นและมันไม่มีผลต่อการทำงานของโปรแกรม นี่เป็นตัวอย่างการคอมเมนต์ในภาษา Python\n# My first Python program \u0026#39;\u0026#39;\u0026#39; This is a multiline comment \u0026#39;\u0026#39;\u0026#39; print (\u0026#39;Hello Python.\u0026#39;) # Inline comment ในตัวอย่าง เราได้คอมเมนต์สามแบบด้วยกัน แบบแรกเป็นการคอมเมนต์แบบ single line แบบที่สองเป็นการคอมเมนต์แบบ multi-line และแบบสุดท้ายเป็นการคอมมเมนต์แบบ inline หรือการคอมเมนต์ภายในบรรทัดเดียวกัน\nStatement Statement คือคำสั่งการทำงานของโปรแกรม แต่ละคำสั่งในภาษา Python นั้นจะแบ่งแยกด้วยการขึ้นบรรทัดใหม่ ซึ่งจะแตกต่างจากภาษา C และ Java ซึ่งใช้เครื่องหมายเซมิโคลอน (;) ในการจบคำสั่งการทำงาน แต่อย่างไรก็ตาม ในภาษา Python นั้นคุณสามารถมีหลายคำสั่งในบรรทัดเดียวกันได้โดยการใช้เครื่องหมายเซมิโคลอน\nname = input(\u0026#39;What is your name?\\\\n\u0026#39;) print (\u0026#39;Hi, %s.\u0026#39; % name); print (\u0026#39;Welcome to Python.\u0026#39;); print (\u0026#39;Do you love it?\u0026#39;) ในตัวอย่าง เรามี 4 คำสั่งในโปรแกรม สองบรรทัดแรกเป็นคำสั่งที่ใช้บรรทัดใหม่ในการจบคำสั่ง ซึ่งเป็นแบบปกติในภาษา Python และบรรทัดสุดท้ายเรามีสองคำสั่งในบรรทัดเดียวที่คั่นด้วยเครืองหมายเซมิโคลอน (;) สำหรับการจบคำสั่ง\nIndentation and while space ในภาษา Python นั้นใช้ Whilespace และ Tab สำหรับกำหนดบล็อคของโปรแกรม เช่น คำสั่ง If Else For หรือการประกาศฟังก์ชัน ซึ่งคำสั่งเหล่านี้เป็นคำสั่งแบบล็อค โดยจำนวนช่องว่างที่ใช้นั้นต้องเท่ากัน มาดูตัวอย่างของบล็อคคำสั่งในภาษา Python\nn = int(input (\u0026#39;Input an integer: \u0026#39;)) if (n \u0026gt; 0): print (\u0026#39;x is positive number\u0026#39;) print (\u0026#39;Show number from 0 to %d\u0026#39; % (n - 1)) else: print (\u0026#39;x isn\\\\\u0026#39;t positive number\u0026#39;) for i in range(n): print(i) ในตัวอย่าง โปรแกรมของเรานั้นประกอบไปด้วย 3 บล็อคที่สร้างจาก 3 คำสั่ง คำสั่งแรกคือ If ในบล็อคนี้มีสองคำสั่งย่อยอยู่ภายใน ที่หัวของบล็อคจะต้องมีเครื่องหมายโคลอน (:) กำหนดหลังคำสั่ง if ในการเริ่มต้นบล็อคเสมอ อีกสองบล็อคสุดท้ายนั้นเป็นคำสั่ง else และ for ซึ่งแต่ละบล็อคมีหนึ่งคำสั่งย่อยอยู่ภายใน ในภาษา Python นั้นเข้มงวดกับช่องว่างภายในบล็อคมาก นั้นหมายความว่าทุกคำสั่งย่อยภายในบล็อคนั้นต้องมีจำนวนช่องว่างเท่ากันเสมอ\nn = int(input (\u0026#39;Input an integer: \u0026#39;)) # Invalid indent if (n \u0026gt; 0): print (\u0026#39;x is positive number\u0026#39;) print (\u0026#39;Show number from 0 to %d\u0026#39; % (n - 1)) # Valid indent else: print (\u0026#39;x isn\\\\\u0026#39;t positive number\u0026#39;) # Valid indent for i in range(n): print(i) นี่เป็นตัวอย่างการใช้งานช่องว่างที่ถูกต้องและไม่ถูกต้องภายในบล็อค ในคำสั่ง If นั้นไม่ถูกเพราะทั้งสองคำสั่งมีจำนวนช่องว่างที่ไม่เท่ากัน สำหรับในคำสั่ง Else และ For นั้นถูกต้อง\nLiterals ในการเขียนโปรแกรม Literal คือตัวอักษรหรือเครื่องหมายที่ใช้แสดงค่าของค่าคงที่ในโปรแกรม ในภาษา Python นั้นมี Literal ของข้อมูลประเภทต่างๆ เช่น Integer Floating-point number และ String หรือแม้กระทั่งตัวอักษรและ boolean นี่เป็นตัวอย่างของการกำหนด Literal ให้กับตัวแปรในภาษา Python\na = 1 b = -1.64E3 c = True d = \u0026#34;marcuscode.com\u0026#34; e = \u0026#39;A\u0026#39; ในตัวอย่าง เป็นการกำหนด Literal ประเภทต่างๆ ให้กับตัวแปร ในค่าที่เป็นแบบตัวเลขนั้นสามารถกำหนดค่าลงไปโดยตรงได้ทันทีและสามารถกำหนดในรูปแบบสั้นได้อย่างในตัวแปร b และสำหรับ boolean นั้นจะเป็น True ส่วน String หรือ Character นั้นจะต้องอยู่ภายในเครื่องหมาย double quote หรือ single quote เสมอ\nExpressions Expression คือการทำงานร่วมกันระหว่างตัวแปร (หรือค่าคงที่) และตัวดำเนินการ โดยค่าเหล่านี้จะมีตัวดำเนินการสำหรับควบคุมการทำงาน ในภาษา Python นั้นมี Expression อยู่สองแบบ แบบแรกคือ Boolean expression เป็นการกระทำกันระหว่างตัวแปรและตัวดำเนินการเปรียบเทียบค่าหรือตัวดำเนินการตรรกศาสตร์ และจะได้ผลลัพธ์เป็น Boolean\nและแบบที่สองคือ Expression ทางคณิตศาสตร์เป็นการกระทำกันระหว่างตัวแปรและตัวดำเนินการคณิตศาสตร์ และจะได้รับค่าใหม่เป็นตัวเลขหรือค่าที่ไม่ใช่ Boolean นี่เป็นตัวอย่างของ Expressions ในภาษา Python\na = 4 b = 5 # Boolean expressions print(a == 4) print(a == 5) print(a == 4 and b == 5) print(a == 4 and b == 8) # Non-boolean expressions print(a + b) print(a + 2) print(a * b) print(((a * a) + (b * b)) / 2) print(\u0026#34;Python \u0026#34; + \u0026#34;Language\u0026#34;) ในตัวอย่าง เรามีตัวแปร a และ b และกำหนดค่าให้กับตัวแปรเหล่านี้ และเราใช้ตัวแปรกับตัวดำเนินการประเภทต่างๆ ที่แสดง Expression ในรูปแบบของ Boolean expression ที่จะได้ผลลัพธ์สุดท้ายเป็นเพียงค่า True และ False เท่านั้น ส่วน Non-Boolean expression นั้นสามารถเป็นค่าใดๆ ที่ไม่ใช่ Boolean\nTrue False True False 9 6 20 20.5 Python Language นี่เป็นผลลัพธ์การทำงานของโปรแกรมในการทำงานของ Expression ในภาษา Python\nKeywords Keyword เป็นคำที่ถูกสงวนไว้ในการเขียนโปรแกรมภาษา Python เราไม่สามารถใช้คำสั่งเหล่านี้ในการตั้งชื่อตัวแปร ชื่อฟังก์ชัน คลาส หรือตัวระบุชื่อ ใดๆ ที่กำหนดขึ้นโดยโปรแกรมเมอร์ นี่เป็นรายการของ Keyword ในภาษา Python\nในบทนี้ คุณได้เรียนรู้เกี่ยวกับโครงสร้างของภาษา Python สิ่งเหล่านี้เป็นข้อกำหนดหรือกฎเกณฑ์ที่จำเป็นต้องใช้ในการเขียนโปรแกรม ซึ่งมันจะปรากฏในทุกๆ โปรแกรมที่คุณเขียน ในบทต่อไป เราจะเริ่มต้นเข้าสู่การเขียนโปรแกรมในภาษา Python\n Reference : http://marcuscode.com\n"
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/phyblas/advance/",
	"title": "ระดับสูง(Advance)",
	"tags": [],
	"description": "",
	"content": "บทที่ ๒๖: อิเทอเรเตอร์และเจเนอเรเตอร์\n※ yield next\nบทที่ ๒๗: การสร้างคลาสของอิเทอเรเตอร์\n※ iter iter next reversed\nบทที่ ๒๘: ฟังก์ชันบางส่วนที่เกี่ยวข้องกับอิเทอเรเตอร์\n※ zip enumerate itertools\nบทที่ ๒๙: การสร้างฟังก์ชันที่มีความซับซ้อน\n※\nบทที่ ๓๐: รู้จักกับเดคอเรเตอร์\n※ @\nบทที่ ๓๑: ทำความเข้าใจเดคอเรเตอร์มากยิ่งขึ้น\n※ functools.wraps functools.update_wrapper\nบทที่ ๓๒: การตกแต่งคลาสด้วยเดคอเรเตอร์\n※\nบทที่ ๓๓: เมธอดของคลาสและเมธอดสถิต\n※ classmethod staticmethod\nบทที่ ๓๔: การสร้างมอดูล\n※ imp.reload exec eval\nบทที่ ๓๕: การทำมอดูลเป็นแพ็กเกจ\n※\nบทที่ ๓๖: บทส่งท้าย\n※\nเกร็ดเล็กน้อย ⊟ [2016/04/30] สร้างแอตทริบิวต์ที่มีคุณสมบัติพิเศษในคลาสด้วย property\n⊟ [2018/05/31] ข้อควรระวังเมื่อใช้ try และ except แล้วต้องการหยุดโปรแกรมกลางคัน\n⊟ [2019/01/07] วิธีทำให้ import มอดูลที่ต้องการทุกครั้งเมื่อเริ่มโปรแกรม\n⊟ [2019/01/08] วิธีการรันไพธอนโดยตรงใน unix shell ใน mac และ linux\n⊟ [2019/01/12] ข้อควรระวังเมื่อมีการแก้ไขลิสต์ขณะใช้ for อาจทำให้เกิดการวนซ้ำไม่สิ้นสุดได้\n⊟ [2019/06/24] ทำความเข้าใจ and และ or ให้มากขึ้น\n⊟ [2019/07/13] เปรียบเทียบระหว่างการใช้ %, ใช้ format และใช้ f-string ใน python\nการประยุกต์ใช้ \u0026raquo; สารบัญแนะนำมอดูลต่างๆ \u0026raquo; สารบัญการเรียนรู้ของเครื่อง \u0026raquo; สารบัญโครงข่ายประสาทเทียม จิปาถะ ⊟ [2017/02/23] สร้างแฟร็กทัลอย่างง่าย\n⊟ [2018/03/26] ใช้ opencv (cv2) เพื่อค้นหาใบหน้าอนิเมะ\n⊟ [2018/03/29] ค้นหาภาพใบหน้าอนิเมะจากเว็บ safebooru\n⊟ [2018/07/14] สร้างเส้นโค้งฮิลแบร์ทสองมิติ\n"
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/learning-python/4_type/",
	"title": "4. ตัวแปรและประเภทข้อมูล",
	"tags": [],
	"description": "นบทนี้ คุณจะได้เรียนรู้เกี่ยวกับตัวแปรและประข้อมูลในภาษา Python เราจะพูดถึงการประกาศตัวแปรและการนำตัวแปรไปใช้งานในโปรแกรม และเราจะอธิบายถึงข้อมูลประเภทต่างๆ ที่เป็นประเภทข้อมูลพื้นฐาน (Primitive data type) ในภาษา Python และรวมทั้งฟังก์ชันสำหรับการใช้งานกับตัวแปร",
	"content": "ในบทนี้ คุณจะได้เรียนรู้เกี่ยวกับตัวแปรและประข้อมูลในภาษา Python เราจะพูดถึงการประกาศตัวแปรและการนำตัวแปรไปใช้งานในโปรแกรม และเราจะอธิบายถึงข้อมูลประเภทต่างๆ ที่เป็นประเภทข้อมูลพื้นฐาน (Primitive data type) ในภาษา Python และรวมทั้งฟังก์ชันสำหรับการใช้งานกับตัวแปร\nตัวแปร ตัวแปร (Variable) คือชื่อหรือเครื่องหมายที่กำหนดขึ้นสำหรับใช้อ้างถึงค่าที่เก็บในหน่วยความจำ ตัวแปรจะมีชื่อ (Identifier) สำหรับใช้ในการอ้างถึงข้อมูลของมัน ในการเขียนโปรแกรม ค่าของตัวแปรสามารถที่จะกำหนดได้ใน run-time หรือเปลี่ยนแปลงอยู่ตลอดเวลาในขณะที่โปรแกรมทำงาน (Executing)\nในการเขียนโปรแกรมคอมพิวเตอร์นั้น ตัวแปรจะแตกต่างจากตัวแปรในทางคณิตศาสตร์ ค่าของตัวแปรนั้นไม่จำเป็นต้องประกอบไปด้วยสูตรหรือสมการที่สมบูรณ์เหมือนกับในคณิตศาสตร์ ในคอมพิวเตอร์ ตัวแปรนั้นอาจจะมีการทำงานซ้ำๆ เช่น การกำหนดค่าในที่หนึ่ง และนำไปใช้อีกที่หนึ่งในโปรแกรม และนอกจากนี้ยังสามารถกำหนดค่าใหม่ให้กับตัวแปรได้ตลอดเวลา ต่อไปเป็นตัวอย่างของการประกาศตัวแปรในภาษา Python\na = 3 b = 4.92 c = \u0026#34;marcuscode.com\u0026#34; c = 10.5 ในตัวอย่าง เราได้ทำการประกาศ 3 ตัวแปร ในการประกาศตัวแปรในภาษา Python คุณไม่จำเป็นต้องระบุประเภทของตัวแปรในตอนที่ประกาศเหมือนในภาษา C ในตัวแปร a มีค่าเป็น 3 และมีประเภทเป็น Integer ตัวแปร b มีค่าเป็น 4.92 และมีประเภทเป็น Float และตัวแปร c มีค่าเป็น \u0026quot;marcuscode.com\u0026quot; และเป็นประเภท String ภายหลังเราได้เปลี่ยนค่าของตัวแปร c เป็น 10.5 และตัวแปรกลายเป็นประเภท Float แทน\na, b = 1, 2 x = y = z = 10 print(\u0026#34;a = \u0026#34; , a) print(\u0026#34;b = \u0026#34; , b) print(\u0026#34;x = \u0026#34; , x) print(\u0026#34;y = \u0026#34; , y) print(\u0026#34;z = \u0026#34; , z) ในภาษา Python นั้นสนับสนุนการกำหนดค่าให้กับตัวแปรหลายค่าในคำสั่งเดียว ในตัวอย่าง เป็นการกำหนดค่า 1 และ 2 กับตัวแปร a และ b ตามลำดับ และในคำสั่งต่อมาเป็นการกำหนดค่า 10 ให้กับตัวแปร x y และ z ซึ่งทำให้การเขียนโปรแกรมสะดวกและรวดเร็วมากขึ้น\na = 1 b = 2 x = 10 y = 10 z = 10 นี่เป็นผลลัพธ์การทำงานของโปรแกรม\nต่อไปจะเป็นการพูดถึงประเภทข้อมูลชนิดต่างๆ ที่ภาษา Python สนับสนุน ซึ่งจะมีอยู่สามประเภทใหญ่ๆ คือ ข้อมูลแบบตัวเลข นั้นจะแบ่งย่อยออกเป็น Integer และ Float ข้อมูลประเภท String และข้อมูลแบบลำดับ เช่น List และ Tuple ประเภทข้อมูลทั้งหมดนี้เป็น Built-in type ในภาษา Python\nNumbers ในภาษา Python นั้นสนับสนุนข้อมูลแบบตัวเลข ซึ่งข้อมูลประเภทนี้จะแบ่งออกเป็น Integer Float Decimal และ Complex อย่างไรก็ตามเราจะเน้นย้ำใน Integer ซึ่งเป็นการเก็บข้อมูลแบบจำนวนเต็ม และ Float เป็นข้อมูลแบบจำนวนจริง สำหรับประเภทแบบ Decimal นั้นแตกต่างไปจาก Float คือสามารถเก็บความละเอียดของจุดทศนิยมได้มากกว่า นอกจากนี้ Python ยังสนับสนุนตัวเลขในรูปแบบ Complex ที่แสดงในแบบ a +bj ต่อไปเป็นตัวอย่างในการประกาศและใช้งานตัวแปรแบบตัวเลขในภาษา Python\n# Integer a = 7 b = 3 c = a + b d = a / b print (\u0026#39;a = %d\u0026#39; % a) print (\u0026#39;b = %d\u0026#39; % b) print (\u0026#39;c = %d\u0026#39; % c) print (\u0026#39;d = \u0026#39;, d) ในตัวอย่าง เป็นการประกาศและใช้งานตัวแปรประเภท Integer เราได้ทำการประกาศตัวแปรและกำหนดค่าให้กับ a และ b ในการแสดงผลในรูปแบบของ String format กับฟังก์ชัน print() นั้นจะใช้ specifier เป็น %d เราสามารถกำหนดค่าให้กับตัวแปรได้โดย Literal หรือ Expression\nสิ่งหนึ่งที่น่าสังเกตในการหารตัวเลขในภาษา Python การหารตัวเลขนั้นจะได้ค่าเป็น Float เสมอ ถึงแม้ตัวเลขทั้งสองจะเป็น Integer ก็ตาม เช่นในตัวแปร d ซึ่งแตกต่างจากภาษา C ที่เมื่อตัวเลขทั้งสองเป็นแบบ Integer จะได้ผลลัพธ์เป็น Integer\na = 7 b = 3 c = 10 d = 2.3333333333333335 นี่เป็นผลลัพธ์การทำงานของโปรแกรม\n# Floating point number speed = 34.12 pi = 22 / 7 height = 2.31E5 length = 1.3E-3 print (\u0026#39;speed = %f\u0026#39; % speed) print (\u0026#39;pi = %f\u0026#39; % pi) print (\u0026#39;height = %f\u0026#39; % height) print (\u0026#39;length = %f\u0026#39; % length) print (pi) ต่อไปเป็นการประกาศและใช้งานตัวแปรประเภท Float หรือตัวเลขที่มีจุดทศนิยม ในการกำหนดค่าให้กับตัวแปรนั้น เมื่อคุณกำหนดตัวเลขมีจุดมันจะเป็นประเภท Float อัตโนมัติ เราสามารถกำหนดค่าโดยตรงหรือในรูปแบบของ Expression ได้ และนอกจากนี้ ในภาษา Python ยังสามารถกำหนดในรูปแบบสัญกรณ์วิทยาศาสตร์ได้เหมือนในตัวแปร height ซึ่งหมายถึง 2.31 x 10 ^ 5 และในตัวแปร length ซึ่งหมายถึง 1.3 x 10 ^ -3\nspeed = 34.120000 pi = 3.142857 height = 231000.000000 length = 0.001300 3.142857142857143 นี่เป็นผลลัพธ์การทำงานของโปรแกรม ซึ่งในการแสดงผลของข้อมูลประเภท Float กับการจัดรูปแบบของตัวเลขนั้นจะใช้ %f และสำหรับการดูค่าเต็มของตัวเลขจริงๆ นั้นเราจะแสดงค่าของตัวเลขผ่านฟังก์ชัน print โดยตรง เหมือนในคำสั่งแสดงผลค่าของ pi ในบรรทัดสุดท้าย\nStrings Strings เป็นประเภทข้อมูลที่สำคัญและใช้งานทั่วไปในการเขียนโปรแกรม ในภาษาเขียนโปรแกรมส่วนมากแล้วจะมีประเภทข้อมูลแบบ String และในภาษา Python เช่นกัน String เป็นลำดับของตัวอักษรหลายตัวเรียงต่อกัน ซึ่งในภาษา Python นั้น String จะอยู่ในเครื่องหมาย Double quote หรือ Single quote เท่านั้น นอกจากนี้ในภาษา Python ยังมีฟังก์ชันในการจัดการกับ String มากมาย ซึ่งเราจะพูดอีกครั้งในบทของ String ในบทนี้มาทำความรู้จักกับ String เบื้องต้นกันก่อน\nname = \u0026#34;Mateo\u0026#34; country = \u0026#34;Ukrain\u0026#34; language = \u0026#39;Python\u0026#39; interest = \u0026#39;Mountain Everest\u0026#39; ในตัวอย่าง เป็นการประกาศตัวแปรประเภท String สองตัวแปรแรกเป็นการประโดยการใช้ Double quote และสองตัวแปรต่อมาเป็นการใช้ Single quote ซึ่งคุณสามารถใช้แบบไหนก็ได้ แต่มีสิ่งที่แตกต่างกันเล็กน้อยคือเกี่ยวกับการกำหนดตัวอักษรพิเศษหรือเรียกว่า Escape character\nsentent1 = \u0026#34;What\u0026#39;s your name?\u0026#34; sentent2 = \u0026#39;I\\\\\u0026#39;m Mateo.\u0026#39; sentent3 = \u0026#34;He said \\\\\u0026#34;I would learn Python first\\\\\u0026#34;.\u0026#34; sentent4 = \u0026#39;His teach replied \u0026#34;Oh well!\u0026#34;\u0026#39; print (sentent1) print (sentent2) print (sentent3) print (sentent4) ในตัวอย่าง เป็นสิ่งที่แตกต่างของการประกาศ String ทั้งสองแบบกับ Escape character ตัวอักษร ' และ \u0026quot; นั้นเป็น Escape character ดังนั้นในการใช้งานตัวอักษรเหล่านี้ เราจะต้องทำการใส่เครื่องหมาย \\\\ ลงไปข้างหน้าเสมอ แต่ในภาษา Python เมื่อคุณใช้ Double quote ในการประกาศ String คุณไม่ต้องทำการ Escape character สำหรับ Single quote และในทางกลับกัน อย่างไรก็ตามเราจะพูดอีกครั้งในบทของ String\nWhat\u0026#39;s your name? I\u0026#39;m Mateo. He said \u0026#34;I would learn Python first\u0026#34;. His teach replied \u0026#34;Oh well!\u0026#34; นี่เป็นผลลัพธ์การทำงานของโปรแกรมในการใช้งาน Escape character ในภาษา Python\nsite = \u0026#39;marcuscode\u0026#39; + \u0026#39;.com\u0026#39; tutorial = \u0026#39;Python\u0026#39; \u0026#39; Language\u0026#39; print(site) print(tutorial) การทำงานอย่างหนึ่งที่สำคัญเกี่ยวกับ String ก็คือการเชื่อมต่อ String ซึ่งเป็นการนำ String ตั้งแต่สองอันขึ้นไปมาต่อกัน ในภาษา Python คุณสามารถต่อ String ได้โดยการใช้เครื่องหมาย + หรือคั่นด้วยช่องว่างหรือบรรทัดใหม่เหมือนในตัวอย่างข้างบน\nmarcuscode.com Python Language นี่เป็นผลลัพธ์การทำงานของโปรแกรม\nอย่างไรก็ตาม นี่เป็นการแนะนำเกี่ยวกับ String ในเบื้องต้นเท่านั้น เพราะว่า String นั้นมีเนื้อหาเป็นจำนวนมาก คุณจะได้เรียนรู้เกี่ยวกับ String อย่างละเอียด อีกครั้งในบทของ String\nLists Lists เป็นประเภทข้อมูลที่เก็บข้อมูลแบบเป็นชุดและลำดับ กล่าวคือมันสามารถเก็บข้อมูลได้หลายค่าในตัวแปรเดียว และมี Index สำหรับเข้าถึงข้อมูล ในภาษา Python นั้น List จะเป็นเหมือนอาเรย์ในภาษา C มันสามารถเก็บข้อมูลได้หลายตัวและยังสามารถเป็นประเภทข้อมูลที่แตกต่างกันได้อีกด้วย มาดูการประกาศและใช้งาน List ในเบื้องต้น\n# Declare lists numbers = [1, 2, 4, 6, 8, 19] names = [\u0026#34;Mateo\u0026#34;, \u0026#34;Danny\u0026#34;, \u0026#34;James\u0026#34;, \u0026#34;Thomas\u0026#34;, \u0026#34;Luke\u0026#34;] mixed = [-2, 5, 84.2, \u0026#34;Mountain\u0026#34;, \u0026#34;Python\u0026#34;] # Display lists print(numbers) print(names) print(mixed) # Display lists using the for loops for n in numbers: print(n, end=\u0026#34; \u0026#34;) print() for n in names: print(n, end=\u0026#34; \u0026#34;) print() for n in mixed: print(n, end=\u0026#34; \u0026#34;) print() ในตัวอย่าง เราได้ทำการประกาศ 3 Lists โดยตัวแปรแรกนั้นเป็น List ของตัวเลข และตัวแปรที่สองเป็น List ของ String และตัวแปรสุดท้ายเป็น List แบบรวมกันของประเภทข้อมูล เราใช้ฟังก์ชัน print() ในการแสดงผลข้อมูลใน List และใช้คำสั่ง For loop ในการอ่านค่าในลิสต์และนำมาแสดงผลเช่นกัน\n[1, 2, 4, 6, 8, 19] [\u0026#39;Mateo\u0026#39;, \u0026#39;Danny\u0026#39;, \u0026#39;James\u0026#39;, \u0026#39;Thomas\u0026#39;, \u0026#39;Luke\u0026#39;] [-2, 5, 84.2, \u0026#39;Mountain\u0026#39;, \u0026#39;Python\u0026#39;] 1 2 4 6 8 19 Mateo Danny James Thomas Luke -2 5 84.2 Mountain Python นี่เป็นผลการทำงานของโปรแกรม\nlanguages = [\u0026#34;C\u0026#34;, \u0026#34;C++\u0026#34;, \u0026#34;Java\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;PHP\u0026#34;] print(\u0026#34;Index at 0 = \u0026#34;, languages[0]) print(\u0026#34;Index at 3 = \u0026#34;, languages[3]) languages[0] = \u0026#34;Scalar\u0026#34; print(\u0026#34;Index at 0 = \u0026#34;, languages[0]) Lists นั้นทำงานกับ Index ดังนั้นเราสามารถเข้าถึงข้อมูลของ List โดยการใช้ Index ของมันได้ ในตัวอย่างเป็นการเข้าถึงข้อมูลภายใน Index ซึ่ง Index ของ List นั้นจะเริ่มจาก 0 ไปจนถึงจำนวนทั้งหมดของมันลบด้วย 1 ในตัวอย่างเราได้แสดงผลข้อมูลของสอง List ในตำแหน่งแรกและในตำแหน่งที่ 4 ด้วย Index 0 และ 3 ตามลำดับ หลังจากนั้นเราเปลี่ยนค่าของ List ที่ตำแหน่งแรกเป็น \u0026quot;Scalar\u0026quot;\nIndex 0 = C Index 3 = Python Index 0 = Scalar นี่เป็นผลลัพธ์การทำงานของโปรแกรม ซึ่งคุณได้ทำความรู้จักกับ List ในเบื้องต้น คุณจะได้เรียนรู้เกี่ยวกับ List ในภาษา Python อย่างละเอียดอีกครั้งในบทของ List ซึ่งเราจะพูดเกี่ยวกับการดำเนินการและการใช้ฟังก์ชันของ List นอกจากนี้ Python ยังมีประเภทข้อมูลแบบ Tuple และ Dictionary ซึ่งมีรูปแบบการเก็บข้อมูลคล้ายกับ List จึงคุณจะได้เรียนในบทต่อไป\nฟังก์ชันที่ใช้กับตัวแปร ในภาษา Python นั้นมีฟังก์ชันที่สร้างมาเพื่อให้ใช้งานกับตัวแปร เช่น ฟังก์ชันสำหรับหาขนาดของตัวแปร ฟังก์ชันในการหาประเภทของตัวแปร ฟังก์ชันลบตัวแปรออกไปจากหน่วยความจำ และฟังก์ชันในการตรวจสอบว่าตัวแปรมีอยู่หรือไม่ ซึ่งในบางครั้งการเขียนโปรแกรมก็จำเป็นที่คุณอาจจะต้องมีการตรวจสอบสิ่งเหล่านี้ในขณะที่โปรแกรมทำงาน นี่เป็นตัวอย่างการใช้งาน\nimport sys a = 8 b = 13.4 c = \u0026#34;Python\u0026#34; d = [1, 2, 3, 4] print(\u0026#39;Size of a = \u0026#39;, sys.getsizeof(a)) print(\u0026#39;Type of a = \u0026#39;, type(a)) print(\u0026#39;Size of b = \u0026#39;, sys.getsizeof(b)) print(\u0026#39;Type of b = \u0026#39;, type(b)) print(\u0026#39;Size of c = \u0026#39;, sys.getsizeof(c)) print(\u0026#39;Type of c = \u0026#39;, type(c)) print(\u0026#39;Size of d = \u0026#39;, sys.getsizeof(d)) print(\u0026#39;Type of d = \u0026#39;, type(d)) del a del b, c, d if \u0026#39;a\u0026#39; in locals(): print(\u0026#34;a is exist\u0026#34;) else: print(\u0026#34;a is not exist\u0026#34;) ในตัวอย่าง เราได้ประกาศตัวแปรประเภทต่างๆ เราได้ฟังก์ชัน getsizeof() สำหรับหาขนาดของตัวแปรที่มีหน่วยเป็น Byte และฟังก์ชัน type() สำหรับดูประเภทของตัวแปรว่าอยู่ในคลาสไหน ฟังก์ชัน del() สำหรับยกเลิกหรือลบการประกาศตัวแปรออกไปจากหน่วยความจำ และสุดท้ายเป็นการตรวจสอบว่าตัวแปรถูกประกาศแล้วหรือยังในฟังก์ชัน locals() สำหรับตรวจสอบตัวแปรในโมดูลปัจจุบัน หรือ globals() สำหรับตรวจสอบตัวแปรในโปรแกรมทั้งหมด\nSize of a = 14 Type of a = \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; Size of b = 16 Type of b = \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; Size of c = 31 Type of c = \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; Size of d = 52 Type of d = \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; a is not exist นี่เป็นผลลัพธ์การทำงานของโปรแกรมในการใช้ฟังก์ชันที่จำเป็นกับตัวแปร\nในบทนี้ คุณได้เรียนรู้เกี่ยวกับตัวแปรและประเภทข้อมูลในภาษา Python เราได้พูดถึงการประกาศและการใช้งานตัวแปร รวมถึงข้อมูลประเภทต่างๆ ในภาษา Python เช่น ตัวเลข String และ List และนอกจากนี้เรายังแนะนำให้คุณรู้จักกับฟังก์ชันที่มีความจำเป็นในการทำงานกับตัวแปร\n Reference : http://marcuscode.com/lang/python/variables-and-types\n "
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/phyblas/beginer/basic_functin/",
	"title": "ฟังก์ชันพื้นฐาน",
	"tags": [],
	"description": "",
	"content": "ความหมายของฟังก์ชัน คำว่าฟังก์ชัน (function) เป็นคำที่น่าจะเคยได้ยินอยู่บ่อยๆ แต่คำนี้จริงๆมีความหมายอยู่หลากหลายมาก ขึ้นอยู่กับว่าคุยกันเรื่องอะไร\nหลายคนอาจเคยได้ยินคำนี้ครั้งแรกกันตอนเรียนคณิตศาสตร์ชั้นมัธยมศึกษา\nคำว่าฟังก์ชันในทางคณิตศาสตร์หมายถึงสิ่งที่แสดงความสัมพันธ์ระหว่างจำนวน โดยใส่ค่าตัวเลขลงไปจำนวนหนึ่ง แล้วจะได้ค่าตัวเลขอีกจำนวนหนึ่งคืนกลับมา เช่น\nf(x) = (x+0.5)/10 ในที่นี้ f เป็นฟังก์ชัน และ x คืออาร์กิวเมนต์ของฟังก์ชัน อาร์กิวเมนต์ คือค่าที่อยู่ในวงเล็บหลังฟังก์ชัน เป็นค่าที่ป้อนให้กับฟังก์ชัน เพื่อให้ฟังก์ชัน นำค่านั้นไปดำเนินการทำอะไรบางอย่าง ในที่นี้หากป้อนค่า x เป็น 0.5 ค่านี้ก็จะถูกนำไปคำนวณ\nf(0.5) = (0.5+0.5)/10 = 0.1 ผลที่ได้คือฟังก์ชันนี้คืน 0.1 ออกมา ค่า 0.1 นี้จะเรียกว่าค่าคืนกลับ (return)\nฟังก์ชันในทางภาษาคอมพิวเตอร์ ก็มีลักษณะคล้ายกันนี้ คือใส่ค่าอะไรบางอย่าง (อาร์กิวเมนต์) ลงไปแล้วก็จะมีค่าคืนกลับออกมา\nในบทที่แล้วได้พูดถึงคำสั่ง int float str bool ซึ่งใช้แปลงชนิดของข้อมูลเพื่อให้เป็นชนิดตามนั้น โดยใส่ข้อมูลชนิดเก่าลงไปแล้วได้ค่าคืนกลับเป็นข้อมูลชนิดใหม่ เช่น\na = 1.111 b = int(a) print(b) # ได้ 1 ในตัวอย่างนี้ a เป็นจำนวนจริงซึ่งมีเลขทศนิยม แต่ใช้คำสั่ง int เพื่อแปลงเป็นจำนวนเต็มแล้วคืนค่ากลับมาแล้วเก็บค่าไว้ใน b ผลก็คือ b ได้ค่าเป็น 1 โดยเศษถูกปัดทิ้งหมด คำสั่งที่ใช้แปลงชนิดข้อมูลเหล่านี้ถือว่าเป็นฟังก์ชันชนิดหนึ่งในภาษาไพธอน\nที่จริงหากว่ากันในรายละเอียดจริงๆแล้ว int float str bool เป็นชื่อคลาส (ชื่อชนิดข้อมูล) อย่างไรก็ตามชื่อคลาสสามารถใช้ทำหน้าที่เหมือนเป็นฟังก์ชันเพื่อสร้างออบเจกต์ในคลาสนั้นอยู่แล้ว จึงถือว่าเป็นฟังก์ชันด้วย หรืออีกตัวอย่างหนึ่งคือฟังก์ชันที่ชือว่า len ซึ่งมีไว้สำหรับหาความยาวของสายอักขระ\nlen(\u0026#39;sawatdi\u0026#39;) # ได้ 7 ในที่นี้ \u0026lsquo;sawatdi\u0026rsquo; เป็นอาร์กิวเมนต์ของฟังก์ชัน len แล้ว 7 เป็นค่าคืนกลับที่ได้มา อย่างไรก็ตามฟังก์ชัน ในภาษาคอมพิวเตอร์นั้น นอกจากจะมีหน้าที่คืนค่ากลับมาแล้วก็ยัง มีอีกหน้าที่ที่สำคัญ นั่นคือดำเนินการบางอย่างให้เกิดผลอะไรบางอย่างขึ้น โดยอาจจะไม่มีการคืนค่ากลับมาเลยก็ได้ เช่นคำสั่ง print ซึ่งใช้มาตั้งแต่บทที่ ๒ แล้ว ก็ถือเป็นฟังก์ชันชนิดหนึ่ง ซึ่งกรณีของ print นั้น อาร์กิวเมนต์ที่ใส่เข้าไปคือสิ่งที่เราต้องการให้แสดงผลออกมา เช่น\nprint(\u0026#39;sawatdi\u0026#39;) ในที่นี้ \u0026lsquo;sawatdi\u0026rsquo; คืออาร์กิวเมนต์ เมื่อใส่ลงไปในฟังก์ชัน print ฟังก์ชันก็จะทำข้อความ ไปแสดงผลออกมาทางหน้าจอ จะเห็นว่าไม่ว่าฟังก์ชันไหนก็ตาม จะมีรูปแบบเหมือนกันก็คือ ชื่อฟังก์ชัน ตามด้วยวงเล็บเปิดและปิด ( ) ซึ่งภายในวงเล็บจะใส่อาร์กิวเมนต์ที่ฟังก์ชันต้องการ และฟังก์ชันก็จะนำค่าอาร์กิวเมนต์ไปทำอะไรบางอย่างและอาจมีการคืนค่ากลับมาหรือไม่ก็ได้\nอีกอย่างที่ต้องเน้นสักหน่อยก็คืออาร์กิวเมนต์อาจเป็นค่าข้อมูลหรือตัวแปรที่เก็บข้อมูลอยู่ก็ได้ ตัวแปรที่ถูกใช้เป็นอาร์กิวเมนต์ในฟังก์ชันมักจะไม่มีการเปลี่ยนแปลงอะไร แค่ถูกนำค่าไปใช้เท่านั้น เช่น\nc = 2.222 d = str(c) print(d) # ได้ \u0026#39;2.222\u0026#39;  print(c) # ได้ 2.222 จะเห็นว่า c ถูกใช้ในฟังก์ชัน str เพื่อให้ได้ค่า d เป็นสายอักขระ แต่ว่า c ยังเป็นตัวเลขอยู่เหมือนเดิมไม่เปลี่ยนแปลง อย่างไรก็ตาม ฟังก์ชันที่ทำให้เกิดความเปลี่ยนแปลงกับอาร์กิวเมนต์ที่ใส่เข้าไปก็มีอยู่เช่นกัน\nอาร์กิวเมนต์หลายตัว อาร์กิวเมนต์ไม่จำเป็นที่จะต้องมีแค่ตัวเดียว อาจมีหลายตัวก็ได้ หากมีหลายตัวก็ ต้องคั่นด้วยเครื่องหมายจุลภาค , เช่น\nprint(\u0026#39;a =\u0026#39;, 1, \u0026#39;, b =\u0026#39;, 2) # ได้ a = 1 , b = 2 จะเห็นกว่าในนี้มีการใส่อาร์กิวเมนต์ถึง ๔ ตัว โดยแต่ละตัวก็คือสิ่งที่ต้องการให้แสดงผลออกมา โดยทั่วไปแล้วฟังก์ชัน print สามารถนำออกข้อมูลได้กี่อันก็ได้ จึงถือว่ามีอาร์กิวเมนต์ แบบไม่จำกัดจำนวน จำนวนอาร์กิวเมนต์ที่แต่ละฟังก์ชันต้องการนั้นอาจไม่เท่ากัน บางฟังก์ชันอาจต้องการหลายตัว หรือบางฟังก์ชันอาจไม่ต้องใช้อาร์กิวเมนต์เลย ซึ่งในกรณีนั้นจะใส่เป็นวงเล็บเปิดแล้วก็ปิดทันที () เช่นฟังก์ชัน input ซึ่งจะยกตัวอย่างให้เห็นต่อไป\nคีย์เวิร์ดของฟังก์ชัน นอกจาก อาร์กิวเมนต์แล้ว ฟังก์ชันยังอาจประกอบด้วยสิ่งที่เรียกว่าคีย์เวิร์ด (keyword) ซึ่งเป็นอีกสิ่งหนึ่งที่สามารถป้อนให้กับฟังก์ชันได้ แต่ต่างจากอาร์กิวเมนต์ตรงที่ว่า การป้อนคีย์เวิร์ดจะต้องใส่ชื่อของ คีย์เวิร์ดนั้น ยกตัวอย่างการใช้คีย์เวิร์ดในฟังก์ชัน print\nprint(\u0026#39;ฉันมีความสุข\u0026#39;,\u0026#39;555\u0026#39;,\u0026#39;๕๕๕\u0026#39;,\u0026#39;อยากหัวเราะดังๆ\u0026#39;,sep=\u0026#39;(^_^)\u0026#39;) ผลลัพธ์\nฉันมีความสุข(^_^)555(^_^)๕๕๕(^_^)อยากหัวเราะดังๆ ตัวอย่าง นี้จะเห็นว่าประกอบไปด้วยอาร์กิวเมนต์ ๔ ตัว และด้านหลังอาร์กิวเมนต์ หลังจุลภาคตัวสุดท้ายจะเห็น sep=\u0026rsquo;(^_^)\u0026rsquo; ซึ่ง sep นี้ก็คือคีย์เวิร์ดที่ใส่เพิ่มลงไปนั่นเอง\nความหมายของ sep ในฟังก์ชัน print ก็คือคำที่ใช้แยกระหว่างอาร์กิวเมนต์แต่ละตัวที่ใส่ลงไป ดังนั้นจึงจะเห็นได้ว่ามี (^_^) ปรากฏขึ้นมาแทรก โดยปกติแล้วถ้าหาก ไม่พิมพ์ sep ลงไปฟังก์ชันก็ยังทำงานได้ปกติ เพียงแต่ตัวคั่นระหว่างแต่ละอาร์กิวเมนต์จะกลายเป็นการเว้นวรรค ดังที่เห็นในตัวอย่างที่แล้ว การเพิ่มคีย์เวิร์ดเข้ามาจึงเป็นแค่การแต่งเสริมเพิ่มเติม นอกจาก sep แล้วก็ยังมีคีย์เวิร์ดสำคัญอีกตัวคือ end ซึ่งเป็นตัวกำหนดการสิ้นสุดประโยค\nprint(\u0026#39;การฝึกฝนที่ไม่มีความเจ็บปวดมันไม่มีความหมาย\u0026#39;,end=\u0026#39; \u0026#39;) print(\u0026#39;เพราะคนเราไม่สามารถได้อะไรมาโดยที่ไม่ต้องเสียสละอะไร\u0026#39;,end=\u0026#39; \u0026#39;) print(\u0026#39;แต่ว่าเมื่อทนความเจ็บปวดนั้นและก้าวผ่านมันไปได้\u0026#39;,end=\u0026#39;\u0026#39;) print(\u0026#39;ถึงตอนนั้นคนเราก็จะมีจิตใจที่แกร่งกล้าไม่แพ้ใครๆ\u0026#39;,end=\u0026#39;!\u0026#39;) (ที่มาของประโยค)\nผลลัพธ์\nการฝึกฝนที่ไม่มีความเจ็บปวดมันไม่มีความหมาย เพราะคนเราไม่สามารถได้อะไรมาโดยที่ไม่ต้องเสียสละอะไร แต่ว่าเมื่อทนความเจ็บปวดนั้นและก้าวผ่านมันไปได้ถึงตอนนั้นคนเราก็จะมี จิตใจที่แกร่งกล้าไม่แพ้ใครๆ! โดยปกติแล้วถ้าไม่ใส่คีย์เวิร์ด end ลงไปพอจบฟังก์ชัน print จะมีการขึ้นบรรทัดใหม่ นั่นเพราะโดยปกติถูกกำหนดให้สิ้นสุดด้วย \\n ซึ่งหมายถึงขึ้นบรรทัดใหม่ แต่ถ้าใส่ end ลงไปเราจะสามารถเปลี่ยนเป็นจบด้วยอะไรก็ได้ ถ้าต้องการให้ติดกันเลยก็พิมพ์ '\u0026rsquo;\nทั้ง sep และ end ใช้ได้เฉพาะไพธอน 3 ส่วนไพธอน 2 จะใช้วิธีที่ต่างกันออกไป\nรายละเอียด\nการคืนกลับและการส่งออก มีอีกเรื่องที่พูดถึงไปแล้วเล็กน้อยในบทที่ ๒ แต่ก็ควรต้องนำมากล่าวย้ำตรงนี้ด้วย นั่นคือความแตกต่างระหว่างระหว่างการคืนกลับ (return) และการส่งออก (output) ซึ่งอาจสร้างความสับสนได้ การคืนกลับหมายถึงการที่ได้ค่าอะไรออกมา จากฟังก์ชันหรือการคำนวณต่าง ๆ โดยค่าที่ได้มานั้น จะยังไม่ปรากฏออกมาให้เห็น แต่เก็บอยู่ภายในหน่วยความจำของเครื่อง\nส่วนการส่งออกนั้นหมายถึงการที่ค่านั้นถูกนำออกมาแสดงผล ให้เราได้เห็น โดยทั่วไปคือออกมาบนหน้าจอ เป็นข้อความ ซึ่งการส่งออกที่พื้นฐานที่สุดก็คือการใช้ฟังก์ชัน print\nฟังก์ชัน print นั้นไม่ได้ทำให้เกิดค่าอะไรคืนกลับมา แต่แค่ทำหน้าที่ส่งออกค่าที่เราป้อนเข้าไปให้\nที่อาจทำให้สับสนได้คือ เวลาที่คำนวณหรือใช้ฟังก์ชันอะไรที่มีค่าคืนกลับมาแล้วไม่มีตัวแปรอะไรมารับ หากทำผ่านเชลมันจะส่งค่าที่คืนกลับมาให้เห็นด้วย ในขณะที่ถ้าทำผ่านอีดิเตอร์ จะไม่มีการส่งออกมาแสดงผล เช่นหากพิมพ์ float(\u0026lsquo;129.3\u0026rsquo;) ในเชลก็จะได้ค่า 129.3 ออกมาพร้อมแสดงออกมาทันทีโดยไม่ต้องใช้ print อย่างไรก็ตาม ความจริงแล้วการแสดงผลค่าคืนกลับผ่านทางเชลนั้นไม่ได้เหมือนฟังก์ชัน print เสมอไป และฟังก์ชันที่สามารถส่งออกข้อมูลมาแสดงผลได้ก็ไม่ได้มีแต่ print ซึ่งตรงนี้จะค่อยมาพูดกันต่อไป\nฟังก์ชัน input สิ่งที่ตรงข้ามกับการส่งออกข้อมูลก็คือการป้อนเข้า (input) ในภาษาไพธอนฟังก์ชัน ที่ใช้ในการป้อนเข้าข้อมูลชื่อฟังก์ชัน input ตัวอย่างการใช้ ลองพิมพ์ตามนี้ลงในเชล\na = input() เสร็จแล้วโปรแกรมก็จะให้เราพิมพ์ข้อความอะไรบางอย่างใส่เพิ่มลงไป ก็ให้พิมพ์อะไรก็ได้ลงไปแล้วกด enter เสร็จแล้วข้อความที่ใส่ลงไปนั้นก็จะถูกเก็บอยู่ในตัวแปร a จากนั้นลองใช้คำสั่ง print เพื่อพิมพ์สิ่งที่เก็บอยู่ในตัวแปร a ออกมา\nprint(\u0026#39;a คือ\u0026#39;,a) ก็จะได้ข้อความที่เราพิมพ์ลงไปนั้นออกมา นี่เป็นวิธีการใช้ฟังก์ชัน input เพื่อรับค่ามาเก็บไว้ในตัวแปร ในที่นี้จะเห็นว่า input ป็นฟังก์ชัน ที่ทำหน้าที่ทั้งดำเนินการอะไรบางอย่างซึ่งในที่นี้คือสั่งให้ รับค่าจากคีย์บอร์ด และสุดท้ายก็ยังคืนค่ากลับออกมาด้วย อย่างไรก็ตามฟังก์ชัน input นั้นที่จริงแล้วไม่ได้ทำหน้าที่แค่รับค่าเพียงอย่างเดียว แต่ยังสามารถทำหน้าที่แสดงผลข้อความไปด้วยในเวลาเดียวกันด้วย ในตัวอย่างข้างต้น จะเห็นว่าในวงเล็บหลัง input นั้นว่างเปล่า ไม่ได้ใส่อะไรลงไป แต่ที่จริงแล้วฟังก์ชัน input เองก็สามารถใส่อาร์กิวเมนต์ลงไปได้ ซึ่งพอใส่ลงไปแล้ว สิ่งนั้นจะกลายเป็น ข้อความที่เราต้องการให้แสดงผลออกมาก่อนที่จะให้ป้อนข้อความ โดยทั่วไปเหมือนเป็น ข้อความที่ใช้บอกให้ผู้ใช้รู้ว่าจะต้องป้อนอะไร ขอยกตัวอย่างการใช้ เช่น ลองพิมพ์\na = input(\u0026#39;จงป้อนค่าอะไรสักอย่าง: \u0026#39;) จากนั้นก็จะมีข้อความขึ้นว่า\nจงป้อนค่าอะไรสักอย่าง: แล้วจึงตามด้วยส่วนที่ให้พิมพ์ข้อความอยู่ทางขวาของข้อความ การทำงานของ input ก็เป็นอย่างที่เห็นนี้ อาจชวนให้สับสนได้ง่าย ต้องจำไว้ว่าข้อความในอาร์กิวเมนต์ของ input เป็นเพียงแค่ข้อความที่สื่อสาร กับผู้ใช้ว่าควรจะกรอกข้อมูลอะไร แต่ไม่ได้มีผลอะไรกับข้อมูลที่ป้อนเข้าไป สิ่งที่ต้องเน้นอีกอย่าง คือ ข้อมูลที่ป้อนเข้าไปด้วยฟังก์ชัน input นี้จะเป็นสายอักขระ หากต้องการจะได้ค่าเป็นจำนวนจริงหรือจำนวนเต็มก็จะต้องแปลงอีกที เช่น\na = float(input(\u0026#39;จงป้อนตัวเลขลงไป: \u0026#39;)) จากนั้นก็ลองป้อนค่าตัวเลขอะไรบางอย่างเข้าไป\nแต่ถ้าป้อนค่าที่ไม่ใช่ตัวเลขลงไป เช่นใส่ตัวหนังสือปนลงไปด้วยก็จะขัดข้องทันที\nทั้งหมดที่ว่ามานี้เป็นเรื่องของไพธอน 3 ส่วนในไพธอน 2 จะมีความแตกต่างออกไปพอสมควร\n รายละเอียด  เมธอด ในภาษาไพธอนและอีกหลายภาษาที่เน้นการเขียนโปรแกรมเชิงวัตถุนั้นนอกจากฟังก์ชันแล้วยังมีคำสั่งอีกอีกชนิดหนึ่งซึ่งซึ่งมีลักษณะพิเศษเฉพาะ เรียกว่าเมธอด (method) ซึ่งก็อาจถือเป็นฟังก์ชันชนิดหนึ่ง เพียงแต่จะมีความจำเพาะต่อออบเจ็กต์\nเมธอดจะถูกนิยามควบคู่ไปกับออบเจ็กต์แต่ละชนิด โดยออบเจ็กต์แต่ละชนิดจะมีเมธอดไม่เหมือนกัน เมธอดจะไม่ปรากฏขึ้นเดี่ยวๆเหมือนอย่างฟังก์ชันทั่วไป เวลาเขียนเมธอดจะเขียน ตามหลังวัตถุที่ต้องการใช้เมธอดนั้น โดยใช้จุด . คั่น ขอยกตัวอย่างเช่น ออบเจ็กต์ชนิดจำนวนจริงมีเมธอดที่ชื่อว่า is_integer() คือเมธอดสำหรับตรวจว่าค่าของจำนวนจริงนั้นเป็นจำนวนเต็มในทางคณิตศาสตร์หรือ ไม่ (คือมีค่าเลขทศนิยมเป็น 0 หรือไม่) ถ้าเป็นก็คืนค่า True ถ้าไม่ใช่ก็คืนค่า False\nx = 3.0 x.is_integer() # ได้ผลเป็น True แต่\n(3.1).is_integer() # ได้ผลเป็น False แต่ถ้าใช้เมธอดกับวัตถุผิดชนิด (3).is_integer() # จะได้ AttributeError: \u0026#39;int\u0026#39; object has no attribute \u0026#39;is_integer\u0026#39; เพราะข้อมูลชนิดจำนวนเต็มไม่มีเมธอด is_integer ต้องเป็นข้อมูลชนิดจำนวนจริงเท่านั้นถึงจะมี\nวงเล็บที่อยู่ด้านหลังนั้นสามารถใส่อาร์กิวเมนต์หรือคีย์เวิร์ดลงไปได้เช่นกันหากเมธอดนั้นเป็นเมธอดที่ต้องการหรือสามารถใส่เพิ่มอาร์กิวเมนต์หรือคีย์เวิร์ดได้\nสรุปเนื้อหา  ฟังก์ชันคือสิ่งที่ทำให้เกิดการดำเนินการทำอะไรบางอย่าง หรืออาจคืนค่าอะไรบางอย่างกลับออกมา คลาสหรือชนิดของข้อมูล เช่น str int float bool นั้น ไม่ใช่ฟังก์ชันโดยตรงแต่ก็สามารถทำหน้าที่เหมือนฟังก์ชัน โดยมีหน้าที่แปลงชนิดข้อมูลให้กลายเป็นคลาสนั้น ฟังก์ชันจะต้องลงท้ายด้วยวงเล็บ () และอาจมีอาร์กิวเมนต์หรือคีย์อยู่ภายใน ส่วนเมธอดคือฟังก์ชันที่จำเพาะต่อออบเจ็กต์แต่ละชนิด เวลาใช้จะต้องเขียนตามหลังวัตถุโดยคั่นด้วยจุด . และต้องมีวงเล็บ () ต่อท้ายเช่นกัน  ยังมีฟังก์ชันและเมธ็อดอีกมากมาย ในบทนี้แค่ยกมาให้เห็นตัวอย่างบางส่วนให้พอเริ่มเห็นภาพ เมื่อผ่านไปถึงบทต่อๆไปก็จะได้รู้จักเพิ่มขึ้นเรื่อยๆและจะเริ่มคุ้นชินกับการใช้\nอ้างอิง\n http://docs.python.jp/3/library/functions.html http://docs.python.jp/3/tutorial/inputoutput.html   Reference : https://phyblas.hinaboshi.com/tsuchinoko04\n "
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/learning-python/9_function/",
	"title": "9. ฟังก์ชัน (Function)",
	"tags": [],
	"description": "ในบทนี้ คุณจะได้เรียนรู้เกี่ยวกับฟังก์ชันในภาษา Python เราจะพูดถึงการสร้างและการใช้งานฟังก์ชันในเบื้องต้น และการเรียกใช้งานฟังก์ชันในรูปแบบต่างๆ ที่สำคัญ เช่น Default Argument และ Keyword Augment และมากไปกว่านั้น เราจะแนะนำให้คุณรู้จักกับ built-in ฟังก์ชันในภาษา Python",
	"content": "ในบทนี้ คุณจะได้เรียนรู้เกี่ยวกับฟังก์ชันในภาษา Python เราจะพูดถึงการสร้างและการใช้งานฟังก์ชันในเบื้องต้น และการเรียกใช้งานฟังก์ชันในรูปแบบต่างๆ ที่สำคัญ เช่น Default Argument และ Keyword Augment และมากไปกว่านั้น เราจะแนะนำให้คุณรู้จักกับ built-in ฟังก์ชันในภาษา Python\nการสร้างฟังก์ชันในภาษา Python ฟังก์ชัน (Function) คือส่วนของโค้ดหรือโปรแกรมที่ทำงานเพื่อวัตถุประสงค์บางอย่าง ในภาษา Python คุณสามารถสร้างฟังก์ชันของคุณเองเพื่อให้ทำงานที่ต้องการ ในการเขียนโปรแกรมเรามักจะแยกโค้ดที่มีการทำงานเหมือนๆ กันเป็นฟังก์ชันเอาไว้ และเรียกใช้ฟังก์ชันนั้นซ้ำๆ ซึ่งเป็นแนวคิดของการนำโค้ดกลับมาใช้ใหม่ (Code reuse) นี่เป็นรูปแบบของการประกาศฟังก์ชันในภาษา Python\ndef function_name(args...): # statements def function_name(args...): # statements return value ในรูปแบบของการประกาศฟังก์ชันในภาษา Python นั้นจะใช้คำสั่ง def และหลังจากนั้น function_name เป็นชื่อของฟังก์ชัน และในวงเล็บ () เป็นการกำหนดพารามิเตอร์ของฟังก์ชัน พารามิเตอร์ของฟังก์ชันนั้นสามารถมีจำนวนเท่าไหร่ก็ได้หรือไม่มีก็ได้ และเช่นเดียวกับภาษาอื่นๆ ฟังก์ชันอาจจะมีหรือไม่มีการส่งค่ากลับ สำหรับฟังก์ชันที่ไม่มีการ return ค่ากลับนั้น เรามักจะเรียกว่า โพรซีเยอร์ (Procedure) ต่อไปมาดูตัวอย่างการประกาศและใช้งานฟังก์ชันในภาษา Python\ndef hello(name): print(\u0026#39;Hello %s\u0026#39; % name) def count_vowel(str): vowel = 0 for c in str: if c in (\u0026#39;A\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;U\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;): vowel = vowel + 1 return vowel def area(width, height): c = width * height return c ในตัวอย่าง เราได้สร้างฟังก์ชันจำนวน 3 ฟังก์ชัน ฟังก์ชันแรกมีชื่อว่า hello() เป็นฟังก์ชันสำหรับแสดงข้อความทักทายจากที่ชื่อส่งเข้ามา ฟังก์ชันนี้มีหนึ่งพารามิเตอร์คือ name สำหรับรับชื่อที่ส่งเข้ามาในฟังก์ชัน\ndef count_vowel(str): vowel = 0 for c in str: if c in (\u0026#39;A\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;U\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;): vowel = vowel + 1 return vowel ต่อมาฟังก์ชัน count_vowel() เป็นฟังก์ชันสำหรับนับจำนวนสระใน String ฟังก์ชันนี้มีหนึ่ง String พารามิเตอร์ ในการทำงานของฟังก์ชันนั้นเราใช้คำสั่ง For loop ในการวนอ่านค่าทีละตัวอักษรเพื่อตรวจสอบว่าเป็นสระหรือไม่ด้วยคำสั่ง in และตัวแปร vowel นั้นใช้สำหรับนับจำนวนสระที่พบใน String ในตอนท้ายเราได้ส่งค่าของจำนวนสระที่นับได้กลับไปด้วยคำสั่ง return\ndef area(width, height): c = width * height return c และฟังกชันสุดท้ายคือฟังก์ชัน area() เป็นฟังก์ชันสำหรับหาพื้นที่ของรูปสี่เหลี่ยมด้านขนาน และฟังก์ชันมีพารามิเตอร์สองตัวสำหรับความกว้างและความยาวของสี่เหลี่ยม และฟังก์ชันทำการ return ผลลัพธ์ที่เป็นพื้นที่กลับไปด้วยคำสั่ง return\nการเรียกใช้งานฟังก์ชันในภาษา Python หลังจากเราได้สร้างฟังก์ชันในตัวอย่างก่อนหน้าแล้ว ต่อไปเราจะมาเรียกใช้งานฟังก์ชันเหล่านั้น ในการเรียกใช้ฟังก์ชันนั้นเราจะใช้ชื่อของฟังก์ชันและส่งอาร์กิวเมนต์ให้สอดคล้องกับพารามิเตอร์ที่กำหนดไว้ในฟังก์ชัน ดังนั้นอาร์กิวเมนต์คือค่าที่ส่งเข้าไปในฟังก์ชันตอนใช้งาน ส่วนพารามิเตอร์นั้นคือตัวแปรทีกำหนดไว้ในฟังก์ชันเพื่อรับค่าจากอาร์กิวเมนต์ มาดูตัวอย่างการเรียกใช้งานฟังก์ชันในภาษา Python\ndef hello(name): print(\u0026#39;Hello %s\u0026#39; % name) def count_vowel(str): vowel = 0 for c in str: if c in (\u0026#39;A\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;U\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;): vowel = vowel + 1 return vowel def area(width, height): c = width * height return c # calling functions hello(\u0026#39;Danny\u0026#39;) hello(\u0026#39;Mateo\u0026#39;) print(\u0026#39;Vowel in string = %d\u0026#39; % count_vowel(\u0026#39;marcuscode.com\u0026#39;)) print(\u0026#39;Vowel in string = %d\u0026#39; % count_vowel(\u0026#39;Python\u0026#39;)) print(\u0026#39;Area = %d\u0026#39; % area(8, 4)) ในตัวอย่าง เป็นการเรียกใช้งานฟังก์ชันที่เราสร้างขึ้น เราได้เรียกใช้ฟังก์ชัน hello() และส่งอาร์กิวเมนต์ที่เป็น String เข้าไปยังฟังก์ชัน เราเรียกใช้ฟังก์ชันนี้สองครั้ง ซึ่งนี่เองเป็นการ reuse โค้ดในการเขียนโปรแกรม\nหลังจากนั้นเราเรียกใช้ฟังก์ชัน count_vowel() และฟังก์ชัน area() และส่งพารามิเตอร์ที่ถูกต้องไปยังฟังก์ชัน และเพราะว่าฟังก์ชันเหล่านี้มีการ return ค่ากลับ เราสามารถนำค่าเหล่านี้ไปใช้งานได้ต่อไป เราได้นำไปใช้กับฟังก์ชัน print() เพื่อจัดรูปแบบการแสดงผล\nHello Danny Hello Mateo Vowel in string = 5 Vowel in string = 1 Area = 32 นี่เป็นผลลัพธ์การทำงานของโปรแกรม จากการเรียกใช้งานฟังก์ชันในภาษา Python\nDefault Argument Values ในภาษา Python เราสามารถสร้างฟังก์ชันโดยการกำหนด Default Argument ให้กับฟังก์ชันพารามิเตอร์ได้ Default Argument เป็นการการกำหนดค่าเริ่มต้นให้กับอาร์กิวเมนต์ที่ส่งเข้ามายังฟังก์ชัน นั่นทำให้เราสามารถเรียกใช้งานฟังก์ชันโดยการส่งอาร์กิวเมนต์น้อยกว่าจำนวนที่กำหนดไว้ในฟังก์ชันได้ ซึ่งอำนวยความสะดวกในการใช้งานมากขึ้น มาดูตัวอย่างการสร้างและใช้งานฟังก์ชันกับ Default Argument\ndef show_info(name, salary = 84360, lang = \u0026#34;Python\u0026#34;): print(\u0026#39;Name: %s\u0026#39; % name) print(\u0026#39;Salary: %d\u0026#39; % salary) print(\u0026#39;Language: %s\u0026#39; % lang) print() ในตัวอย่าง เราได้สร้างฟังก์ชัน show_info() สำหรับแสดงข้อมูลของโปรแกรมเมอร์ ข้อมูลที่จำเป็นต้องการจะแสดงนั้นมีชื่อ เงินเดือน และภาษาที่เขียน ในฟังก์ชันของเรานั้นมี 3 พารามิเตอร์ พารามิเตอร์แรก name นั้นเป็นพารามิเตอร์แบบปกติ และสองพารามิเตอร์นั้นเป็น Default Argument ซึ่งเรากำหนดค่าเริ่มต้นให้กับพารามิเตอร์โดยใช้เครื่องหมาย = ในการกำหนดพารามิเตอร์นั้น Default Argument ต้องอยู่หลังพารามิเตอร์แบบปกติเสมอ\n# calling function show_info(\u0026#39;Mateo\u0026#39;) show_info(\u0026#39;Mateo\u0026#39;, 105000) show_info(\u0026#39;Danny\u0026#39;, 120000, \u0026#39;Java\u0026#39;) ในการเรียกใช้งานฟังก์ชันนั้น เราต้องทำการส่งค่าอาร์กิวเมนต์สำหรับพารามิเตอร์แบบปกติเสมอ ส่วนพารามิเตอร์แบบ Default Argument นั้นเป็นทางเลือก ในตัวอย่าง คำสั่งเราเรียกใช้ฟังก์ชันโดยอาร์กิวเมนต์เพียงหนึ่งตัวเข้าไป ทำให้สองอาร์กิวเมนต์ที่เหลือที่เป็น Default Argument ใช้ค่าเริ่มต้นของมันแทน คือ 84360 สำหรับเงินเดือน และ \u0026quot;Python\u0026quot; สำหรับภาษาเขียนโปรแกรม\nต่อมาเราเรียกใช้ฟังก์ชันโดยการส่งสองอาร์กิวเมนต์เข้าไป ทำให้มีเพียงพารามิเตอร์สุดท้ายเท่านั้นที่ใช้ค่าเริ่มต้น และในคำสั่งสุดท้ายเป็นการส่งค่าครบจำนวนให้กับทุกอาร์กิวเมนต์\nName: Mateo Salary: 84360 Language: Python Name: Mateo Salary: 105000 Language: Python Name: Danny Salary: 120000 Language: Java นี่เป็นผลลัพธ์การทำงานของโปรแกรม ในการเรียกใช้งานฟังก์ชันกับ Default Argument\nKeyword Arguments ในภาษา Python เราสามารถเรียกใช้งานฟังก์ชันในรูปแบบของ Keyword Argument โดยการใช้ชื่อของพารามิเตอร์สำหรับส่งอาร์กิวเมนต์ ในการใช้งานนั้น พารามิเตอร์ต้องมีการกำหนดในรูปแบบของ Default Argument ก่อน มาดูตัวอย่างการใช้งาน Keyword Arguments ในภาษา Python\ndef create_button(id, color = \u0026#39;#ffffff\u0026#39;, text = \u0026#39;Button\u0026#39;, size = 16): print(\u0026#39;Button ID: %d\u0026#39; % id) print(\u0026#39;Attributes:\u0026#39;) print(\u0026#39;Color: %s\u0026#39; % color) print(\u0026#39;Text: %s\u0026#39; % text) print(\u0026#39;Size: %dpx\u0026#39; % size) print() create_button(10) create_button(11, color = \u0026#39;#4286f4\u0026#39;, text = \u0026#39;Sign up\u0026#39;) create_button(id = 12, color = \u0026#39;#323f54\u0026#39;, size = 24) create_button(color = \u0026#39;#1cb22b\u0026#39;, text = \u0026#39;Log in\u0026#39;, size = 32, id = 13) ในตัวอย่าง เราได้สร้างฟังก์ชันสำหรับการสร้างปุ่ม ในการเรียกใช้งานฟังก์ชันนั้น เราสามารถเรียกโดยวิธีการส่งแบบ Keyword Argument ได้ในรูปแบบของ argument = value และสามารถสลับตำแหน่งของอาร์กิวเมนต์ได้ และในฟังก์ชันนั้นเรามีอาร์กิวเมนต์ id ซึ่งเป็นอาร์กิวเมนต์แบบปกติ สำหรับอาร์กิวเมนต์แบบปกติในการส่งค่านั้นต้องส่งเป็นลำดับแรกเสมอ เหมือนในคำสั่งการเรียกใช้งานสองคำสั่งแรก หรือสามารถส่งแบบ Keyword Argument ก็ได้เช่นกันเหมือนในคำสั่งที่สามและสี่\nButton ID: 10 Attributes: Color: #ffffff Text: Button Size: 16 px Button ID: 11 Attributes: Color: #4286f4 Text: Sign up Size: 16 px Button ID: 12 Attributes: Color: #323f54 Text: Button Size: 24 px Button ID: 13 Attributes: Color: #1cb22b Text: Log in Size: 32 px นี่เป็นผลลัพธ์การทำงานของโปรแกรม เราได้เรียกใช้งานฟังก์ชันเพื่อสร้างปุ่ม 4 ปุ่มในรูปแบบต่างๆ ของการใช้ Keyword Argument\nตัวอย่างของฟังก์ชันที่มีการใช้งานในรูปแบบของ Keyword Argument ก็คือ ฟังก์ชัน print() เราสามารถเปลี่ยนตัวคั่นระหว่างอาร์กิวเมนต์ และการแสดงผลลัพธ์ในตอนท้ายของฟังก์ชันได้ โดยการใช้ Keyword sep และ end ตามลำดับ\nprint(1, 2, 3) print(1, 2, 3, sep = \u0026#39;-\u0026#39;, end = \u0026#39;/\u0026#39;) Lambda Expressions Lambda Expressions คือ anonymous function ที่เป็นฟังก์ชันที่มีการทำงานขนาดเล็กอยู่ภายในที่สามารถมีได้เพียง Expression เดียวเท่านั้น เราสามารถสร้างโดยใช้คำสั่ง lambda เราสามารถใช้ Lambda Expressions สร้างออบเจ็คของฟังก์ชันได้ และค่า return จะเป็นค่าที่ได้จากผลลัพธ์ของ Expression ของฟังก์ชัน มาดูตัวอย่างการใช้งาน\nf = lambda x: x + 1 print(f(2)) print(f(8)) g = lambda a, b: (a + b) / 2 print(g(3, 5)) print(g(10, 33)) def make_incrementor(n): return lambda x: x + n f = make_incrementor(13) print(f(0)) print(f(1)) print(f(5)) ในตัวอย่าง เราได้สร้าง Lambda Expressions เป็นจำนวนสามฟังก์ชัน ฟังก์ชันแรกเป็นฟังก์ชันสำหรับเพิ่มตัวเลขขึ้น 1 และฟังก์ชันที่สองเป็นฟังก์ชันสำหรับหาค่าเฉลี่ยของตัวเลขสองจำนวน คุณจะสังเกตได้ว่าฟังก์ชันแรกนั้นมี 1 อาร์กิวเมนต์และฟังก์ชันที่สองนั้นมี 2 อาร์กิวเมนต์ และฟังก์ชันสุดท้ายนั้นเป็นการ return ฟังก์ชันกลับภายในฟังก์ชันอีกที และเป็นฟังก์ชันสำหรับเพิ่มตัวเลขขึ้นจำนวน n จากอาร์กิวเมนต์ที่ใส่เข้าไป\n3 9 4.0 21.5 13 14 18 นี่เป็นผลลัพธ์การทำงานของโปรแกรม\nนอกจากนี้ Lambda Expressions ยังมีประโยชน์เพื่อใช้งานกับ built-in function เช่น ฟังก์ชัน filter() และฟังก์ชัน map() ในภาษา Python มันใช้เป็นอาร์กิวเมนต์ส่งเข้าไปในฟังก์ชัน เพื่อสร้าง Expression ให้กับฟังก์ชัน มาดูตัวอย่างการใช้งาน\nnumbers = [2, 15, 5, 7, 10, 3, 28, 30] print(list(filter(lambda x: x % 5 == 0, numbers))) print(list(map(lambda x: x * 2, numbers))) ในตัวอย่าง เรามีลิสต์ของตัวเลข Integer และเราได้ใช้ฟังก์ชัน filter() และฟังก์ชัน map() ซึ่งเป็นฟังก์ชันที่มีอาร์กิวเมนต์ตัวแรกเป็นฟังก์ชัน และตัวที่สองเป็นลิสต์ ในการทำงานของฟังก์ชัน filter() เราได้ใช้ฟังก์ชันกรองเอาตัวเลขที่ตรงกันกับ Lambda Expressions ซึ่งก็คือตัวเลขในลิสต์ที่หารด้วย 5 ลงตัว และในการใช้ฟังก์ชัน map() เป็นการเชื่อมโยงค่าในลิสต์ให้ตรงกับ Lambda Expressions คือการเพิ่มตัวเลขให้เป็นสองเท่า ซึ่งทั้งสองฟังก์ชันนี้ส่งค่ากลับเป็นออบเจ็ค และเราใช้ฟังก์ชัน list() เพื่อแปลงออบเจ็คให้เป็นสิสต์\n[15, 5, 10, 30] [4, 30, 10, 14, 20, 6, 56, 60] นี่เป็นผลลัพธ์การทำงานของโปรแกรม\nในบทนี้ คุณได้เรียนรู้เกี่ยวกับการสร้างและใช้งานฟังก์ชันในภาษา Python และการเรียกใช้ฟังก์ชันในรูปแบบอื่นๆ เช่น Default Argument และ Keyword Argument และนอกจากนี้เรายังแนะนำให้คุณรู้จักกับการใช้งาน Lambda Expressions เพื่อสร้างฟังก์ชันขนาดเล็กแต่ช่วยอำนวยความสะดวกในการทำงานเป็นอย่างมาก และแนะนำให้คุณรู้จักกับ built-in function\n Reference : http://marcuscode.com\n "
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": "A bunch of Shortcodes are available with this theme :\n Python by MascusCode MarcusCode เป็นเว็บไซต์ที่ให้คุณสามารถเรียนการเขียนโปรแกรมคอมพิวเตอร์ โดยบทเรียนนั้นเป็นเนื้อหาพื้นฐานและเข้าใจง่าย และที่สำคัญมันฟรี มีบทเรียนในการเขียนโปรแกรมในภาษา Python ในพื้นฐานจนถึงระดับสูงแยกตามบท ซึ่งเนื้อหาที่เว็บไซต์นี้สอนนั้นจะกระชับและตรงประเด็น ทำให้ผู้ที่ศึกษาตามสามารถเข้าใจถึงหลักการของภาษาไพธอนได้อย่างรวดเร็ว ตัวอย่างของเนื้อหาที่สอน เช่น โครงสร้างของภาษาไพธอน ตัวแปรและประเภทข้อมูล ตัวดำเนินการ อาเรย์และฟังก์ชัน\n  phyblas phyblas กำลังศึกษาต่ออยู่ที่มหาวิทยาลัยในไต้หวัน มีความสนใจในหลาย ๆ ด้าน เนื้อหาที่เขียนภายในบล็อกนี้ก็มีอยู่หลากหลาย ขึ้นอยู่กับความสนใจในแต่ละช่วง มีทั้งเรื่องราวท่องเที่ยว ซึ่งเน้นที่จีนและญี่ปุ่นเป็นหลัก นอกจากนี้ก็เขียนบันทึกประจำวัน ความรู้ทั่วไป ประสบการณ์ต่างๆ เรื่องราวรอบๆตัว แล้วก็เกี่ยวกับอนิเมะที่ดู เกมที่ได้เคยเล่นเป็นต้น\n  "
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/learning-python/10_string/",
	"title": "10. String",
	"tags": [],
	"description": "",
	"content": "ในบทนี้ คุณจะได้เรียนรู้เกี่ยวกับ String ในภาษา Python เราจะพูดเกี่ยวกับการประกาศและใช้งาน String ในรูปแบบต่างๆ เพราะว่าเนื้อหาเกี่ยวกับ String นั้นมีค่อนข้างมาก ดังนั้นเราจึงได้รวบรวมเนื้อหาทั้งหมดไว้ในบทนี้ และเราจะแนะนำการใช้งาน built-in function ในภาษา Python ที่สำคัญในการจัดการกับข้อมูลประเภท String\nการประกาศตัวแปร String String เป็นลำดับของตัวอักษรหลายตัวเรียงต่อกัน ซึ่งในภาษา Python นั้นการที่จะประกาศ String ค่าของมันจะอยู่ในเครื่องหมาย Double quote หรือ Single quote เท่านั้น มาดูตัวอย่างการประกาศตัวแปรของ String\nname = \u0026#34;Mateo\u0026#34; site = \u0026#39;marcuscode.com\u0026#39; str1 = \u0026#34;This is my string\u0026#34; str2 = \u0026#39;This is my string\u0026#39; ในตัวอย่าง เราได้ประกาศ 4 ตัวแปรของ String คุณจะสังเกตว่าในการกำหนดค่าให้กับตัวแปรนั้น String literal จะถูกภายในเครืองหมาย Double quote (\u0026quot;\u0026quot;) หรือ Single quote ('') เท่านั้น ซึ่งได้ผลการทำงานที่เหมือนกัน ขนาดของ String นั้นจะขึ้นกับจำนวนตัวอักษรภายใน String\nอย่างไรก็ตาม ถึงแม้เราจะสามารถใช้ Double quote หรือ Single quote กับ String ได้ แต่มีสิ่งที่แตกต่างกันเล็กน้อยสำหรับการใช้งานทั้งสองแบบคือการใช้ตัวอักษรพิเศษใน String หรือเรียกว่า Escape character ลองมาดูตัวอย่างต่อไปนี้\nsentent1 = \u0026#34;What\u0026#39;s your name?\u0026#34; sentent2 = \u0026#39;I\\\u0026#39;m Mateo.\u0026#39; sentent3 = \u0026#34;He said \\\u0026#34;I would learn Python first\\\u0026#34;.\u0026#34; sentent4 = \u0026#39;His teach replied \u0026#34;Oh well!\u0026#34;\u0026#39; print(sentent1) print(sentent2) print(sentent3) print(sentent4) ในตัวอย่าง เป็นสิ่งที่แตกต่างของการประกาศ String ทั้งสองแบบกับ Escape character ซึ่งตัวอักษร ' และ \u0026quot; นั้นเป็น Escape character ดังนั้นในการใช้งานตัวอักษรเหล่านี้ เราต้องใส่เครื่องหมาย \\ ลงไปข้างหน้าเสมอ แต่ในภาษา Python เมื่อคุณใช้ Double quote ในการประกาศ String คุณไม่ต้องทำการ Escape character สำหรับ Single quote และในทางกลับกัน\nWhat\u0026#39;s your name? I\u0026#39;m Mateo. He said \u0026#34;I would learn Python first\u0026#34;. His teach replied \u0026#34;Oh well!\u0026#34; นี่เป็นผลลัพธ์การทำงานของโปรแกรมที่แสดงให้เห็นถึงความแตกต่างของการใช้ Double quote และ Single quote\nraw_str = r\u0026#34;Python\\tJava\\tPHP\\n\u0026#34; print(raw_str) ในภาษา Python มีอีกวิธีหนึ่งในการประกาศตัวแปร String คือการกำหนดค่าแบบ raw string ในตัวอย่างข้างบน เราใช้ตัวอักษร r ก่อนหน้าเครื่องหมาย ' หรือ \u0026quot; ซึ่ง raw string เป็นการแปลง String ให้เหมือนกับที่กำหนดใน String literal เสมอ\nนอกจากนี้ เรายังสามารถประกาศ String แบบหลายบรรทัดได้ โดยการครอบด้วยเครื่องหมาย \u0026quot;\u0026quot;\u0026quot; หรือ ''' String literal ที่ปรากฎภายในเครื่องหมายนี้จะเป็น raw string ที่จะทำการ Escape ให้อัตโนมัติ มาดูตัวอย่าง\nstr = \u0026#34;\u0026#34;\u0026#34;\\ HTTP response code 200 Success 404 Not found 503 Service unavailable \u0026#34;\u0026#34;\u0026#34; print(str) ในตัวอย่าง เป็นการประกาศตัวแปร String แบบการใช้หลายบรรทัด String literal ทั้งหมดนั้นจะต้องอยู่ภายใน \u0026quot;\u0026quot;\u0026quot; เนื่องจากเราต้องการจัดรูปแบบของ String ให้สวยงาม ดังนั้นเราจึงต้อง Newline ลงมาเขียนในบรรทัดถัดมา ดังนั้นเราสามารถใช้เครื่องหมาย \\ เพื่อลบ Newline ออกไปได้ นี่เป็นผลลัพธ์ของโปรแกรม\nHTTP response code 200 Success 404 Not found 503 Service unavailable String concatenation เช่นเดียวกับในภาษาอื่นๆ ในภาษา Python คุณสามารถเชื่อมต่อตั้งแต่สอง String เข้าด้วยกันได้ โดยการใช้เครื่องหมายบวก (+) ถึงแม้ว่านี่เป็นตัวดำเนินการทางคณิตศาสตร์ที่ใช้สำหรับบวกค่าของตัวเลข แต่เมื่อนำมาใช้กับ String จะเป็นการเชื่อมต่อ String เข้าด้วยกันแทนหรือเรียกว่า Operator overloading มาดูตัวอย่างการเชื่อมต่อ String\nfirst_name = \u0026#39;Matt\u0026#39; last_name = \u0026#39;Williams\u0026#39; full_name = first_name + \u0026#39; \u0026#39; + last_name bless = \u0026#39;Merry\u0026#39; + \u0026#39;Christmas!\u0026#39; print(full_name) print(bless) ในตัวอย่าง เป็นการเชื่อมต่อ String ในภาษา Python เรามีตัวแปร first_name สำหรับเก็บชื่อ และตัวแปร last_name สำหรับเก็บนามสกุล และเราสร้างตัวแปร full_name เพื่อเก็บชื่อแบบเต็มโดยการนำ String จากทั้งสองตัวแปรก่อนหน้ามาเชื่อมต่อกัน ซึ่งเป็นการเชื่อมต่อ String จากตัวแปร และในตัวแปร bless เป็นการเชื่อมต่อจาก String literal โดยตรงเพื่อสร้างคำอวยพรในวันคริสมาสต์ นี่เป็นผลลัพธ์การทำงานของโปรแกรม\nMatt Williams MerryChristmas! ในภาษา Python คุณยังสามารถเชื่อมต่อ String ได้ด้วยวิธีอื่นอีก เช่น White-space Tab หรือ Newline โดย String literal ที่คั่นด้วยช่องว่างในบรรทัดเดียวกันจะถูกนำมาต่อกันอัตโนมัติโดยตัวแปรของภาษา และคุณสามารถเชื่อมต่อโดยที่ String อยู่คนละบรรทัดได้ด้วยการใช้ \\ ต่อท้ายสำหรับบอกว่าคำสั่งมีอยู่ในบรรทัดต่อไป มาดูตัวอย่าง\nname = \u0026#39;Matt\u0026#39; \u0026#39;Williams\u0026#39; my_number = \u0026#39;One \u0026#39;\\ \u0026#39;Two \u0026#39;\\ \u0026#39;Three \u0026#39; print(name) print(my_number) ในตัวอย่าง เป็นการเชื่อมต่อ String โดยการใช้ช่องว่างและการขึ้นบรรทัดใหม่ และในการเขียนโปรแกรม เราแนะนำให้คุณใช้วิธีการใช้เครื่องหมาย + เพื่อให้การเขียนโปรแกรมเป็นไปในรูปแบบเดียวกัน อย่างไรก็ตาม คุณสามารถเลือกใช้แบบต่างๆ ได้ตามความเหมาะสมของโปรแกรม\nMattWilliams One Two Three นี่เป็นผลลัพธ์การทำงานของโปรแกรมในการเชื่อมต่อ String เข้าด้วยกัน\nCharterers of string เนื่องจาก String นั้นเกิดจากตัวอักษรหลายๆ ตัวต่อกันจนเกิดเป็น String หรือกล่าวอีกนัยหนึ่งก็คือ String คืออาเรย์ของตัวอักษร ดังนั้นเราจึงสามารถเข้าถึงตัวอักษรตำแหน่งต่างๆ ของ String ได้ผ่านทาง Index ของมัน เช่นเดียวกับการเข้าถึงข้อมูลใน List มาดูตัวอย่าง\ns = \u0026#39;Mountain\u0026#39; print(s[0]) # M print(s[4]) # t print(s[7]) # n ในตัวอย่าง เป็นการเข้าถึงตำแหน่งของตัวอักษรในตัวแปร String s เราสามารถเข้าถึงด้วยการใช้ Index ในเครื่องหมาย [] โดยที่ Index ของ String นั้นจะเริ่มจาก 0 สำหรับตำแหน่งแรก และเพิ่มขึ้นทีละ 1 ไปจนถึงตำแหน่งสุดท้าย\ns = \u0026#39;Mountain\u0026#39; s[0] = \u0026#39;a\u0026#39; # invalid อย่างไรก็ตาม การทำงานกับ String ผ่านทาง Index นั้นสามารถอ่านค่าได้เพียงอย่างเดียว และไม่สามารถแก้ไขค่าได้ (Immutable) จากตัวอย่างข้างบนจึงทำให้เกิดข้อผิดพลาดขึ้น เพราะเราพยายามที่จะเปลี่ยนแปลงค่าของ String ผ่านทาง Index ของมัน\ns = \u0026#39;Python\u0026#39; for c in s: print(c) print() s = \u0026#39;marcuscode.com\u0026#39; for i in range(len(s)): print(\u0026#39;s[%d] = %c\u0026#39; % (i, s[i])) print() เนื่องจาก String นั้นเป็นอาเรย์ของตัวอักษร ดังนั้นมันจึงสะดวกที่จะใช้คำสั่ง For loop วนอ่านค่าจากใน String ทีละตัวอักษร ในตัวอย่างข้างบน เป็นการวนอ่านค่าโดยการใช้คำสั่ง For วนอ่านค่าใน String สำหรับลูปแรก และในลูปที่สอง เราใช้คำสั่ง For สร้าง Index ตั้งแต่ 0 ถึงตำแหน่งสุดท้ายของ String และวนอ่านค่า\nP y t h o n s[0] = m s[1] = a s[2] = r s[3] = c s[4] = u s[5] = s s[6] = c s[7] = o s[8] = d s[9] = e s[10] = . s[11] = c s[12] = o s[13] = m นี่เป็นผลลัพธ์การทำงานของโปรแกรม\nนอกจากนี้ ในภาษา Python นั้นยังสนับสนุนการตัดคำใน String ด้วย Index โดยการตัดเอาส่วนย่อยๆ ภายใน String มาดูตัวอย่างการใช้งาน การตัดคำใน String\ns1 = \u0026#39;Mountain\u0026#39; print(s1[0:4]) # Moun print(s1[4:6]) # ta print(s1[0:1]) # M s2 = \u0026#39;marcuscode\u0026#39; print(s2[:6]) #marcus print(s2[6:]) #code ในตัวอย่าง เป็นการตัดคำด้วย Index ในการใช้งานนั้นจะมีรูปแบบเป็น [start:end] โดยที่ start นั้นเป็นตำแหน่งของ Index เริ่มต้นที่ต้องการ และ end นั้นเป็นตำแหน่งก่อนหน้าตำแหน่งสุดท้ายของตัวอักษรที่ต้องการ เหมือนในตัวอย่างของการตัดคำในตัวแปร s1\nและถ้าหากคุณปล่อยให้ตำแหน่ง start ให้ว่าง นั้นหมายความว่าเป็นการเริ่มมาจากตำแหน่งแรกของ String หรือหากคุณปล่อยให้ end ให้ว่าง เป็นการตัดจากตำแหน่งที่กำหนดไปจนสิ้นสุด String เหมือนในตัวแปร s2\nMoun ta M marcus code นี่เป็นผลลัพธ์การทำงานของของโปรแกรมในการตัด String ด้วย Index\nและนอกจากนี้ เรายังสามารถหาความยาวของ String โดยการใช้ฟังก์ชันที่มากับภาษา Python คือฟังก์ชัน len() สำหรับหาขนาดของตัวอักษรของ String ที่ระบุ ซึ่งจะได้ผลลัพธ์กลับมาเป็น Integer นี่เป็นตัวอย่างการหาความยาวของ String\ns1 = \u0026#39;Mountain\u0026#39; s2 = \u0026#39;marcuscode\u0026#39; s3 = \u0026#39;Python\u0026#39; print(\u0026#39;length of s1 =\u0026#39;, len(s1)) print(\u0026#39;length of s2 =\u0026#39;, len(s2)) print(\u0026#39;length of s3 =\u0026#39;, len(s3)) ในตัวอย่าง เป็นการใช้ฟังก์ชัน len() สำหรับหาความยาวของตัวแปร String สามตัวแปร และแสดงผลความยาวนั้นออกทาง console ซึ่งจะได้ผลลัพธ์ดังข้างล่าง\nlength of s1 = 8 length of s2 = 10 length of s3 = 6 ในบทนี้ คุณได้เรียนรู้เกี่ยวกับข้อมูลประเภท String ในภาษา Python การประกาศและใช้งานตัวแปรในรูปแบบต่างๆ รวมถึงการเชื่อมต่อ String เข้าด้วยกัน นอกจากนี้ คุณยังทราบว่าเราสามารถเข้าถึงตัวอักษรใน String ผ่านทาง Index ของมันและเราพูดถึงฟังก์ชันในการหาความยาวของ String ในบทต่อไป จะเป็นการใช้งานฟังก์ชันมาตรฐานในภาษา Python เพื่อจัดการกับ String\nReference : http://marcuscode.com/lang/python/string\n"
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/phyblas/beginer/string_output/",
	"title": "การแสดงผลตัวอักษร",
	"tags": [],
	"description": "",
	"content": "การใช้อักษรพิเศษที่มีหน้าที่เฉพาะ ปกติแล้วข้อความที่พิมพ์ป้อนให้สายอักขระมักจะแสดงผลตามที่ป้อนเข้าไปทั้งหมด แต่ก็มีอักษรบางตัวที่มีหน้าที่พิเศษภายในสายอักขระ ได้แก่ ' \u0026quot; \\ % เวลาต้องการใส่อักษรเหล่านี้ ลงในสายอักขระจึงอาจต้องระวัง สายอักขระจะสร้างขึ้นจากการใช้เครื่องหมายคำพูดแบบเดี่ยว ' หรือแบบคู่ \u0026quot; ล้อมข้อความ แต่ว่าหากต้องการให้มี ' หรือ \u0026quot; อยู่ในสายอักขระแล้วละก็ ต้องระวังเพราะอาจทำให้โปรแกรมตีความผิดเข้าใจว่า ตัดจบหรือเริ่มสายอักขระใหม่ได้ ดังนั้นจึงต้องหาวิธีเลี่ยง วิธีที่ง่ายที่สุดคือการใช้อีกตัวแทน เช่น ถ้าต้องการข้อความที่มี ' อยู่ก็ต้องใช้ \u0026quot;\u0026rdquo; เป็นตัวครอบ\nprint(\u0026#34;คำว่า \u0026#39;รัก\u0026#39; มันยากจะอธิบาย\u0026#34;) ในทางกลับกันถ้าต้องการข้อความที่มี \u0026quot; อยู่ก็ต้องใช้ ' ' เป็นตัวครอบ แต่ถ้าต้องการ ใช้ทั้งสองตัวทีเดียวเลี่ยงไม่ได้จริงๆก็ต้องใช้แบ็กสแลช \\ ช่วย\nprint(\u0026#34;เครื่องหมายคำพูดมีแบบเดี่ยว \u0026#39; \u0026#39; และแบบคู่ \\\u0026#34;\\\u0026#34;\u0026#34;) ผลที่แสดงออกมา\nเครื่องหมายคำพูดมีแบบเดี่ยว \u0026#39; \u0026#39; และแบบคู่ \u0026#34; \u0026#34; เอสเคปคาแร็กเตอร์ นอกจากแบ็กสแลชจะทำหน้าที่นำหน้าอักษรที่มีหน้าที่เฉพาะเพื่อให้ปรากฏตามที่เห็นโดยไม่ถูกตีความแล้ว มีอักษรหลายตัวที่นำหน้าด้วยแบ็กสแลช \\ แล้วมีความหมายพิเศษ ซึ่งเรียกว่า เอสเคปคาแร็กเตอร์ (escape character)\n\\n คือ ขึ้นบรรทัดใหม่ \\t คือ เคาะเว้นย่อหน้า \\b คือ แบ็กสเปซ (ลบตัวอักษร) \\a คือ ส่งเสียงเตือน ตัวอย่าง\nprint(\u0026#39;ma\\bc\u0026#39;) # ได้ mc (เพราะ a ถูกลบ)  print(\u0026#39;a\\ta\u0026#39;) # ได้ a a  print(\u0026#39;\\a\u0026#39;) # จะได้ยินเสียงเตือนดังขึ้นมา หาก \\ ตามด้วยตัวอักษรที่รวมแล้วไม่ได้มีความหมายพิเศษก็จะปรากฏตามที่พิมพ์ไป\nprint(\u0026#39;\\s\u0026#39;) # ได้ \\s แต่หาก \\ ตามด้วยอักษรที่รวมแล้วมีความหมายพิเศษ เช่น n t b a ก็จะเกิดการตีความแล้วให้ผลที่ต่างออกจากที่พิมพ์ ในกรณีที่ต้องการหลีกเลี่ยงไม่ให้เป็นเช่นนั้นสามารถทำได้โดยเขียน \\ ติดกัน ๒ ขีด เป็น \\ เช่น\nprint(\u0026#39;\\\\n\u0026#39;) # ได้ \\n จะเห็นว่ามี \\ ปรากฏขึ้นแค่ตัวเดียว เพราะ \\ ถูกตีความเป็น \\ ตัวเดียว หากต้องการ ๒ ตัวก็พิมพ์ ๔ ตัว\nprint(\u0026#39;\\\\\\\\\u0026#39;) # ได้ \\\\ หากไม่ต้องการให้เอสเคปคาแร็กเตอร์ทำงานเลยก็สามารถทำได้โดยใส่ r ลงไปหน้าเครื่องหมายคำพูด แล้วสายอักขระนั้นจะถูกมองเป็นตัวอักษรตามที่พิมพ์ลงไปทั้งหมด\nprint(r\u0026#39;\\n\\t\\b\\a\u0026#39;) # ได้ \\n\\t\\b\\a ยูนิโค้ด ในสายอักขระสามารถใช้โค้ดในระบบยูนิโค้ดเพื่อแทนตัวอักษรได้ โค้ดจะถูกแปลงเป็นตัวอักษร วิธีการใช้ทำได้โดยใช้ \\u \\U และ \\X\n \\uคคคค ระบุอักษรด้วยรหัสยูนิโค้ดแบบ utf-16 (ค แทนเลขฐาน 16 ทั้งหมด 4 ตัว) \\Uคคคคคคคค ระบุอักษรด้วยรหัสยูนิโค้ดแบบ utf-32 (ค แทนเลขฐาน 16 ทั้งหมด 8 ตัว) \\N{ชื่ออักษร} คือ ระบุอักษรด้วยชื่อที่ถูกเก็บในฐานข้อมูลของยูนิโค้ด  ตัวอย่าง\nprint(\u0026#39;\\u0e2e\u0026#39;) # ได้ ฮ  print(\u0026#39;\\U00000e0e\u0026#39;) # ได้ ฎ  print(\u0026#34;\\N{Thai Character Pho Phan}\u0026#34;) # ได้ พ ในไพธอน 2 จะได้ผลต่างออกไป จำเป็นต้องเติม u นำหน้า อ่านรายละเอียดได้ที่\nการเปลี่ยนรูปแบบการแสดงผลของข้อความ ในการแสดงผลข้อมูลที่เป็นตัวเลขนั้นจะเห็นว่าหากสั่ง print ค่าตัวเลขนั้นโดยตรง จะได้ลักษณะที่มีค่าตายตัวแบบหนึ่ง เช่น จำนวนจริงที่เป็นจำนวนเต็ม จะมีศูนย์หลังจุดแค่ตัวเดียวเสมอ หรือเลขทศนิยมที่เล็กมากหรือใหญ่มากจะถูกเขียนในรูป e เช่น\nprint(3.000000000) # ได้ 3.0  print(0.00000000003) # ได้ 3e-11  print(300000000000000000.) # ได้ 3e+17 แต่ก็มีวิธีที่จะเปลี่ยนการแสดงผลเมื่อใช้คำสั่ง print หรือเมื่อแปลงเป็นสายอักขระได้ ซึ่งทำได้โดยเขียนให้อยู่ในรูปของ %d, %e, %f, ฯลฯ\nการแสดงจำนวนเต็ม %d ใช้แทนจำนวนเต็มที่แทรกอยู่ภายในสายอักขระ โดยค่าของจำนวนเต็ม ที่จะคำนวณนั้นต้องใส่ไว้ด้านหลังเครื่องหมายคำพูด\ni = 20 print(\u0026#39;==%d==\u0026#39;%i) # ได้ ==20== จากตัวอย่างจะเห็นว่าค่าของ i เข้าไปแทนที่ %d สิ่งที่อาจชวนสับสนก็คือ รูปแบบการเขียนแบบนี้มีการใช้เครื่องหมาย % ถึง ๒ ครั้ง แต่ว่า % ทั้ง ๒ นี้เป็นคนละความหมายกัน % ตัวแรกอยู่ภายในเครื่องหมายคำพูด วางอยู่ในตำแหน่งที่ต้องการให้ค่าตัวเลขไปอยู่ แล้วก็ตามด้วยชนิดของข้อมูลที่ต้องการแทน ในที่นี้เป็นจำนวนเต็มใช้ d ส่วน % ตัวหลังอยู่หลังเครื่องหมายคำพูด โดยตามหลังด้วยค่าที่ต้องการนำไปแทน โดยอาจเป็นตัวเลขหรือเป็นตัวแปรก็ได้ การเปลี่ยนการแสดงผลทำได้โดยใส่ส่วนแต่งเติมลงหลัง % ตัวหน้า\nprint(\u0026#39;==%4d==\u0026#39;%19) # ได้ == 19== ให้เพิ่มช่องว่างจนครบ 4 ตำแหน่ง  print(\u0026#39;==%4d==\u0026#39;%19000) # ==19000== ถ้าเลขเกิน 4 อยู่แล้วไม่มีผล  print(\u0026#39;==%04d==\u0026#39;%19) # ได้ ==0019== ให้ใส่เลข 0 จนถึง 4 ตำแหน่ง  print(\u0026#39;==%04d==\u0026#39;%19000) # ==19000== ถ้าเลขเกิน 4 อยู่แล้วไม่มีผล  print(\u0026#39;==%+d==\u0026#39;%19) # ได้ ==+19== ให้ใส่เครื่องหมาย + เมื่อเป็นค่าบวก  print(\u0026#39;==%+d==\u0026#39;%-19) # ได้ ==-19== ถ้าเป็นลบอยู่แล้วไม่มีผล  print(\u0026#39;==%+04d==\u0026#39;%19) # ได้ ==+019== 4 ตำแหน่งนี้นับรวมเครื่องหมายด้วย ตัวอย่าง ไล่เรียงหมายเลขโดยขึ้นเป็น ๒ หลัก\ns = [\u0026#39;no.%02d\u0026#39;%i for i in range(1,21)] print(s) # ได้ [\u0026#39;no.01\u0026#39;, \u0026#39;no.02\u0026#39;, \u0026#39;no.03\u0026#39;, \u0026#39;no.04\u0026#39;, \u0026#39;no.05\u0026#39;, \u0026#39;no.06\u0026#39;, \u0026#39;no.07\u0026#39;, \u0026#39;no.08\u0026#39;, \u0026#39;no.09\u0026#39;, \u0026#39;no.10\u0026#39;, \u0026#39;no.11\u0026#39;, \u0026#39;no.12\u0026#39;, \u0026#39;no.13\u0026#39;, \u0026#39;no.14\u0026#39;, \u0026#39;no.15\u0026#39;, \u0026#39;no.16\u0026#39;, \u0026#39;no.17\u0026#39;, \u0026#39;no.18\u0026#39;, \u0026#39;no.19\u0026#39;, \u0026#39;no.20\u0026#39;] หากมีส่วนที่ต้องการแทรกอยู่หลายตัวก็ให้ใส่ตัวแปรตามจำนวนนั้นโดยใส่วงเล็บแล้วคั่นด้วยจุลภาค ,ตัวอย่าง แสดงวันเดือนปี\nprint(\u0026#39;%02d/ %02d/ %04d\u0026#39;%(9,2,2016)) # ได้ 09 / 02 / 2016 แปลงเลขเป็นฐาน 16 นอกจาก %d ที่ให้แสดงเลขตามปกติเป็นฐาน 10 ที่เราคุ้นเคยกันดีแล้ว หากแทนด้วย %x ก็จะได้ค่าเป็นเลขฐาน 16 แทน\nprint(\u0026#39;%x\u0026#39;%(2**16-1)) # ได้ ffff  print(\u0026#39;%x\u0026#39;%(27365824924)) # ได้ 65f21599c  print(\u0026#39;%09x\u0026#39;%1000) # ได้ 0000003e8 เลขฐาน 16 มีประโยชน์ เพราะใช้แทนค่ารหัสสีซึ่งมักประกอบไปด้วยค่าของเลขฐาน 16 ของค่าแม่สีทั้งสาม\nprint(\u0026#39;#%02x%02x%02x\u0026#39;%(10,252,90)) # ได้#0afc5a การแสดงเลขจำนวนจริง จำนวนจริงใช้ %f ในการแสดง สามารถปรับตำแหน่งหลักและตำแหน่งเลขทศนิยมได้\nprint(\u0026#39;==%12f==\u0026#39;%129.3) # ได้ == 129.300000== เติมช่องว่างจนครบ 12 ตำแหน่ง  print(\u0026#39;==%012f==\u0026#39;%129.3) # ได้ ==00129.300000== เติม 0 จนครบ 12 ตำแหน่ง  print(\u0026#39;==%.3f==\u0026#39;%129.3) # ได้ ==129.300== ทศนิยม 3 ตำแหน่ง  print(\u0026#39;==%.0f==\u0026#39;%129.3) # ได้ ==129== เศษถูกปัดทิ้ง  print(\u0026#39;==%12.3f==\u0026#39;%129.3) # ได้ == 129.300==  print(\u0026#39;==%012.3f==\u0026#39;%129.3) # ได้ ==00000129.300== อีกวิธีในการแสดงผลก็คือใช้ %e ซึ่งจะแสดงเป็นตัวเลขในรูปแบบ e\npi = 3.14159 print(\u0026#39;==%e==\u0026#39;%pi) # ได้ ==3.141590e+00==  print(\u0026#39;==%15e==\u0026#39;%pi) # ได้ == 3.141590e+00==  print(\u0026#39;==%015e==\u0026#39;%pi) # ได้ ==0003.141590e+00==  print(\u0026#39;==%.8e==\u0026#39;%pi) # ได้ ==3.14159000e+00==  print(\u0026#39;==%.2e==\u0026#39;%pi) # ได้ ==3.14e+00==  print(\u0026#39;==%015.8e==\u0026#39;%pi) # ได้ ==3.14e+00== นอกจากนี้ยังมี %s ซึ่งแสดงผลสายอักขระเอง\nprint(\u0026#39;==%s==\u0026#39;%\u0026#39;asa\u0026#39;) # ได้ ==asa==  print(\u0026#39;==%5s==\u0026#39;%\u0026#39;asa\u0026#39;) # ได้ == asa6== โดย %s นี้ยังใช้กับข้อมูลชนิดกลุ่มเช่นลิสต์หรือทูเพิลได้ด้วย ผลที่ได้จะเหมือนกับเวลาที่ print ลิสต์หรือทูเพิลนั้นออกมาโดดๆ\nprint(\u0026#39;==%s==\u0026#39;%[1,2]) # ได้ ==[1, 2]==  print(\u0026#39;==%25s==\u0026#39;%[\u0026#39;a\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;a\u0026#39;]) # ได้ == [\u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;a\u0026#39;]== สำหรับลิสต์ไม่มีปัญหาอะไร แต่กรณีที่ต้องการใช้กับทูเพิลจะมีความยุ่งยากเล็กน้อย เนื่องจากโดยทั่วไปเมื่อมีทูเพิลอยู่หลัง % จะถูกตีความว่าเป็นการใส่ข้อมูลหลายตัว ดังนั้นต้องเขียนในรูปทูเพิลซ้อนทูเพิล\nprint(\u0026#39;==%s==\u0026#39;%(\u0026#39;a\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;a\u0026#39;)) # ได้ TypeError: not all arguments converted during string formatting  print(\u0026#39;==%s%s%s==\u0026#39;%(\u0026#39;a\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;a\u0026#39;)) # ได้ ==a s a==  print(\u0026#39;==%s==\u0026#39;%((\u0026#39;a\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;a\u0026#39;),)) # ได้ ==(\u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;a\u0026#39;)== กรณีที่มีข้อมูลมาแทนเป็นจำนวนไม่เท่ากันกับจำนวน % ที่อยู่ด้านหน้า หรือชนิดผิด ก็จะขัดข้องทันที\nprint(\u0026#39;==%s,%s==\u0026#39;%\u0026#39;asa\u0026#39;) # ได้ TypeError: not enough arguments for format string  print(\u0026#39;==%f==\u0026#39;%\u0026#39;asa\u0026#39;) # ได้ TypeError: a float is required กรณีมี % ตัวอื่นอยู่ในสายอักขระและไม่ได้ต้องการให้แสดงผลด้วยเลยให้ใส่ % นำหน้าอีกตัว\nprint(\u0026#39;==%.2f%%formaldehyde==\u0026#39;%70) # ได้ ==70%formaldehyde== สรุปเนื้อหา  ในบทนี้ได้เข้าใจรูปแบบการแสดงผลของสายอักขระแล้ว เมื่อเข้าใจแล้ว ก็จะสามารถเปลี่ยนผลให้ออกมาได้ตามที่ต้องการ ต้องระวังการใช้เอสเคปคาแร็กเตอร์ \\n \\t \\b \\a ' \u0026quot; \\ ให้ดี เวลาที่แปลงตัวเลขเป็นสายอักขระมักถูกตีความในรูปแบบที่ถูกกำหนดมาแล้ว แต่ด้วย %d %x %f %e สามารถเปลี่ยนให้หลากหลายขึ้นได้  อ้างอิง\n http://docs.python.jp/3/howto/unicode.html http://www.tohoho-web.com/python/types.html http://www.isl.ne.jp/pcsp/python/python18.html   Reference : https://phyblas.hinaboshi.com/tsuchinoko10\n "
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/learning-python/11_string_methods/",
	"title": "11. String methods",
	"tags": [],
	"description": "",
	"content": "ในบทก่อนหน้า เราได้พูดเกี่ยวกับการใช้งาน String ในเบื้องต้นไปแล้ว ในบทนี้ เราจะแนะนำเมธอดและการใช้งานเมธอดในคลาส String ในภาษา Python นั้น String เป็นคลาสมาตรฐานสำหรับจัดการข้อมูลประเภทข้อความ และในคลาสจะมีเมธอดสำหรับจัดการข้อมูลและอำนวยความสะดวกในการเขียนโปรแกรมเป็นอย่างมากและช่วยลดเวลาในการเขียนโปรแกรมของคุณ\nFind and search ในคลาสของ String มีเมธอดประเภทต่างๆ ในการจัดการกับ String เมธอดกลุ่มแรกที่เราจะแนะนำให้คุณรู้จักคือเมธอดเกี่ยวกับการค้นหาและตรวจสอบตำแหน่งภายใน String มาดูตัวอย่างของการใช้เมธอดดังกล่าวในภาษา Python\ns = \u0026#39;mountain\u0026#39; print(s.startswith(\u0026#39;moun\u0026#39;)) print(s.endswith(\u0026#39;in\u0026#39;)) print(s.find(\u0026#39;n\u0026#39;)) print(s.rfind(\u0026#39;n\u0026#39;)) print(s.replace(\u0026#39;moun\u0026#39;, \u0026#39;con\u0026#39;)) print(s.count(\u0026#39;a\u0026#39;)) ในตัวอย่าง เป็นการใช้งานเมธอดในการค้นหาและการทำงานกับตำแหน่งใน String โดยเมธอด startswith() เป็นเมธอดในการตรวจสอบว่า String นั้นเริ่มต้นด้วย 'moun' หรือไม่ และเมธอด endswith() เพื่อตรวจสอบว่า String นั้นจบด้วย 'in' หรือไม่ เพราะว่าข้อมูลใน String นั้นตรงกับเงื่อนไขดังกล่าวซึ่งมีค่าเป็นจริง\nprint(s.find(\u0026#39;n\u0026#39;)) print(s.rfind(\u0026#39;n\u0026#39;)) ต่อไปเป็นการใช้เมธอด find() เพื่อค้นหาตำแหน่ง Index ของ Sub string 'n' ที่พบครั้งแรกใน String และเมธอด rfind() เป็นการค้นหาจากด้านหลังจากตำแห่งแรกที่พบเช่นกัน ซึ่งจะได้ Index เป็น 3 และ 7 ตามลำดับ\nprint(s.replace(\u0026#39;moun\u0026#39;, \u0026#39;con\u0026#39;)) print(s.count(\u0026#39;a\u0026#39;)) และเมธอด replace() เป็นการใช้สำหรับแทนที่คำใน Srting โดยเราได้ทำการแทนที่ 'moun' ด้วย 'con' ซึ่งถ้าหากคำดังกล่าวพบมากกว่าหนึ่งครั้งใน String จะทำการแทนที่ทั้งหมดที่เจอ และเมธอด count() ใช้สำหรับนับตัวอักษรที่ระบุที่พบใน String เราได้ทำการนับว่าพบตัวอักษร 'a' เป็นจำนวนเท่าไหร่ใน String\nTrue True 3 7 contain 1 นี่เป็นผลลัพธ์การทำงานของโปรแกรม ในการใช้เมธอดเกี่ยวกับการค้นหาและทำงานในตำแหน่งของ String\nText and sentence ในภาษา Python คลาสของ String ยังมีเมธอดในการทำงานเกี่ยวกับ text และข้อความ เมธอดเหล่านี้มักจะใช้สำหรับการจัดแสดงผลข้อความในโปรแกรมหรือเว็บไซต์ให้อยู่ในรูปแบบเดี่ยวกัน เช่น การเปลี่ยนตัวแรกของประโยคให้เป็นตัวพิมพ์ใหญ่ หรือแสดงข้อความในตัวพิมพ์เล็กหรือตัวพิมพ์ใหญ่ เป็นต้น มาดูตวอย่างการใช้งาน\ns = \u0026#39;this is a game that i love to play.\u0026#39; print(s.capitalize()) print(s.title()) print(s.upper()) print(\u0026#39;MARCUSCODE.COM\u0026#39;.lower()) ในตัวอย่าง เป็นการใช้งานเมธอดต่างๆ ในการจัดการกับข้อความ เมธอด capitalize() ใช้สำหรับทำให้ตัวอักษรตัวแรกของ String เป็นตัวพิมพ์ใหญ่ ในขณะที่เมธอด title() นั้นจะทำให้ตัวแรกในทุกๆ คำที่คั่นด้วย white space เป็นตัวพิมพ์ใหญทั้งหมด\nสำหรับเมธอด upper() แปลงให้ตัวอักษรทุกตัวใน String เป็นตัวพิมพ์ใหญ่ และเมธอด lower() แปลงให้ตัวอักษรทุกตัวใน String เป็นตัวพิมพ์เล็ก\nThis is a game that i love to play. This Is A Game That I Love To Play. THIS IS A GAME THAT I LOVE TO PLAY. marcuscode.com นี่เป็นผลลัพธ์การทำงานของโปรแกรม ในการใช้งานเมธอดจัดการกับข้อความเกี่ยวกับตัวพิมพ์ใหญ่และตัวพิมพ์เล็ก\nFormatting string ในภาษา Python นั้นคลาสของ String ยังมีเมธอดในการจัดรูปแบบของ String สำหรับการแสดงผลอีกด้วย เช่น การเติมตัวอักษรเข้าไปใน String หรือการลบตัวอักษรที่ไม่ต้องการออกไปจาก String มาดูตัวอย่างการใช้งาน\ns = \u0026#39;Python\u0026#39; print(s.center(10)) print(s.ljust(10)) print(s.rjust(10)) print(s.center(10, \u0026#39;#\u0026#39;)) print(s.ljust(10, \u0026#39;#\u0026#39;)) print(s.rjust(10, \u0026#39;#\u0026#39;)) number = \u0026#39;83\u0026#39; print(number.zfill(6)) print(\u0026#39;-1.32\u0026#39;.zfill(8)) ใน 3 เมธอดแรก คือเมธอดที่ใช้ในการเติมตัวอักษรเข้าไปในข้อความให้ได้ตามจำนวนที่ต้องการ เมธอด center() ใช้สำหรับเติมข้อความเข้าไปทางซ้ายและทางขวาให้ String มีความยาวกับที่ระบุ ส่วนเมธอด ljust() นั้นทำงานเช่นเดียวกันแต่เติมตัวอักษรเฉพาะทางซ้าย และเมธอด rjust() เติมตัวอักษรเพียงด้านขวา อาร์กิวเมนต์แรกเป็นจำนวนของ String ทั้งหมด ส่วนอาร์กิวเมนต์ที่สองเป็นทางเลือกโดยเป็นตัวอักษรที่ต้องการเติมลงไป และมีค่า Default เป็น Space และเมธอด zfill() เป็นการใช้เติมตัวเลข 0 โดยเรามักจะใช้กับ String ที่มีรูปแบบเป็นตัวเลข\nPython Python Python ##Python## Python#### ####Python 000083 -0001.32 นี่เป็นผลลัพธ์การทำงานของโปรแกรมในการใช้เมธอดสำหรับเติมข้อความ ในกลุ่มคำสั่งแรกเป็นการเติมช่องว่างลงไปทางซ้ายและขวาของ 'Python' และหลังจากนั้นเติมเครื่องหมาย '#' และสุดท้ายเติมเลข 0 ลงไปข้างหน้าของ String ในรูปแบบตัวเลข\ns = \u0026#39; Python \u0026#39; print(s.strip()) print(s.lstrip()) print(s.rstrip()) s2 = \u0026#39;----marcuscode----\u0026#39; print(s2.strip(\u0026#39;-\u0026#39;)) print(s2.lstrip(\u0026#39;-\u0026#39;)) print(s2.rstrip(\u0026#39;-\u0026#39;)) นอกจากเมธอดในการเติมข้อความแล้ว ยังมีเมธอดในการตัดคำออกจากข้อความด้วยเช่นกัน โดยเมธอด strip() ใช้สำหรับตัดลำดับของตัวอักษรที่พบในทางซ้ายและทางขวาออกไป เมธอด rstrip() นั้นจะตัดเพียงทางขวา และเมธอด lstrip() จะตัดเพียงทางซ้าย อาร์กิวเมนต์เป็นตัวอักษรที่คุณต้องการตัด และมีค่า Default เป็น Space ถ้าหากคุณเว้นว่างไว้\nPython Python Python marcuscode marcuscode---- ----marcuscode นี่เป็นผลลัพธ์การทำงานของโปรแกรม ในกลุ่มคำสั่งแรกเป็นการตัดช่องว่างออกไปจากทางซ้ายและขวาของ String และกลุ่มต่อไปเป็นการตัดตัวอักษร `` ออกไปจากทางซ้ายและขวาของ String\nในภาษา Python ยังมีเมธอด format() สำหรับจัดรูปแบบการแสดงผลของ String ที่เรียกว่า String interpolation การทำงานของเมธอดนั้นจะคล้ายกับการจัดการแสดงผลในฟังก์ชัน print() มาดูตัวอย่างการใช้งาน\nprint(\u0026#39;a = {0}\u0026#39;.format(3)) print(\u0026#39;{0} loves to learn {1}\u0026#39;.format(\u0026#39;Mateo\u0026#39;, \u0026#39;Python\u0026#39;)) ในการใช้งานเมธอด format() นั้นเราต้องกำหนดรูปแบบการแสดงผลให้กับ String ในรูปแบบ {n} โดยที่ n นั้นเป็นลำดับของอาร์กิวเมนต์ที่ส่งเข้าไปในเมธอดซึ่งเป็นจำนวนเต็มที่เริ่มจาก 0 ไปเรื่อยๆ ในคำสั่งแรกนั้นมีเพียงหนึ่งอาร์กิวเมนต์ และในคำสั่งที่สองนั้นมีสองอาร์กิวเมนต์ เราจะเพิ่ม {1} เข้ามาสำหรับอาร์กิวเมนต์ที่สอง\na = 3 Mateo loves to learn Python นี่เป็นผลลัพธ์การทำงานของโปรแกรม\nType checking เมธอดที่สำคัญในคลาส String อีกกลุ่มหนึ่งคือเมธอดในการตรวจสอบประเภทข้อมูลภายใน String ว่าเป็นประเภทที่กำหนดหรือไม่ เช่น การตรวจสอบหาว่ามีตัวเลขภายใน String หรือไม่ หรือตรวจสอบว่า String นั้นเป็นตัวเลขหรือไม่ เป็นต้น มาดูตัวอย่างการใช้งาน\n# tesing true print(\u0026#39;marcuscode2017\u0026#39;.isalnum()) print(\u0026#39;bobby\u0026#39;.isalpha()) print(\u0026#39;1234\u0026#39;.isdecimal()) print(\u0026#39;1234\u0026#39;.isdigit()) print(\u0026#39;1234\u0026#39;.isnumeric()) print(\u0026#39;mateo\u0026#39;.islower()) print(\u0026#39;MATEO\u0026#39;.isupper()) # tesing false print(\u0026#39;marcuscode 2017\u0026#39;.isalnum()) # has space print(\u0026#39;bobby1\u0026#39;.isalpha()) # has number print(\u0026#39;7F\u0026#39;.isdecimal()) # F is not decimal print(\u0026#39;1234A\u0026#39;.isdigit()) # A is not digit print(\u0026#39;Python\u0026#39;.isnumeric()) # not number print(\u0026#39;Mateo\u0026#39;.islower()) # M is upper case print(\u0026#39;Mateo\u0026#39;.isupper()) # Not all are upper case ในตัวอย่าง เป็นทดสอบการตรวจสอบ String ด้วยเมธอดต่างๆ สำหรับการตรวจสอบที่เป็นจริงและไม่เป็นจริง สำหรับการทดสอบที่ไม่เป็นจริงนั้นเราได้คอมเมนต์เหตุผลที่ทำให้ไม่เป็นจริงด้วย และนี่เป็นผลลัพธ์การทำงานของโปรแกรม\nTrue True True True True True True False False False False False False False List and sequence methods นอกจากนี้ในคลาส String ยังมีเมธอดที่ทำงานเกี่ยวกับ List ในการรวม String จากลิสต์เข้าด้วยกันด้วยเมธอด join() หรือการตัดคำออกจาก String ด้วยเมธอด split() หรือเมธอด splitlines() นี่เป็นตัวอย่างการใช้งานเมธอดเหล่านี้\ncountries = [\u0026#39;England\u0026#39;, \u0026#39;Turkey\u0026#39;, \u0026#39;Poland\u0026#39;, \u0026#39;Russia\u0026#39;, \u0026#39;Germany\u0026#39;] print(\u0026#39;, \u0026#39;.join(countries)) lang = \u0026#39;Java PHP C++ Python C#\u0026#39; print(lang.split(\u0026#39; \u0026#39;)) text = \u0026#39;Python is a language\\nused to create a web,\\n\u0026#39; text += \u0026#39;desktop application\\nand more\u0026#39; text2 = text.splitlines() for t in text2: print(t) ในตัวอย่าง เรามีตัวแปรลิสต์ countries สำหรับเก็บข้อมูลของประเทศต่างๆ เราใช้เมธอด join() เพื่อรวม String ในลิสต์เข้าด้วยกันโดยคั่นด้วย ', ' และในตัวแปร lang นั้นเป็นข้อความที่คั่นด้วยช่องว่าง เราใช้เมธอด split() เพื่อแยก String ออกจากตัวแปรและจะได้ผลลัพธ์เป็นลิสต์ คุณสามารถใช้ตัวอักษรอื่นได้โดยใส่ในอาร์กิวเมนต์ของเมธอด สำหรับเมธอด splitlines() เป็นการแบ่ง String ด้วยการขึ้นบรรทัดใหม่\nEngland, Turkey, Poland, Russia, Germany [\u0026#39;Java\u0026#39;, \u0026#39;PHP\u0026#39;, \u0026#39;C++\u0026#39;, \u0026#39;Python\u0026#39;, \u0026#39;C#\u0026#39;] Python is a language used to create a web, desktop application and more นี่เป็นผลลัพธ์การทำงานของโปรแกรม\nในบทนี้ คุณได้รู้จักกับการใช้งานเมธอดจากคลาส String ในรูปแบบต่างๆ เช่น เมธอดในการค้นหาข้อความและ Index ของ String เมธอดในการทำงานเพื่อแปลง String เป็นตัวพิมพ์เล็กและตัวพิมพ์ใหญ่ เมธอดที่ใช้ในการจัดรูปแบบของ String เมธอดในการตรวจสอบประเภทและข้อมูลใน String เป็นต้น ซึ่งเราได้แนะนำให้คุณรู้จักในเบื้องต้น สำหรับเมธอดทั้งหมดคุณสามารถดูได้ที่เอกสารของเว็บไซต์ภาษา Python ที่ https://docs.python.org/3/library/stdtypes.html#string-methods\nReference : http://marcuscode.com/lang/python/string-methods\n"
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/phyblas/beginer/string_format/",
	"title": "การจัดการกับสายอักขระ",
	"tags": [],
	"description": "",
	"content": "ความยาวของสายอักขระ สายอักขระอาจยาวเท่าใดก็ได้ การหาความยาวของสายอักขระทำได้เช่นเดียวกับลิสต์หรือทูเพิล คือใช้ฟังก์ชัน len\nprint(len(\u0026#39;กขคงจ\u0026#39;)) # ได้ 5 สายอักขระอาจจะมีความยาวเป็นศูนย์ก็ได้ ซึ่งเขียนแทนด้วยเครื่องหมายคำพูดติดกันสองตัวโดยไม่มีอะไรข้างใน\nprint(len(\u0026#39;\u0026#39;)) # ได้ 0 ช่องว่างจะถูกนับรวมความยาวด้วย ต่อให้ไม่ได้อยู่ตรงกลางก็ตาม\nprint(len(\u0026#39; \u0026#39;)) # ได้ 2 ภายในสายอักขระอักษรทุกตัวมีความยาวตัวละหน่วยเท่ากันหมด ไม่ว่าจะเป็นอักษรอะไรก็ตาม จะเป็นอักษร ASCII หรือไม่ก็ตาม\n***ข้อนี้สำหรับไพธอน 3 ส่วนในไพธอน 2 จะแตกต่างออกไป รายละเอียด\nการเข้าถึงสมาชิกของสายอักขระ สายอักขระก็เป็นข้อมูลชนิดลำดับเช่นเดียวกับลิสต์หรือทูเพิล ดังนั้นสามารถเข้าถึงข้อมูลได้โดยใส่ลำดับสมาชิกในวงเล็บเหลี่ยม\na = \u0026#39;bestuurdersaansprakelijkheidsverzekering\u0026#39; print(a[0]) # ได้ b  print(a[-1]) # ได้ g  print(a[int(len(a)/2)]) # ได้ l สามารถเข้าถึงทีละหลายตัวด้วยการใช้ : เช่นกัน\na[29:40] # ได้ verzekering  a[0:40:2] # ได้ \u0026#39;bsuresasrkljhisezkrn\u0026#39; การแก้ไขและเพิ่มข้อความในสายอักขระ\nสายอักขระไม่สามารถแก้ไขข้อมูลอะไรได้ เช่นเดียวกับทูเพิล\nb = \u0026#39;เขาเป็นคนป่วย\u0026#39; b[9:11] = \u0026#39;ร\u0026#39; # ได้ TypeError: \u0026#39;str\u0026#39; object does not support item assignment แม้ว่าจะไม่สามารถแก้ไขข้อความข้างในได้ แต่ก็สามารถสร้างใหม่ทับตัวเก่าได้\nb = b[:9]+\u0026#39;ร\u0026#39;+b[11:] print(b) # ได้ เขาเป็นคนรวย ส่วนการเพิ่มข้อความในสายอักขระก็ทำได้โดยเอาสายอักขระเดิมมาบวกกับสิ่งที่ต้องการเพิ่ม\nc = \u0026#39;เขาเป็นคนดี\u0026#39; c += \u0026#39;แต่พูด\u0026#39; print(c) # ได้ เขาเป็นคนดีแต่พูด การเปรียบเทียบสายอักขระ สายอักขระสามารถนำมาทำการเปรียบเทียบเพื่อหาค่าความจริงเท็จได้โดย เมื่อใช้เครื่องหมาย == จะให้ค่าเป็นจริงต่อเมื่อเหมือนกันทุกตัวอักษร\nprint(\u0026#39;J\u0026#39; == \u0026#39;j\u0026#39;) # False เพราะพิมพ์เล็กกับพิมพ์ใหญ่ถือเป็นคนละตัว  print(\u0026#39;J\u0026#39; == \u0026#39;j\u0026#39;.upper()) #True เมื่อใช้เปรียบเทียบมากกว่า \u0026gt; หรือน้อยกว่า \u0026lt; จะเปรียบเทียบลำดับภายในยูนิโค้ดของอักษรนั้นทีละตัว โดยเลขที่มาก่อนถือว่าค่าน้อยกว่า หากเหมือนกันจึงจะพิจารณาตัวต่อไป\nprint(\u0026#39;11\u0026#39; \u0026gt; \u0026#39;2\u0026#39;) # False เพราะเลข 1 เทียบกับ 2 ก่อน  print(\u0026#39;A\u0026#39; \u0026gt; \u0026#39;a\u0026#39;) # False เพราะตัวพิมพ์ใหญ่มาก่อนตัวพิมพ์เล็ก  print(\u0026#39;ü\u0026#39; \u0026gt; \u0026#39;z\u0026#39;) # True เพราะ z เป็น ASCII แต่ ü ไม่ใช่  print(\u0026#39;ม\u0026#39; \u0026gt; \u0026#39;美\u0026#39;) # False เพราะอักษรไทยมาก่อนอักษรจีนในยูนิโค้ด  print(\u0026#39;ア\u0026#39; \u0026gt; \u0026#39;あ\u0026#39;) # True เพราะฮิรางานะมาก่อนคาตาคานะ การตัดช่องว่างหัวท้าย ช่องว่างที่หัวท้ายของสายอักขระสามารถทำให้หายไปได้โดยใช้เมธอด strip\nprint(len(\u0026#39; แม่นแล้ว \u0026#39;)) # ได้ 13  print(\u0026#39; แม่นแล้ว \u0026#39;.strip()) # ได้ แม่นแล้ว  print(len(\u0026#39; แม่นแล้ว \u0026#39;.strip())) # ได้ 8 หากต้องการตัดแค่หัวหรือท้ายอย่างเดียวก็ใช้ lstrip หรือ rstrip โดย lstrip จะตัดเฉพาะหัว ส่วน rstrip จะตัดเฉพาะท้าย\nprint(len(\u0026#39; แม่นแล้ว \u0026#39;.lstrip())) # ได้ 11  print(len(\u0026#39; แม่นแล้ว \u0026#39;.rstrip())) # ได้ 10 การแบ่งและเชื่อมรวมสายอักขระ สามารถแยกสายอักขระออกเป็นส่วนๆได้ด้วยเมธอด split โดยเมธอดนี้จะสร้างลิสต์ของสายอักขระแต่ละส่วนที่แยกได้ออกมา\nโดยในการแยกจำเป็นต้องระบุว่าจะใช้สัญลักษณ์อะไรเป็นตัวแยก โดยใส่เป็นอาร์กิวเมนต์ในเมธอด เช่นหากต้องการให้แยกตามจุลภาพ ,\nit = \u0026#39;pasta, spaghetti, macaroni, lasagna, pizza\u0026#39; ita = it.split(\u0026#39;, \u0026#39;) print(ita) # ได้ [\u0026#39;pasta\u0026#39;, \u0026#39;spaghetti\u0026#39;, \u0026#39;macaroni\u0026#39;, \u0026#39;lasagna\u0026#39;, \u0026#39;pizza\u0026#39;] หากไม่ใส่อาร์กิวเมนต์อะไรลงในเมธอดเลยจะแยกตามช่องว่าง\nfr = \u0026#39;croissant baguette éclair macaron madeleine\u0026#39; fra = fr.split() print(fra) # ได้ [\u0026#39;croissant\u0026#39;, \u0026#39;baguette\u0026#39;, \u0026#39;éclair\u0026#39;, \u0026#39;macaron\u0026#39;, \u0026#39;madeleine\u0026#39;] ในทางตรงข้ามมีเมธอดที่ชื่อ join เอาไว้ใช้รวมลิสต์ของสายอักขระเข้าเป็นสายอักขระอันเดียว\njoin นั้นถือเป็นเมธอดของสายอักขระโดยทำกับสายอักขระที่เป็นตัวคั่นแล้วมีอาร์กิวเมนต์เป็นลิสต์ของสายอักขระที่ต้องการรวม\nวิธีการใช้อาจดูแล้วเข้าใจยากกว่า split อยู่หน่อยและอาจสับสนกันได้ ให้ดูตัวอย่างประกอบ\nf = [\u0026#39;ยานี้ดี\u0026#39;, \u0026#39;กินแล้วแข็ง\u0026#39;, \u0026#39;แรงไม่มี\u0026#39;, \u0026#39;โรคภัยไข้เจ็บเบียดเบียน\u0026#39;] g = \u0026#39;\u0026#39;.join(f) print(g) # ได้ ยานี้ดีกินแล้วแข็งแรงไม่มีโรคภัยไข้เจ็บเบียดเบียน ลองเขียนโปรแกรมสำหรับเชื่อมโดยไม่ใช้ join ดูก็สามารถทำได้\nf = [\u0026#39;ยานี้ดี\u0026#39;, \u0026#39;กินแล้วแข็ง\u0026#39;, \u0026#39;แรงไม่มี\u0026#39;, \u0026#39;โรคภัยไข้เจ็บเบียดเบียน\u0026#39;] g = \u0026#39;\u0026#39; for s in f: g += s print(g) ตัวเชื่อมอาจใช้เป็นอะไรก็ได้ เช่นเว้นวรรคก็ใช้ \\n\nh = \u0026#39;\\n\u0026#39;.join([\u0026#39;ooo\u0026#39;,\u0026#39;o o\u0026#39;,\u0026#39;ooo\u0026#39;]) print(h) จะได้สายอักขระที่มี ๓ บรรทัด\nooo o o ooo สำหรับการแยกสายอักขระโดยใช้การขึ้นบรรทัดใหม่เป็นตัวแยกอาจใช้เมธอด splitlines เช่นลองใช้กับสายอักขระตัวเมื่อครู่\nprint(h.splitlines()) # ได้กลับมาเป็น [\u0026#39;ooo\u0026#39;, \u0026#39;o o\u0026#39;, \u0026#39;ooo\u0026#39;] หากต้องการแยกสายอักขระออกเป็นทีละตัวๆก็อาจทำได้ง่ายๆด้วยการใช้ list แปลงเป็นลิสต์ได้เลย\nprint(list(\u0026#39;กลุ่มก้อน\u0026#39;)) # ได้ [\u0026#39;ก\u0026#39;, \u0026#39;ล\u0026#39;, \u0026#39;ุ\u0026#39;, \u0026#39;่\u0026#39;, \u0026#39;ม\u0026#39;, \u0026#39;ก\u0026#39;, \u0026#39;้\u0026#39;, \u0026#39;อ\u0026#39;, \u0026#39;น\u0026#39;] การเปลี่ยนตัวพิมพ์ใหญ่พิมพ์เล็ก อักษรโรมันมักประกอบไปด้วยตัวพิมพ์เล็กและพิมพ์ใหญ่ ในภาษาไพธอนมีคำสั่งสำหรับเปลี่ยนข้อความในสายอักขระทั้งหมดเป็นพิมพ์เล็ก หรือพิมพ์ใหญ่ทั้งหมด นั่นคือใช้เมธอด upper และ lower\na = \u0026#39;Die Flügel der Freiheit\u0026#39; print(a.upper()) # ได้ DIE FLÜGEL DER FREIHEIT  print(a.lower()) # ได้ die flügel der freiheit อักษรกรีกเองก็มีตัวพิมพ์เล็กพิมพ์ใหญ่ สามารถใช้ได้ด้วย\na = \u0026#39;Αστρονομία\u0026#39; print(a.upper()) # ΑΣΤΡΟΝΟΜΊΑ  print(a.lower()) # αστρονομία ***แต่ถ้าใช้ในไพธอน 2 มีข้อต้องระวัง อ่านรายละเอียด\nสำหรับอักษรไทยไม่มีตัวพิมพ์เล็กพิมพ์ใหญ่จึงไม่มีผลอะไรกับเมธอดนี้\nลองเขียนโปรแกรมให้สร้างสายอักขระขึ้นใหม่โดยเปลี่ยนคำที่เป็นตัวพิมพ์เล็กทั้งหมดให้เป็นตัวพิมพ์ใหญ่สลับกับตัวพิมพ์เล็ก\na = \u0026#39;pneumoultramicroscopicossilicovulcanoconioticozinhos\u0026#39; b = \u0026#39;\u0026#39; for i in range(0,len(a),2): b += a[i].upper() if(i\u0026lt;len(a)-1): b += a[i+1] print(b) # ได้ PnEuMoUlTrAmIcRoScOpIcOsSiLiCoVuLcAnOcOnIoTiCoZiNhOs การค้นหาข้อความที่ต้องการภายในสายอักขระ การจะตรวจว่าข้อความสั้นๆที่เราต้องการค้นนั้นอยู่ภายในสายอักขระยาวๆหรือไม่สามารถใช้ in เช่น\n\u0026#39;Essen\u0026#39; in \u0026#39;Sie sind das Essen und wir sind die Jäger\u0026#39; # ได้ True หากต้องการหาว่าคำที่ต้องการนั้นอยู่ในตำแหน่งไหนก็อาจทำการวนซ้ำเพื่อค้น เช่น\ng = \u0026#39;Sie sind das Essen und wir sind die Jäger\u0026#39; s = \u0026#39;Essen\u0026#39; if(s in guren): for i in range(len(g)): if(s not in g[i:]): print(i-1) break else: print(\u0026#39;ไม่พบคำที่ต้องการหา\u0026#39;) ผลลัพธ์จะได้ 13\nอย่างไรก็ตามในภาษาไพธอนมีคำสั่งที่สามารถช่วยค้นหาได้โดยอัตโนมัติอยู่ นั่นคือ find\nโครงสร้าง\nสายอักขระ.find(คำที่ค้น, จุดเริ่มค้น, จุดสิ้นสุดการค้น)\nโดยที่จุดเริ่มต้นและสิ้นสุดอาจใส่หรือไม่ใส่ก็ได้ ถ้าไม่ใส่ก็จะค้นทั้งหมด\ng = \u0026#39;Sie sind das Essen und wir sind die Jäger\u0026#39; print(g.find(\u0026#39;Essen\u0026#39;)) # ได้ 13 หากค้นหาแล้วไม่พบ จะคืนค่า -1\nprint(g.find(\u0026#39;der\u0026#39;)) # ได้ -1 กรณีที่มีคำที่ค้นอยู่ ๒ ตัวขึ้นไป จะขึ้นตำแหน่งของตัวแรก\nprint(g.find(\u0026#39;sind\u0026#39;)) # ได้ 4 หากต้องการให้ค้นไล่มาจากด้านหลังให้ใช้เมธอด rfind\nprint(g.rfind(\u0026#39;sind\u0026#39;)) # ได้ 27 กรณีที่กำหนดจุดเริ่มต้นและจุดสิ้นสุด ถ้าตัวที่ต้องการหาไม่อยู่ในขอบเขตก็จะหาไม่พบ\nprint(g.find(\u0026#39;Sie\u0026#39;,3)) # ได้ -1 (คือหาไม่พบ)  print(g.find(\u0026#39;die\u0026#39;,2,35)) # ได้ 32  print(g.find(\u0026#39;die\u0026#39;,2,32)) # ได้ -1 (คือหาไม่พบ) นอกจากนี้ยังมีเมธอด index และ rindex ซึ่งก็ใช้ค้นหาเหมือนกัน แต่ความต่างคือหากค้นหาแล้วไม่เจอจะขึ้นขัดข้องแทนที่จะคืนค่า -1\nprint(g.index(\u0026#39;Eren\u0026#39;)) # ได้ ValueError: substring not found หากต้องการนับจำนวนคำที่ต้องการค้นว่ามีทั้งหมดกี่ตัวสามารถใช้เมธอด count\nprint(g.count(\u0026#39;sind\u0026#39;)) # ได้ 2 ตรวจจุดเริ่มและจุดสิ้นสุด ในการตรวจว่าข้อความขึ้นต้นและสิ้นสุดเป็นตัวที่ต้องการหรือไม่นั้น มีเมธอดเฉพาะที่สามารถใช้ได้ คือ startswith กับ endswith\nโครงสร้าง\nสายอักขระ.startswith(คำที่ค้น, จุดเริ่มค้น, จุดสิ้นสุดการค้น) สายอักขระ.endswith(คำที่ค้น, จุดเริ่มค้น, จุดสิ้นสุดการค้น) ตัวอย่าง\na = \u0026#39;verbrennungsanlage\u0026#39; print(a.startswith(\u0026#39;ver\u0026#39;)) # ได้ True  print(a.startswith(\u0026#39;ver\u0026#39;,3)) # ได้ False  print(a.startswith(\u0026#39;bren\u0026#39;,3)) # ได้ True  print(a.startswith(\u0026#39;erb\u0026#39;,1,7)) # ได้ True  print(a.endswith(\u0026#39;sanlage\u0026#39;)) # ได้ True  print(a.endswith(\u0026#39;nung\u0026#39;,7)) # ได้ False  print(a.endswith(\u0026#39;san\u0026#39;,3,14)) # ได้ True  print(a.endswith(\u0026#39;san\u0026#39;,12,14)) # ได้ False การแทนที่ สามารถค้นหาอักษรที่ต้องการแล้วเขียนทับได้โดยใช้เมธอด replace\nโครงสร้าง\nสายอักขระ.replace(ข้อความที่จะให้ถูกแทนที่,ข้อความที่จะนำไปแทน,จำนวนที่จะแทน) จำนวนที่แทนอาจไม่จำเป็นต้องใส่ก็ได้ หากไม่ใส่มีกี่ตัวก็จะถูกแทนหมด\nตัวอย่าง\nv = \u0026#39;ไก่จิกเด็กตายเด็กตายบนปากโอ่ง\u0026#39; print(v.replace(\u0026#39;เด็กตาย\u0026#39;,\u0026#39;เด็กเต้น\u0026#39;)) # ได้ ไก่จิกเด็กเต้นเด็กเต้นบนปากโอ่ง กรณีที่กำหนดจำนวนก็จะถูกแทนแค่จำนวนนั้น\nprint(v.replace(\u0026#39;เด็กตาย\u0026#39;,\u0026#39;โดนเตียง\u0026#39;,1)) # ได้ ไก่จิกโดนเตียงเด็กตายบนปากโอ่ง กรณีที่อยากลบข้อความก็ทำได้โดยปล่อยว่าง\nprint(v.replace(\u0026#39;จิกเด็กตายเด็ก\u0026#39;,\u0026#39;\u0026#39;)) # ได้ ไก่ตายบนปากโอ่ง อ้างอิง\nhttp://docs.python.jp/3/library/functions.html\nhttp://python.civic-apps.com/string-find\nhttp://python.civic-apps.com/string-split-join\nhttp://www.isl.ne.jp/pcsp/python/python19.html\n Reference : https://phyblas.hinaboshi.com/tsuchinoko11\n "
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/learning-python/12_list/",
	"title": "12. List (ลิสต์)",
	"tags": [],
	"description": "",
	"content": "ในบทนี้ คุณจะได้เรียนรู้เกี่ยวกับโครงสร้างข้อมูลแบบ List ในภาษา Python เราจะพูดถึงการสร้างและใช้งาน List ในเบื้องต้น การใช้งานเมธอดและฟังก์ชันเพื่อจัดการข้อมูลภายใน List และการใช้งานคำสั่ง For loop กับ List รวมถึงการ slicing\nList (ลิสต์) คือโครงสร้างข้อมูลชนิดหนึ่งในภาษา Python ที่ใช้เก็บข้อมูลแบบลำดับ (Sequence) โดยมี Index เป็นตัวระบุตำแหน่งในการเข้าถึงข้อมูล เราสามารถใช้ List เพื่อเก็บข้อมูลจำนวนมากและหลากหลายประเภทในเวลาเดียวกัน List เป็นประเภทข้อมูลที่ใช้อย่างหลากหลายในการเขียนโปรแกรม นอกจากนี้ ในภาษา Python ยังมี built-in function ที่สามารถทำงานกับ List และใน List ออบเจ็คเองก็มีเมธอดต่างๆ เป็นจำนวนมากที่ช่วยอำนวยความสะดวกในการเขียนโปรแกรม\nการประกาศและใช้งาน List List นั้นเป็นตัวแปรประเภทหนึ่ง การใช้งานของมันจะเหมือนกันอาเรย์ในภาษาอื่นๆ ในการประกาศ List นั้นข้อมูลของมันจะอยู่ภายในเครื่องหมาย [] และคั่นสมาชิกแต่ละตัวด้วยเครื่องหมายคอมมา , มาดูตัวอย่างการประกาศ List ในภาษา Python\nnumbers = [-1, 2, 5, 8, 10, 13] names = [\u0026#39;Mateo\u0026#39;, \u0026#39;Danny\u0026#39;, \u0026#39;James\u0026#39;, \u0026#39;Thomas\u0026#39;, \u0026#39;Luke\u0026#39;] mixed_type = [-2, 5, 84.2, \u0026#34;Mountain\u0026#34;, \u0026#34;Python\u0026#34;] ในตัวอย่าง เราได้สร้างตัวแปร List สามตัวแปร numbers เป็นตัวแปร List ที่มีสมาชิกเป็นตัวเลขจำนวนเต็ม 6 ตัว names เป็น List ของ String ที่สำหรับเก็บชื่อและมี 5 รายชื่อ และสุดท้ายตัวแปร mixed_type เป็น List ที่เก็บข้อมูลประเภทต่างๆ แบบรวมกันในตัวแปรเดียวซึ่งมีสมาชิกทั้งหมด 5 ตัว ซึ่งทั้งหมดนี้เป็นการกำหนดสมาชิกให้กับ List พร้อมกับการประกาศตัวแปร ในภาษา Python เราสามารถกำหนดค่าให้กับ List หลังจากประกาศตัวแปรแล้วได้ มาดูตัวอย่าง\nnumbers = [] numbers.append(-1) numbers.append(2) numbers.append(5) numbers.append(8) numbers.append(10) numbers.append(13) names = [\u0026#39;Mateo\u0026#39;, \u0026#39;Danny\u0026#39;] names.append(\u0026#39;James\u0026#39;) names.append(\u0026#39;Thomas\u0026#39;) names.append(\u0026#39;Luke\u0026#39;) print(numbers) print(names) print(\u0026#39;numbers count = \u0026#39;, len(numbers)) print(\u0026#39;names count = \u0026#39;, len(names)) ในตัวอย่าง เป็นการกำหนดค่าให้กับ List หลังจากที่มันถูกสร้างแล้ว เราใช้เมธอด append() เพื่อเพิ่มข้อมูลใหม่เข้าไปใน List ซึ่งข้อมูลที่เพิ่มเข้าจะอยู่ท้ายสุดและเรียง Index เพิ่มขึ้นไปเรื่อยๆ โดยเริ่มจาก 0 ในตัวแปร numbers เราได้เพิ่ม 5 จำนวนเต็มเข้าไปใน List และในตัวแปร names ในตอนแรกได้ประกาศและกำหนดสองชื่อให้กับตัวแปร และเพิ่มเข้าไปภายหลังอีก 3 ชื่อ และฟังก์ชัน len() ใช้เพื่อนับจำนวนสมาชิกภายใน List\n[-1, 2, 5, 8, 10, 13] [\u0026#39;Mateo\u0026#39;, \u0026#39;Danny\u0026#39;, \u0026#39;James\u0026#39;, \u0026#39;Thomas\u0026#39;, \u0026#39;Luke\u0026#39;] numbers count = 6 names count = 5 การเข้าถึงข้อมูลภายใน List List นั้นใช้ Index สำหรับการเข้าถึงข้อมูล โดย Index ของ List จะเป็นจำนวนเต็มที่เริ่มจาก 0 และเพิ่มขึ้นทีละ 1 ไปเรื่อยๆ ดังนั้น เราจึงสามารถเข้าถึงข้อมูลภายใน List เพื่ออ่านหรืออัพเดทค่าได้โดยตรงผ่าน Index ของมัน นี่เป็นโค้ดการเข้าถึงข้อมูลภายใน List ในภาษา Python\nnames = [\u0026#39;Mateo\u0026#39;, \u0026#39;Danny\u0026#39;, \u0026#39;James\u0026#39;, \u0026#39;Thomas\u0026#39;, \u0026#39;Luke\u0026#39;] print(\u0026#39;names[0] = \u0026#39;, names[0]) print(\u0026#39;names[3] = \u0026#39;, names[3]) print(\u0026#39;names[-1] = \u0026#39;, names[-1]) # update value names[0] = \u0026#39;Bob\u0026#39; print(\u0026#39;names[0] = \u0026#39;, names[0]) ในตัวอย่าง เรามีตัวแปร List ที่ชื่อว่า names ดังนั้น เพือเข้าถึงสมาชิกตัวแรกภายใน List ซึ่งก็คือ \u0026ldquo;Mateo\u0026rdquo; นั้นจะใช้คำสั่ง names[0] และสมาชิกที่มีค่าเป็น \u0026ldquo;Thomas\u0026rdquo; ซึ่งอยู่ตำแหน่งที่ 4 จะใช้คำสั่ง names[3] สังเกตว่า Index จะลดลงหนึ่งเพราะ Index ของ List นั้นเริ่มต้นจาก 0\nprint(\u0026#39;names[-1] = \u0026#39;, names[-1]) นอกจากนี้ เราสามารถเข้าถึงข้อมูลภายใน List โดยการใช้ Index เป็นจำนวนลบได้ โดยเริ่มจาก -1 ซึ่งเป็นสมาชิกตัวสุดท้ายของ List และ -2 สมาชิกตัวถัดมาและลดลงไปทีละ 1\nnames[0] = \u0026#39;Bob\u0026#39; print(\u0026#39;names[0] = \u0026#39;, names[0]) นี่เป็นการอัพเดทค่าของสมาชิกภายใน List ในตัวอย่างเราได้เปลี่ยนค่าของสมาชิกในตำแหน่งแรกของ List จากเดิมที่เป็น \u0026ldquo;Mateo\u0026rdquo; ให้เป็น \u0026ldquo;Bob\u0026rdquo;\nnames[0] = Mateo names[3] = Thomas names[-1] = Luke names[0] = Bob การอ่านค่าใน List ด้วยคำสัง For loop เนื่องจาก List นั้นเก็บข้อมูลเป็นแบบลำดับและใช้ Index ในการเข้าถึงข้อมูล ดังนั้น เราจึงมักจะใช้คำสั่งวนซ้ำสำหรับการเขียนโปรแกรมที่ทำงานกับ List เพราะทำให้การทำงานรวดเร็วและง่ายขึ้น เช่น การใช้คำสั่งวนซ้ำวนอ่านค่าใน List ที่มีข้อมูลเป็นจำนวนมาก เป็นต้น ต่อไปมาดูตัวอย่างการใช้งานคำสั่ง For loop กับ List ในภาษา Python\nnumbers = [10, 20, 30, 40, 50, 60, 70] sum = 0 for n in numbers: print(n, end =\u0026#39; \u0026#39;) sum += n print(\u0026#39;sum = \u0026#39;, sum) names = [\u0026#39;Mateo\u0026#39;, \u0026#39;Danny\u0026#39;, \u0026#39;James\u0026#39;, \u0026#39;Thomas\u0026#39;, \u0026#39;Luke\u0026#39;] for i in range(0, len(names)): print(names[i].upper(), end =\u0026#39; \u0026#39;) ในตัวอย่าง เป็นการวนอ่านค่าภายใน List ด้วยการใช้คำสั่ง For loop โดยเราได้แยกการทำงานออกเป็นสองลูป ในลูปแรกเป็นการใช้งานคำสั่ง For loop เพื่อวนอ่านค่าภายใน List numbers โดยตรง โปรแกรมจะวนอ่านค่าไปทีละค่าและนำค่าในแต่ละรอบที่ได้มาใส่ในตัวแปร n เราได้ทำการแสดงผลตัวเลขภายใน List และหาผลรวมของตัวเลขภายใน List โดยเก็บไว้ในตัวแปร sum\nในลูปที่สอง เป็นการใช้คำสั่ง For loop เช่นกัน แต่ในตอนนี้เราจะสร้าง Index ขึ้นมาโดยการใช้ตัวแปร i เป็นตัวรัน Index จาก 0 ถึงขนาดตัวสุดท้ายของ List ที่สร้างจากฟังก์ชัน range() และเราแสดงผลชื่อในตัวพิมพ์ใหญ่ด้วยเมธอด upper() ของ String\n10 20 30 40 50 60 70 sum = 280 MATEO DANNY JAMES THOMAS LUKE List slicing ในภาษา Python เราสามารถตัดข้อมูลจาก List หนึ่งแล้วนำไปสร้างเป็น List ใหม่ได้ โดยวิธีดังกล่าวนั้นเรียกกว่า slicing ในการตัดข้อมูลใน List นั้นจะทำในรูปแบบ [a:b] เมื่อ a เป็น Index เริ่มต้นและ b เป็น Index ก่อนสมาชิกตัวสุดท้ายที่ต้องการตัด มาดูตัวอย่างของ list slicing\nch = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;h\u0026#39;] a = ch[0:4] # a - d b = ch[4:9] # e - h c = ch[:3] # a - c d = ch[3:] # c - h e = ch[:] # copy all list, or equivalent to e = ch f = ch[0:2] + ch[6:8] # a - b and g - h print(a) print(b) print(c) print(d) print(e) print(f) ในตัวอย่าง เรามีตัวแปร ch ซึ่งมีสมาชิกเป็นตัวอักษรในภาษาอังกฤษจาก a ถึง h หลังจากนั้นเราได้ทำการ slice ข้อมูลจาก List ดังกล่าว ในตัวแปร a นั้นเป็นการตัดเอาข้อมูลจากตำแหน่งที่ 0 ถึง 3 มา ในตัวแปร b นั้นตัดเอาตำแหน่งที่ 4 ถึง 8 ถัดมาเป็นตัวแปร c d และ e เป็นการเว้นว่างตำแหน่งข้างหน้าและข้างหลัง ซึ่งถ้าตำแหน่งข้างหน้าถูกเว้นว่างไว้ เป็นการตัดเอาสมาชิกตั้งแต่ตำแหน่งเริ่มต้นของ List และถ้าตำแหน่งสิ้นสุดถูกเว้นว่างไว้ เป็นการตัดเอาจนถึงสมาชิกตัวสุดท้ายของ List และในตัวแปร f เป็นการตัดเอาสองส่วนของ List มาต่อกัน ในการนำสอง List มาต่อกันนั้นเราจะใช้ตัวดำเนินการ +\n[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;] [\u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;h\u0026#39;] [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] [\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;h\u0026#39;] [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;h\u0026#39;] [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;h\u0026#39;] การใช้งานคำสั่ง del เพื่อลบข้อมูลใน List คำสั่ง del เป็นคำสั่งที่ใช้สำหรับลบตัวแปรใดๆ ออกไปจากหน่วยความจำหรือใช้ยกเลิกตัวแปรที่เคยประกาศไปแล้ว เราสามารถใช้คำสั่ง del เพื่อลบสมาชิกภายใน List ได้เช่นเดียวกัน มาดูตัวอย่างการใช้งานคำสั่ง del ในภาษา Python\nch = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;h\u0026#39;] del ch[0] # delete a  print(ch) del ch[0] # delete b  print(ch) del ch[2:4] # delete e, f  print(ch) del ch[:] # delete all print(ch) ในตัวอย่าง เป็นการใช้งานคำสั่ง del สำหรับลบสมาชิกภายใน List ในตอนแรก เราได้ลบอักษร a ออกไปจาก List ซึ่งสมาชิกตัวแรกนั้นจะมี Index เป็น 0 ดังนั้น เมื่อการลบเสร็จสิ้น List จะทำการเลื่อนตัวอักษร b มายัง Index 0 แทน ซึ่งสิ่งนี้เป็นสภาวะการสูญเสียตำแหน่งของ List หรือ Index lose หลังจากนั้น เราได้ลบโดยการใช้วิธีการกำหนด Index แบบ slicing เราได้ทำการลบค่าจาก Index 0 ถึง 3 ซึ่งเป็นการลบตัวอักษรจาก e ถึง f และในคำสั่งสุดท้ายเป็นการลบข้อมูลภายใน List ทั้งหมด\n[\u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;h\u0026#39;] [\u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;h\u0026#39;] [\u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;h\u0026#39;] [] Warning: จากตัวอย่างข้างต้นนั้น เมื่อคุณต้องการลบข้อมูลทั้งหมดภายใน List เราจะใช้ del ch[:] เพราะว่าเป็นการลบแบบ slicing จากตำแหน่งแรกถึงตำแหน่งสุดท้ายและจะทำให้มันกลายเป็น List ว่างปล่าว เมื่อคุณใช้คำสั่ง del ch จะหมายความว่าลบตัวแปรออกไปจากหน่วยความจำแทน\nในบทนี้ คุณได้เรียนรู้เกี่ยวกับการประกาศและใช้งาน List ในภาษา Python นอกจากนี้เรายังใช้คำสัง For loop เพื่อให้ง่ายในการอ่านข้อมูลภายใน List รวมทั้งการตัดข้อมูลใน List ด้วยการ slicing และการใช้คำสั่ง del เพื่อลบข้อมูลภายใน List ออกไป ในบทต่อไป เราจะเป็นการใช้งานฟังก์ชันและเมธอดของ List\nReference :\n http://marcuscode.com/lang/python/lists  "
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/phyblas/beginer/list/",
	"title": "การจัดการกับลิสต์ (List)",
	"tags": [],
	"description": "",
	"content": "ในบทนี้จะมาขยายความถึงลิสต์ ซึ่งเป็นข้อมูลชนิดลำดับที่ใช้มากที่สุดเนื่องจากสามารถเพิ่มและแก้ไขข้อมูลได้ตลอด ต่างกับทูเพิลซึ่งแก้อะไรไม่ได้ สิ่งที่จะแนะนำในบทนี้เป็นคำสั่งที่ใช้กับลิสต์เป็นหลัก แต่บางอย่างก็สามารถนำมาใช้กับทูเพิลได้ด้วยเช่นกัน\nการกลับลำดับลิสต์ สามารถกลับลำดับของสมาชิกในลิสต์จากหัวมาท้ายได้โดยใช้ for สร้างลิสต์ใหม่ที่ดึงข้อมูลลิสต์เดิมที่ไล่ตำแหน่งจากท้ายมาหัว เช่น\na = [\u0026#39;ก\u0026#39;,\u0026#39;ข\u0026#39;,\u0026#39;ค\u0026#39;,\u0026#39;ง\u0026#39;,\u0026#39;จ\u0026#39;] b = [a[4-i] for i in range(len(a))] print(b) # [\u0026#39;จ\u0026#39;, \u0026#39;ง\u0026#39;, \u0026#39;ค\u0026#39;, \u0026#39;ข\u0026#39;, \u0026#39;ก\u0026#39;] อย่างไรก็ตาม มีวิธีที่สามารถสลับลำดับของสมาชิกได้ในทันที นั่นคือใช้เมธอด reverse\na = [\u0026#39;ก\u0026#39;,\u0026#39;ข\u0026#39;,\u0026#39;ค\u0026#39;,\u0026#39;ง\u0026#39;,\u0026#39;จ\u0026#39;] a.reverse() print(a) # ได้[\u0026#39;จ\u0026#39;, \u0026#39;ง\u0026#39;, \u0026#39;ค\u0026#39;, \u0026#39;ข\u0026#39;, \u0026#39;ก\u0026#39;] วิธีนี้ยังมีข้อดีตรงที่เป็นการเปลี่ยนสลับลำดับของสมาชิกในลิสต์เดิมไปเลยทันที ไม่ต้องสร้างลิสต์ขึ้นมาใหม่ ข้อเสียคือลิสต์แบบเดิมหายไป นอกจากนี้ยังอาจใช้ฟังก์ชัน reversed อย่างไรก็ตามฟังก์ชันนี้ไม่ได้ให้ผลเป็นลิสต์\na = [\u0026#39;ก\u0026#39;,\u0026#39;ข\u0026#39;,\u0026#39;ค\u0026#39;,\u0026#39;ง\u0026#39;,\u0026#39;จ\u0026#39;] print(reversed(a)) # ได้ \u0026lt;list_reverseiterator object at 0x10de03198\u0026gt; จะเห็นว่าผลที่ได้ไม่ใช่ลิสต์ที่ถูกสลับตำแหน่งข้อมูล แต่เป็นออบเจ็กต์อีกชนิดหนึ่งชื่อชนิด list_reverseiterator ซึ่งเป็นอิเทอเรเตอร์ (iterator) ชนิดหนึ่ง เวลาสั่งให้แสดงผลจะไม่สามารถเห็นผลได้ทันที\nอย่างไรก็ตามสามารถนำมาใช้ใน for ได้เหมือนกับลิสต์ ละจะเห็นว่าตำแหน่งถูกสลับจากหลังมาหน้าจริงๆ\nfor i in reversed([\u0026#39;ก\u0026#39;,\u0026#39;ข\u0026#39;,\u0026#39;ค\u0026#39;,\u0026#39;ง\u0026#39;,\u0026#39;จ\u0026#39;]): print(i,end=\u0026#39; \u0026#39;) # ได้ จ ง ค ข ก หรืออาจเปลี่ยนให้เป็นลิสต์ธรรมดาได้โดย\nlist(reversed((\u0026#39;ก\u0026#39;,\u0026#39;ข\u0026#39;,\u0026#39;ค\u0026#39;,\u0026#39;ง\u0026#39;,\u0026#39;จ\u0026#39;))) #ได้ [\u0026#39;จ\u0026#39;, \u0026#39;ง\u0026#39;, \u0026#39;ค\u0026#39;, \u0026#39;ข\u0026#39;, \u0026#39;ก\u0026#39;] วิธีนี้ใช้กับทูเพิลได้เช่นกัน\ntuple(reversed((\u0026#39;ก\u0026#39;,\u0026#39;ข\u0026#39;,\u0026#39;ค\u0026#39;,\u0026#39;ง\u0026#39;,\u0026#39;จ\u0026#39;))) # ได้ (\u0026#39;จ\u0026#39;, \u0026#39;ง\u0026#39;, \u0026#39;ค\u0026#39;, \u0026#39;ข\u0026#39;, \u0026#39;ก\u0026#39;) การหาค่าสูงสุดและต่ำสุดของลิสต์ หลักการหาค่าสูงสุดหรือต่ำสุดของสมาชิกที่อยู่ภายในลิสต์นั้น ให้นึกถึงนายพรานที่ไปล่าหมูป่าเพื่อทำเป็นอาหาร\nนายพรานสามารถขนหมูป่ากลับได้แค่ตัวเดียว สมมุติว่าเข้าไปถึงเขาเจอหมูป่าตัวหนึ่งก็ฆ่าแล้วขนมา แต่ต่อมาก็เจอตัวใหม่ซึ่งใหญ่กว่า จึงตัดสินใจทิ้งตัวเก่าไป พอเดินไปต่อก็ฆ่าหมูป่าได้อีกตัว แต่ตัวนี้ตัวเล็กกว่าเขาจึงเดินผ่านไปโดยเก็บตัวเดิมไว้ หลังจากนั้นก็เดินเจอหมูป่าอีกหลายตัวแล้วก็ทำเหมือนเดิมคือถ้าเจอตัวใหญ่ กว่าก็ฆ่าแล้วเปลี่ยนไปถือตัวนั้น จนสุดท้ายนายพรานก็จะได้หมูป่าตัวใหญ่ที่สุดกลับบ้าน การหาค่าสูงสุดของลิสต์ก็ใช้หลักการเดียวกันนี้ ลองสร้างลิสต์ของน้ำหนักหมูป่าทั้งหมดในป่าแล้วใช้ for เพื่อไล่หาค่าน้ำหนักของตัวที่มากที่สุดดู\nmupa = [50.9,89.3,62.7,101.2,70.4,129.3,94.9] #น้ำหนักหมูป่า 7 ตัว  mmax = mupa[0] # ตั้งค่าสูงสุดเริ่มต้น  i = 0 # ลำดับของค่าสูงสุดเริ่มต้น  for m in mupa: # ทำการวนซ้ำตามจำนวนในลิสต์  if(m\u0026gt;mmax): # ถ้ามากกว่าค่าสูงสุดเดิม  mmax = m # ให้เปลี่ยนเป็นค่านั้น  imax = i # และเปลี่ยนลำดับด้วย  i += 1 print(\u0026#39;ตัวที่ %dหนักสุด หนัก %.1fกก.\u0026#39;%(imax,mmax)) ผลลัพธ์\nตัวที่ 5 หนักสุด หนัก 129.3 กก. อย่างไรก็ตาม มีฟังก์ชันที่ใช้หาค่าสูงสุดได้ทันที นั่นคือ max\nprint(max(mupa)) # ได้ 129.3 และในทางกลับกันก็สามารถหาค่าต่ำสุดได้ด้วย โดยใช้ฟังก์ชัน min\nprint(min(mupa)) # ได้ 50.9 แต่ฟังก์ชันนี้ไม่สามารถบอกลำดับของข้อมูลที่ให้ค่าสูงสุดหรือต่ำสุดได้ ต้องใช้คู่กับฟังก์ชัน index เพื่อหาว่าตัวที่ตำแหน่งไหนมีค่าเป็นค่าสูงสุด\nprint(mupa.index(max(mupa))) # ได้ 5 หรือเขียนแบบนี้ก็ได้\nprint(max(mupa, key=mupa.index)) # ได้ 5 การใช้เมธอด index นี้เหมือนกับ index ที่ใช้กับสายอักขระซึ่งอธิบายไปในบทที่แล้ว แต่ลิสต์จะไม่มี rindex และไม่มี find กับ rfind ด้วย\nผลรวมและค่าเฉลี่ยของตัวเลขในลิสต์ หากมีลิสต์ที่ประกอบไปด้วยจำนวนตัวเลข สามารถหาค่ารวมของสมาชิกในลิสต์ทั้งหมดได้โดยใช้ for ไล่สมาชิกทีละตัวแล้วให้บวกไปเรื่อย ๆ\nx = [124.3,45.4,34.5,199.8,444.3,322.2,401.1] ruam = 0 for s in x: ruam +=s print(ruam) # ได้ 1571.6 ส่วนค่าเฉลี่ยก็แค่นำความยาวของลิสต์มาหารอีกที\nchalia = ruam/len(x) print(\u0026#39;ค่าเฉลี่ยเท่ากับ %.2f\u0026#39;%chalia) # ได้ ค่าเฉลี่ยเท่ากับ 224.51 ในภาษาไพธอนมีฟังก์ชันที่ใช้สำหรับหาค่าผลรวมของลิสต์โดยเฉพาะ คือ sum สามารถใช้เพื่อหาผลรวมและค่าเฉลี่ยได้ดังนี้\nprint(sum(x)) # ได้ 1571.6  print(sum(x)/len(x)) # ได้ 224.5142857142857 นับจำนวนสิ่งที่ต้องการในลิสต์ หากต้องการหาว่าในลิสต์นั้นมีสมาชิกที่เราต้องการค้นอยู่กี่ตัวอาจทำได้โดยลองกำหนดตัวแปรขึ้นมาตัวหนึ่งใช้เก็บค่าจำนวนที่นับโดยเริ่มจาก 0 จากนั้นใช้ for วนเพื่อตรวจว่าสมาชิกแต่ละตัวตรงกับค่าที่ต้องการหรือไม่ ถ้าตรงก็บวกเพิ่มไปเรื่อย ๆ\nตัวอย่าง หาว่ามี 2 กี่ตัวในลิสต์ w\nw = [1,2,1,2,2,2,1,2,2,1,1,1,1,2,1,1,2,2] nap = 0 for b in w: if(b==2): nap += 1 print(nap) # ได้ 9 นอกจากนี้ยังอาจทำได้ง่ายๆโดยใช้เมธอด count เช่นเดียวกับที่ใช้ในสายอักขระ\nprint(w.count(2)) # ได้ 9 การจัดเรียงลิสต์ วิธีการจัดเรียงสมาชิกในลิสต์ตามลำดับค่ามากน้อยนั้นมีอยู่หลายวิธี แต่วิธีที่เข้าใจง่ายที่สุดและนิยมสอนกันในเบื้องต้นก็คือการเรียงลำดับแบบฟอง (bubble sort) คือตรวจดูค่าแล้วสลับลำดับทีละคู่ไปเรื่อยๆ โดยไล่จากตัวแรกกับตัวที่สอง ไปตัวที่สองกับตัวที่สาม แล้วไล่ไปเรื่อยๆจนถึงตัวรองสุดท้ายกับตัวสุดท้าย จากนั้นก็วนสลับอย่างนี้ไปอีกเรื่อย ๆ จนเรียงกันหมด\nx = [35,24,30,17,15,6,8,2] for i in range(len(x)-1): # ทำซ้ำไป len(x)-1 ครั้ง  for j in range(len(x)-i-1): # ทำซ้ำโดยไล่ตั้งแต่ j เป็น 0 ไปจนถึง j เป็น len(x)-i-2  if(x[j]\u0026gt;x[j+1]): # ถ้าตัวซ้ายมากกว่าตัวขวาให้สลับ  x[j],x[j+1] = x[j+1],x[j] print(x) ผลลัพธ์\n[24, 30, 17, 15, 6, 8, 2, 35] [24, 17, 15, 6, 8, 2, 30, 35] [17, 15, 6, 8, 2, 24, 30, 35] [15, 6, 8, 2, 17, 24, 30, 35] [6, 8, 2, 15, 17, 24, 30, 35] [6, 2, 8, 15, 17, 24, 30, 35] [2, 6, 8, 15, 17, 24, 30, 35] อย่างไรก็ตามตามในทางปฏิบัติแล้วมีวิธีอื่นที่เร็วกว่า ตัวอย่างนี้แค่ยกมาเพื่อฝึกกระบวนการคิดเท่านั้น ที่จริงแล้วในไพธอนมีคำสั่งเฉพาะที่ใช้ในการทำให้สมาชิกของลิสต์เรียงกันทันทีโดยง่าย นั่นคือเมธอด sort\nx = [35,24,30,17,15,6,8,2] x.sort() print(x) # ได้ [2, 6, 8, 15, 17, 24, 30, 35] ซึ่งจะพบว่านอกจากจะเขียนง่ายกว่าแล้วยังทำงานเร็วกว่ามากอย่างเทียบไม่ติด ดังนั้นในทางปฏิบัติแล้วจึงควรใช้วิธีนี้มากกว่า หากต้องการเรียงกลับด้านก็เพิ่มคีย์เวิร์ด reverse เข้าไปเป็น reverse=True (หรือใช้ 1 แทน True ก็ได้)\nx = [35,24,30,17,15,6,8,2] x.sort(reverse=1) print(x) # ได้ [35, 30, 24, 17, 15, 8, 6, 2] นอกจากนี้ยังอาจใช้ฟังก์ชัน sorted ซึ่งจะคืนค่าลิสต์ที่เรียงแล้ว\nx = [35,24,30,17,15,6,8,2] print(sorted(x)) # ได้ [2, 6, 8, 15, 17, 24, 30, 35] อนึ่ง ฟังก์ชัน sorted ไม่ได้เป็นการแก้ไขตัวลิสต์แต่เป็นการสร้างลิสต์ใหม่โดยใช้สมาชิกของลิสต์เก่ามาจัดเรียง ดังนั้นทูเพิลก็สามารถใช้ฟังก์ชัน sorted ได้ แต่ผลที่ไดจะออกมาเป็นลิสต์ ต้องแปลงกลับเป็นทูเพิลอีกที\ny = (489,378,112,388,98,14,333) y = tuple(sorted(y)) print(y) # ได้ (14, 98, 112, 333, 378, 388, 489) การสร้างคีย์ในการเรียงขึ้นเอง ในการเรียงนั้นปกติหากเป็นตัวเลขก็จะเรียงตามค่าสูงต่ำ หากเป็นตัวอักษรก็จะเรียงตามลำดับในยูนิโค้ด แต่ก็สามารถตั้งคีย์ขึ้นมาเองเพื่อใช้เป็นดัชนี ในการค้นได้เช่นกัน โดยการเพิ่มคีย์เวิร์ด key ลงไปในฟังก์ชัน sorted ดัชนีที่ใช้อาจเป็นสายอักขระหรือลิสต์ก็ได้\nตัวอย่าง ลองทำให้อักษรเรียงตามลำดับในแป้นพิมพ์เกษมณีโดยไล่จากแถวบนไปแถวล่าง ซ้ายไปขวา\nkedma = \u0026#39;ภถคตจขชฎพฑธรณนยญบฐลฃฅฟหฆกฏดฌษสศวซงผปฉอฮทมฒฬฝ\u0026#39; a = [\u0026#39;ก\u0026#39;,\u0026#39;ข\u0026#39;,\u0026#39;ค\u0026#39;,\u0026#39;ฆ\u0026#39;,\u0026#39;ง\u0026#39;,\u0026#39;จ\u0026#39;,\u0026#39;ฉ\u0026#39;,\u0026#39;ช\u0026#39;,\u0026#39;ซ\u0026#39;] print(sorted(a,key=kedma.index)) ได้\n[\u0026#39;ค\u0026#39;, \u0026#39;จ\u0026#39;, \u0026#39;ข\u0026#39;, \u0026#39;ช\u0026#39;, \u0026#39;ก\u0026#39;, \u0026#39;ซ\u0026#39;, \u0026#39;ง\u0026#39;, \u0026#39;ฉ\u0026#39;] สรุปเนื้อหา ในบทนี้ได้พูดถึงกระบวนการจัดการกับสมาชิกภายในลิสต์แบบต่างๆทั้งแบบใช้ฟังก์ชันหรือเมธอดช่วยและแบบที่ไม่ใช้ การใช้ฟังก์ชันหรือเมธอดช่วยนั้นจะง่ายกว่า แต่เพื่อให้เข้าใจหลักการคิดและกระบวนการที่ซ่อนอยู่ภายในจึงอธิบายวิธีที่เห็นภาพชัดก่อน\nเรื่องของลิสต์นั้นยังมีรายละเอียดอีกมาก ที่แนะนำมาจนถึงตอนนี้เป็นแค่พื้นฐานส่วนหนึ่ง ที่เหลือต้องนำไปต่อยอดกันต่อไป\nอ้างอิง\nhttp://docs.python.jp/3/library/stdtypes.html\nhttp://www.tohoho-web.com/python/list.html\nhttp://minus9d.hatenablog.com/entry/2015/01/04/235442\nhttp://kaisk.hatenadiary.com/entry/2014/11/04/232558\nhttp://d.hatena.ne.jp/yumimue/20071218/1197985024\nhttps://ja.wikipedia.org/wiki/バブルソート\n Reference : https://phyblas.hinaboshi.com/tsuchinoko12\n "
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/learning-python/13_list_methods/",
	"title": "13. List Methods (ลิสต์ เมธอด)",
	"tags": [],
	"description": "",
	"content": "ในบทนี้ เราจะพูดถึงการใช้งาน List เมธอด ในภาษา Python เนื่องจาก List เป็นออบเจ็ค ดังนั้น Python จึงได้ให้เมธอดต่างๆ สำหรับทำงานพื้นฐานกับ List ที่ช่วยอำนวยความสะดวกในการทำงานเป็นอย่างมาก นอกจากนี้ เรายังจะพูดถึงการใช้งาน built-in function กับ List ถึงแม้ในภาษา Python นั้นมีเมธอดและฟังก์ชันเป็นจำนวนมาก แต่เราจะมาดูตัวอย่างการใช้งานเฉพาะที่สำคัญ\nการใช้งานเมธอดของ List ตัวอย่างแรกของการใช้เมธอดของ List นั้นจะเป็นการใช้งานเมธอดเพื่อทำงานพื้นฐานกับ List คือการเพิ่มและลบข้อมูลออกจาก List โปรแกรมของเราเป็นการใช้ List เพื่อเก็บรายชื่อ หลังจากนั้นเราใช้เมธอดต่างๆ กับเพื่อจัดการกับข้อมูลภาย List นี่เป็นโค้ดการทำงานของโปรแกรม\nnames = [\u0026#39;David\u0026#39;, \u0026#39;Johnny\u0026#39;, \u0026#39;Dennis\u0026#39;, \u0026#39;Jason\u0026#39;] # add 2 names to the end of the list names.append(\u0026#39;Andy\u0026#39;) names.append(\u0026#39;Rene\u0026#39;) print(names) # add a name at position 3 names.insert(2, \u0026#39;Mike\u0026#39;) print(names) # remove 2 specific names names.remove(\u0026#39;David\u0026#39;) names.remove(\u0026#39;Johnny\u0026#39;) print(names) # pop the last item fro the list print(\u0026#39;Popped item =\u0026#39;, names.pop()) print(names) print(\u0026#39;Popped item =\u0026#39;, names.pop()) print(names) # clear all items names.clear() print(names) ในตัวอย่าง เราได้สร้างตัวแปร List ขึ้นมาและกำหนดสมาชิกให้กับตัวแปร โดยมีสมาชิกที่เป็น String จำนวน 4 ตัว หลังจากนั้นเราใช้เมธอด append() ในการเพิ่มอีกสองชื่อเข้ามา โดยเมธอดนี้จะทำการเพิ่มข้อมูลใหม่เข้าไปยังท้ายของ List ต่อมาเราใช้เมธอด insert() เพื่อเพิ่มสมาชิกไปยังตำแหน่งที่ต้องการ เราได้เพิ่ม 'Mike' ไปยังตำแหน่งที่ 3 ของ List ทำให้ในตอนนี้ List ของเรามีสมาชิกทั้งหมด 7 ตัว\nnames.remove(\u0026#39;David\u0026#39;) names.remove(\u0026#39;Johnny\u0026#39;) หลังจากนั้นเป็นการใช้งานเมธอด remove() เพื่อนำออกข้อมูลใน List เราได้ทำการลบสองรายชื่อ คือ 'David' และ 'Johnny' ออกไปจาก List โดยเมธอดจะทำการลบข้อมูลแรกที่เจอใน List ออกไปในกรณีที่ข้อมูลนั้นมีเหมือนกันมากกว่าหนึ่งใน List แต่ในการใช้งานเมธอดคุณต้องตรวจสอบให้แน่ใจว่าข้อมูลนั้นมีอยู่จริง ไม่เช่นนั้นจะทำให้เกิดข้อผิดพลาดขึ้น\nprint(\u0026#39;Popped item =\u0026#39;, names.pop()) print(names) print(\u0026#39;Popped item =\u0026#39;, names.pop()) print(names) ต่อมาเป็นการนำข้อมูลออกจาก List ด้วยการใช้เมธอด pop() การทำงานของเมธอดนั้นจะนำข้อมูลที่อยู่ท้ายสุดของ List และส่งค่านั้นกลับมา และเนื่องจาก List มีเมธอด append() และ pop() ดังนั้น เราจึงสามารใช้ List เหมือนกับการทำงานของ Stack ได้ และเมธอด clear() นั้นสำหรับลบข้อมูลออกจาก List ทั้งหมด\n[\u0026#39;David\u0026#39;, \u0026#39;Johnny\u0026#39;, \u0026#39;Dennis\u0026#39;, \u0026#39;Jason\u0026#39;, \u0026#39;Andy\u0026#39;, \u0026#39;Rene\u0026#39;] [\u0026#39;David\u0026#39;, \u0026#39;Johnny\u0026#39;, \u0026#39;Mike\u0026#39;, \u0026#39;Dennis\u0026#39;, \u0026#39;Jason\u0026#39;, \u0026#39;Andy\u0026#39;, \u0026#39;Rene\u0026#39;] [\u0026#39;Mike\u0026#39;, \u0026#39;Dennis\u0026#39;, \u0026#39;Jason\u0026#39;, \u0026#39;Andy\u0026#39;, \u0026#39;Rene\u0026#39;] Popped item = Rene [\u0026#39;Mike\u0026#39;, \u0026#39;Dennis\u0026#39;, \u0026#39;Jason\u0026#39;, \u0026#39;Andy\u0026#39;] Popped item = Andy [\u0026#39;Mike\u0026#39;, \u0026#39;Dennis\u0026#39;, \u0026#39;Jason\u0026#39;] [] นี่เป็นผลการทำงานของโปรแกรมในการใช้งานเมธอดเพื่อเพิ่มและลบข้อมูลกับ List ในรูปแบบต่างๆ\nมาดูตัวอย่างในการใช้งาน List กับเมธอดเพิ่มเติมในภาษา Python ที่เป็นโปรแกรมในการเก็บชื่อของผลไม้ เราได้ทำการประกาศ List fruits และกำหนดสมาชิก 6 ตัวให้กับ List แต่มี 'apple' ที่มี 2 ตัวใน List นี่เป็นโค้ดการทำงานของโปรแกรม\nfruits = [\u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;peach\u0026#39;] print(fruits) print(\u0026#39;%dapples in list\u0026#39; % fruits.count(\u0026#39;apple\u0026#39;)) print(\u0026#39;%dbanana in list\u0026#39; % fruits.count(\u0026#39;banana\u0026#39;)) print(\u0026#39;Index of grape is %d\u0026#39; % fruits.index(\u0026#39;grape\u0026#39;)) fruits.sort() print(\u0026#39;Sorted\u0026#39;, fruits) fruits.reverse() print(\u0026#39;Reversed\u0026#39;, fruits) ในตัวอย่าง เรามี List ในการเก็บรายชื่อของผลไม้ เมธอด count() ใช้สำหรับนับจำนวนออบเจ็คที่ตรงกันกับที่ระบุภายใน List เราได้ทำการนับ 'apple' และ 'banana' ใน List และแสดงจำนวนที่ได้ออกทางหน้าจอ เมธอด index() นั้นใช้สำหรับหาตำแหน่ง Index ของออบเจ็คตัวแรกที่พบใน List เราได้ใช้เมธอดเพื่อหา Index ของ 'grape' และแสดงผลตำแหน่งที่ได้\nเมธอด sort() ใช้สำหรับเรียงข้อมูลภายใน List ตามตัวอักษรจากก่อนไปทีหลัง ในกรณีที่ข้อมูลใน List เป็นตัวเลขจะเป็นการเรียงจากน้อยไปหามากแทน คุณสามารถใช้ Keyword argument ที่ชื่อว่า reverse โดยกำหนดให้เป็น True หากต้องการเรียงจากมากไปหาน้อย ซึ่งโดยปกติแล้วค่านี้จะมีค่าเป็น False และเมธอด reverse() ใช้สำหรับย้อนกลับข้อมูลภายใน List จากตำแหน่งแรกไปตำแหน่งสุดท้ายและในทางกลับกัน\n[\u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;peach\u0026#39;] 2 apples in list 1 banana in list Index of grape is 3 Sorted [\u0026#39;apple\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;peach\u0026#39;] Reversed [\u0026#39;peach\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;apple\u0026#39;] นี่เป็นผลลัพธ์การทำงานของโปรแกรม\nในสองตัวอย่างก่อนหน้า เป็นการใช้งานเมธอดต่างๆ ของ List อย่างไรก็ตามยังมีเมธอดอื่นๆ อีกที่เราไม่ได้กล่าวถึง นี่เป็นรายการเมธอดทั้งหมดของ List ในภาษา Python\nUntitled\nการใช้งานฟังก์ชันกับ List ในภาษา Python นั้นมี built-in function ที่สามารถใช้งานกับโครงสร้างข้อมูลทั่วไปได้ เช่น List Tupple หรือ Dictionary ฟังก์ชันเหล่านี้อำนวยความสะดวกเป็นอย่างมาก เช่น การนับจำนวนสมาชิก การหาค่าน้อยสุดหรือค่ามากสุด เป็นต้น ต่อไปมาดูตัวอย่างการใช้งานฟังก์ชันที่สามารถใช้ได้กับ List\nnumbers = [12, 3, 1, -5, 8, 3, -2, 10] print(\u0026#39;%dnumbers in list\u0026#39; % len(numbers)) print(\u0026#39;Min number = %d\u0026#39; % min(numbers)) print(\u0026#39;Max number = %d\u0026#39; % max(numbers)) ในตัวอย่าง เป็นการใช้งานฟังก์ชันกับ List ของตัวเลข โดยฟังก์ชัน len() ที่เรารู้จักกันดีนั้นใช้สำหรับนับจำนวนของออบเจ็คภายใน List อย่างไรก็ตามฟังก์ชันนี้สามารถใช้งานได้กับข้อมูลประเภทอื่นๆ เหมือนกัน เช่น ใช้กับ Tuple Dictionary หรือการหาความยาวของ String ฟังก์ชัน min() สำหรับหาค่าที่น้อยที่สุดใน List และฟังก์ชัน max() นั้นสำหรับหาค่าที่มากที่สุด\nprint(list(range(0, 20, 2))) tuple1 = (1, 2, 3, 4, 5) print(list(tuple1)) ต่อไปเป็นการใช้งานฟังก์ชัน list() ในการแปลงข้อมูลประเภทต่างๆ ไปเป็น List ในคำสั่งแรกเป็นการแปลงข้อมูลจากออบเจ็คลำดับของตัวเลขที่สร้างจากฟังก์ชัน range() เป็น List และในคำสั่งที่สองเป็นการแปลง Tuple ให้เป็น List\n8 numbers in list Min number = -5 Max number = 12 [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] [1, 2, 3, 4, 5] นี่เป็นผลลัพธ์การทำงานของโปรแกรม ในการใช้ฟังก์ชันกับ List\nในบทนี้ เราได้ครอบคลุมการใช้งานเมธอดของ List ในภาษา Python คุณได้เห็นตัวอย่างในการใช้งานเมธอดกับ List ในการเขียนโปรแกรมแบบต่างๆ นอกจากนี้ ยังทราบถึงการใช้งาน built-in function ที่สามารถใช้งานกับ List ได้\n Reference : http://marcuscode.com\n "
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/phyblas/beginer/dictionary/",
	"title": "ดิกชันนารี (Dictionary)",
	"tags": [],
	"description": "",
	"content": "ดิกชันนารีเป็นวัตถุที่เก็บค่าข้อมูลหลายๆตัวเช่นเดียวกับลิสต์และทูเพิล แต่จะต่างกันตรงที่ต้องประกอบไปด้วย ๒ ส่วน คือ คีย์ (key) กับ ค่า (value) อยู่ด้วยกันเหมือนเป็นคู่อันดับ ลิสต์และทูเพิลจะใช้เลขดัชนีเป็นตัวชี้ถึงค่าภายในลำดับ แต่ว่าในดิกชันนารีจะใช้คีย์แทน คีย์นั้นเหมือนเป็นสิ่งที่มาใช้แทนเลขดัชนีในลิสต์หรือทูเพิล คือแทนที่จะใช้ตัวเลขเพื่อชี้สมาชิกก็เปลี่ยนมาใช้คีย์ซึ่งเป็นอะไรก็ได้ที่กำหนดขึ้นเอง\nการสร้างและเข้าถึงข้อมูลในดิกชันนารี ดิกชันนารีสามารถสร้างได้โดยใช้วงเล็บปีกกาเช่นเดียวกับเซ็ต แต่ภายในใส่สมาชิกเป็นคู่ๆโดยแต่ละคู่ใส่คีย์ทางซ้ายแล้วคั่นด้วยโคลอน : แล้วตามด้วยค่า จากนั้นก็คั่นด้วยจุลภาค , แล้วตามด้วยคู่ถัดไป\nตัวอย่าง ดิกชันนารีที่เก็บข้อมูลตึกสูงในไทย\ntueksung = {\u0026#39;มหานคร\u0026#39;: 313, \u0026#39;ใบหยก 2\u0026#39;: 304, \u0026#39;อมันตา ลุมพินี\u0026#39;: 212, \u0026#39;อื้อจือเหลียง\u0026#39;: 160, \u0026#39;จัตุรัสจามจุรี\u0026#39;: 157, \u0026#39;ใบหยก 1\u0026#39;: 151} เวลาต้องการเข้าถึงข้อมูลก็ใช้ชื่อดิกชันนารีตามด้วย [ ] ซึ่งใส่ชื่อคีย์\nprint(tueksung[\u0026#39;จัตุรัสจามจุรี\u0026#39;]) # ได้ 157  print(tueksung[\u0026#39;ใบหยก 2\u0026#39;]) # ได้ 304 ดิกชันนารีไม่สามารถใช้ตัวเลขเพื่อระบุสมาชิกโดยอาศัยลำดับได้อย่างในลิสต์ ต้องใช้คีย์ตามที่ใส่เข้าไปเท่านั้น\nprint(tueksung[1]) # ได้ KeyError: 1 ทั้งคีย์และค่าจะเป็นข้อมูลชนิดไหนก็ได้ อาจเป็นตัวเลขก็ได้ เช่น ดิกชันนารีที่เก็บชื่อของโปเกมอน\npokemon = {151: \u0026#39;mew\u0026#39;, 152: \u0026#39;chicorita\u0026#39;, 153: \u0026#39;bayleaf\u0026#39;,154: \u0026#39;meganium\u0026#39;, 155: \u0026#39;hinoarashi\u0026#39;, 156: \u0026#39;magmarashi\u0026#39;,157: \u0026#39;bakphoon\u0026#39;, 158: \u0026#39;waninoko\u0026#39;,159: \u0026#39;alligates\u0026#39;, 160: \u0026#39;ordile\u0026#39;} print(pokemon[151]) # ได้ mew กรณีที่ใช้คีย์เป็นตัวเลขจำนวนเต็มแบบนี้ดูเผินๆอาจดูคล้ายกับลิสต์หรือทูเพิล แต่ต่างกันตรงที่ตัวเลขที่ใส่ต้องเป็นเลขที่มีอยู่ในคีย์เท่านั้นและไม่จำเป็นต้องไล่จาก 0\nการซ้ำกันของคีย์และค่า ภายในดิกชันนารีหนึ่งๆ ค่าอาจจะซ้ำกันได้ แต่คีย์จะซ้ำกันไม่ได้\nkhanaen = {\u0026#39;ฟิสิกส์\u0026#39;:97,\u0026#39;ฟิสิกส์\u0026#39;:91,\u0026#39;เคมี\u0026#39;:96,\u0026#39;คณิตศาสตร์\u0026#39;:87} print(khanaen) # ได้ {\u0026#39;ฟิสิกส์\u0026#39;: 91, \u0026#39;เคมี\u0026#39;: 96, \u0026#39;คณิตศาสตร์\u0026#39;: 87} จะเห็นว่าใส่ค่าซ้ำลงไปแต่สุดท้ายก็เหลือแค่ตัวเดียว ทั้งนี้เพราะว่าคีย์เป็นสิ่งที่ต้องใช้อ้างอิงเพื่อชี้ถึงค่าในดิกชันนารี จึงไม่สามารถซ้ำกันได้ เช่นเดียวกับฟังก์ชันทางคณิตศาสตร์ที่โดเมนต้องไม่ซ้ำ ถ้าซ้ำกันละก็พอจะเรียกหาค่าก็จะเกิดความคลุมเครือไม่รู้จะเรียกตัวไหน ในขณะที่ค่านั้นต่อให้ใส่ซ้ำกันจะไม่มีปัญหาอะไร\nkhanaen = {\u0026#39;ฟิสิกส์ 1\u0026#39;:97,\u0026#39;ฟิสิกส์ 2\u0026#39;:91,\u0026#39;เคมี 1\u0026#39;:91,\u0026#39;เคมี 2\u0026#39;:97} print(khanaen) # ได้ {\u0026#39;ฟิสิกส์ 1\u0026#39;: 97, \u0026#39;ฟิสิกส์ 2\u0026#39;: 91, \u0026#39;เคมี 1\u0026#39;: 91, \u0026#39;เคมี 2\u0026#39;: 97} ในที่นี้ค่าของ \u0026ldquo;ฟิสิกส์ 1\u0026rdquo; ซ้ำกับ \u0026ldquo;เคมี 2\u0026rdquo; และ \u0026ldquo;เคมี 1\u0026rdquo; ซ้ำกับ \u0026ldquo;ฟิสิกส์ 2\u0026rdquo; จะเห็นว่าสามารถซ้ำกันได้\nkeys, values และ items รายการคีย์ทั้งหมดสามารถแสดงได้โดยเมธอด keys ตัวอย่าง ดิกชันนารีแสดงรายชื่อเมืองเอก (เรียกว่าเสิ่งฮุ่ย (shěnghuì, 省会) ในภาษาจีน) ของมณฑลในจีน\nshenghui = {\u0026#39;กวางตุ้ง\u0026#39;: \u0026#39;กว่างโจว\u0026#39;,\u0026#39;เจ้อเจียง\u0026#39;: \u0026#39;หางโจว\u0026#39;, \u0026#39;เหลียวหนิง\u0026#39;: \u0026#39;เสิ่นหยาง\u0026#39;,\u0026#39;เหอเป่ย์\u0026#39;: \u0026#39;สือเจียจวาง\u0026#39;, \u0026#39;เหอหนาน\u0026#39;: \u0026#39;เจิ้งโจว\u0026#39;,\u0026#39;ฝูเจี้ยน\u0026#39;: \u0026#39;ฝูโจว\u0026#39;, \u0026#39;ทิเบต\u0026#39;: \u0026#39;ลาซ่า\u0026#39;,\u0026#39;ซินเจียง\u0026#39;: \u0026#39;อูหลู่มู่ฉี\u0026#39;} print(shenghui.keys()) ผลที่ได้\ndict_keys([\u0026#39;กวางตุ้ง\u0026#39;, \u0026#39;เจ้อเจียง\u0026#39;, \u0026#39;เหลียวหนิง\u0026#39;, \u0026#39;เหอเป่ย์\u0026#39;, \u0026#39;เหอหนาน\u0026#39;, \u0026#39;ฝูเจี้ยน\u0026#39;, \u0026#39;ทิเบต\u0026#39;, \u0026#39;ซินเจียง\u0026#39;]) ข้อมูลที่ได้นี้เป็นชนิด dict_keys ซึ่งถือเป็นคลาสเฉพาะคลาสนึง ไม่สามารถเปลี่ยนแปลงแก้ไขค่าในนี้ได้เช่นเดียวกับทูเพิล ไม่สามารถใช้ตัวเลขชี้ถึงค่าข้างในได้ แต่สามารถใช้ in เพื่อตรวจดูสมาชิกข้างในได้ สามารถแปลงเป็นลิสต์หรือทูเพิล หรือใช้ join เพื่อเชื่อมกันได้\n\u0026#39;ไต้หวัน\u0026#39; in shenghui.keys() # ได้ False  \u0026#39;ทิเบต\u0026#39; in shenghui.keys() # ได้ True  {\u0026#39;เหอหนาน\u0026#39;,\u0026#39;เหอเป่ย์\u0026#39;}.issubset(shenghui.keys()) # ได้ True  {\u0026#39;เหอหนาน\u0026#39;,\u0026#39;เหอเป่ย์\u0026#39;,\u0026#39;หูหนาน\u0026#39;,\u0026#39;หูเป่ย์\u0026#39;}.intersection( shenghui.keys()) # ได้ {\u0026#39;เหอหนาน\u0026#39;, \u0026#39;เหอเป่ย์\u0026#39;}  print(tuple(shenghui.keys())) # ได้ (\u0026#39;กวางตุ้ง\u0026#39;, \u0026#39;เจ้อเจียง\u0026#39;, \u0026#39;เหลียวหนิง\u0026#39;, \u0026#39;เหอเป่ย์\u0026#39;, \u0026#39;เหอหนาน\u0026#39;, \u0026#39;ฝูเจี้ยน\u0026#39;, \u0026#39;ทิเบต\u0026#39;, \u0026#39;ซินเจียง\u0026#39;)  print(\u0026#39;|\u0026#39;.join(shenghui.keys())) # ได้ กวางตุ้ง|เจ้อเจียง|เหลียวหนิง|เหอเป่ย์|เหอหนาน|ฝูเจี้ยน|ทิเบต|ซินเจียง ส่วนค่าในดิกชันนารีสามารถแสดงทั้งหมดโดยเมธอด values\nprint(shenghui.values()) จะได้ออกมาเป็นข้อมูลชนิด dict_values ซึ่งก็มีคุณสมบัติเหมือนกับ dict_keys\ndict_values([\u0026#39;กว่างโจว\u0026#39;, \u0026#39;หางโจว\u0026#39;, \u0026#39;เสิ่นหยาง\u0026#39;, \u0026#39;สือเจียจวาง\u0026#39;, \u0026#39;เจิ้งโจว\u0026#39;, \u0026#39;ฝูโจว\u0026#39;, \u0026#39;ลาซ่า\u0026#39;, \u0026#39;อูหลู่มู่ฉี\u0026#39;]) และถ้าต้องการให้แสดงคีย์กับค่าคู่กันในรูปของทูเพิลให้ใช้เมธอด items\nprint(shenghui.items()) จะได้ข้อมูลชนิด dict_items\ndict_items([(\u0026#39;กวางตุ้ง\u0026#39;, \u0026#39;กว่างโจว\u0026#39;), (\u0026#39;เจ้อเจียง\u0026#39;, \u0026#39;หางโจว\u0026#39;), (\u0026#39;เหลียวหนิง\u0026#39;, \u0026#39;เสิ่นหยาง\u0026#39;), (\u0026#39;เหอเป่ย์\u0026#39;, \u0026#39;สือเจียจวาง\u0026#39;), (\u0026#39;เหอหนาน\u0026#39;, \u0026#39;เจิ้งโจว\u0026#39;), (\u0026#39;ฝูเจี้ยน\u0026#39;, \u0026#39;ฝูโจว\u0026#39;), (\u0026#39;ทิเบต\u0026#39;, \u0026#39;ลาซ่า\u0026#39;), (\u0026#39;ซินเจียง\u0026#39;, \u0026#39;อูหลู่มู่ฉี\u0026#39;)]) ***ในไพธอน 2 เมธอด keys, values และ items จะได้ผลเป็นลิสต์ แทนที่จะได้เป็นคลาสเฉพาะ รายละเอียด\nการใช้ for คู่กับดิกชันนารี เมื่อใช้ for กับดิกชันนารี ตัวแปรจะไล่ตามคีย์ ไม่ใช่ค่า\nfor s in shenghui: print(s,end=\u0026#39; \u0026#39;) # ได้ กวางตุ้ง เจ้อเจียง เหลียวหนิง เหอเป่ย์ เหอหนาน ฝูเจี้ยน ทิเบต ซินเจียง แต่ก็สามารถเข้าถึงค่าได้ทันทีโดยใส่คีย์ใน [ ]\nfor s in shenghui: print(shenghui[s],end=\u0026#39; \u0026#39;) # ได้ กว่างโจว หางโจว เสิ่นหยาง สือเจียจวาง เจิ้งโจว ฝูโจว ลาซ่า อูหลู่มู่ฉี หรือใช้เมธอด values ก็สามารถไล่ตามค่าได้\nfor v in shenghui.values(): print(v,end=\u0026#39; \u0026#39;) # ได้ กว่างโจว หางโจว เสิ่นหยาง สือเจียจวาง เจิ้งโจว ฝูโจว ลาซ่า อูหลู่มู่ฉี  หากจะใช้ทั้งคีย์และค่าก็อาจใช้เมธอด items\nfor v in shenghui.items(): print(v[0],v[1],sep=\u0026#39;\u0026gt;\u0026#39;,end=\u0026#39; \u0026#39;) # กวางตุ้ง\u0026gt;กว่างโจว เจ้อเจียง\u0026gt;หางโจว เหลียวหนิง\u0026gt;เสิ่นหยาง เหอเป่ย์\u0026gt;สือเจียจวาง เหอหนาน\u0026gt;เจิ้งโจว ฝูเจี้ยน\u0026gt;ฝูโจว ทิเบต\u0026gt;ลาซ่า ซินเจียง\u0026gt;อูหลู่มู่ฉี การเพิ่มข้อมูลและแก้ไขดิกชันนารี การเพิ่มเติมข้อมูลสามารถทำได้โดยใช้ = เพื่อป้อนค่าใหม่ลงไปได้เลย ตัวอย่าง พื้นที่ของจังหวัดในไทย\nphuenthi = {\u0026#39;นครราชสีมา\u0026#39;: 20494, \u0026#39;เชียงใหม่\u0026#39;: 20107, \u0026#39;กาญจนบุรี\u0026#39;: 19483, \u0026#39;ตาก\u0026#39;: 16407, \u0026#39;อุบลราชธานี\u0026#39;: 15774, \u0026#39;สุราษฎร์ธานี\u0026#39;: 12891} phuenthi[\u0026#39;ชัยภูมิ\u0026#39;] = 12778 phuenthi[\u0026#39;แม่ฮ่องสอน\u0026#39;] = 12681 print(phuenthi) # ได้ {\u0026#39;นครราชสีมา\u0026#39;: 20494, \u0026#39;เชียงใหม่\u0026#39;: 20107, \u0026#39;กาญจนบุรี\u0026#39;: 19483, \u0026#39;ตาก\u0026#39;: 16407, \u0026#39;อุบลราชธานี\u0026#39;: 15774, \u0026#39;สุราษฎร์ธานี\u0026#39;: 12891, \u0026#39;ชัยภูมิ\u0026#39;: 12778, \u0026#39;แม่ฮ่องสอน\u0026#39;: 12681} หรืออาจใช้เมธอด update เพื่อรับเอาข้อมูลจากดิกชันนารีอื่นมาก็ได้\nphuenthi.update({\u0026#39;เพชรบูรณ์\u0026#39;: 12668, \u0026#39;ลำปาง\u0026#39;: 12534}) print(phuenthi) # ได้ {\u0026#39;นครราชสีมา\u0026#39;: 20494, \u0026#39;เชียงใหม่\u0026#39;: 20107, \u0026#39;กาญจนบุรี\u0026#39;: 19483, \u0026#39;ตาก\u0026#39;: 16407, \u0026#39;อุบลราชธานี\u0026#39;: 15774, \u0026#39;สุราษฎร์ธานี\u0026#39;: 12891, \u0026#39;ชัยภูมิ\u0026#39;: 12778, \u0026#39;แม่ฮ่องสอน\u0026#39;: 12681, \u0026#39;เพชรบูรณ์\u0026#39;: 12668, \u0026#39;ลำปาง\u0026#39;: 12534} ในการใช้ = นั้นจะเป็นการเพิ่มข้อมูลก็ต่อเมื่อคีย์ที่ใส่ไปนั้นไม่มีอยู่เดิม แต่หากคีย์ที่ใส่ไปนั้นมีอยู่ก่อนแล้วจะเป็นการแก้ค่าเขียนทับลงไปใหม่แทน ตัวอย่างการประยุกต์ใช้ ลองเขียนโปรแกรมสำหรับนับจำนวนตัวอักษรแต่ละตัวที่มีอยู่ในสายอักขระ\nr = \u0026#34;Si schiudono i boccioli color di rosa. L\u0026#39;ostinato inverno ha annunciato la propria fine.\u0026#34; # สายอักขระที่ต้องการวิเคราะห์  nap = {} # สร้างดิกชันนารีสำหรับเก็บค่าจำนวนของแต่ละตัวอักษร  for s in r.lower(): #เปลี่ยนให้เป็นตัวพิมพ์เล็กเพื่อจะนับรวมพิมพ์ใหญ่พิมพ์เล็กด้วยกัน  if(s\u0026lt;\u0026#39;a\u0026#39; or s\u0026gt;\u0026#39;z\u0026#39;): continue # เอาเฉพาะที่เป็นอักษรโรมัน a ถึง z ถ้าเจอสัญลักษณ์หรือช่องว่างให้ข้าม  if(s not in nap): # ถ้ายังไม่มีอยู่ในดิกชันนารี ให้ป้อนค่าใหม่โดยเริ่มนับ 1  nap[s] = 1 else: # ถ้ามีอยู่ในดิกชันนารีแล้ว ให้แก้ค่าโดยบวกเพิ่มอีก 1  nap[s] += 1 print(nap) (ที่มามาจากเนื้อเพลง)\nผลที่ได้\n{\u0026#39;s\u0026#39;: 4, \u0026#39;i\u0026#39;: 11, \u0026#39;c\u0026#39;: 5, \u0026#39;h\u0026#39;: 2, \u0026#39;u\u0026#39;: 2, \u0026#39;d\u0026#39;: 2, \u0026#39;o\u0026#39;: 12, \u0026#39;n\u0026#39;: 8, \u0026#39;b\u0026#39;: 1, \u0026#39;l\u0026#39;: 4, \u0026#39;r\u0026#39;: 5, \u0026#39;a\u0026#39;: 7, \u0026#39;t\u0026#39;: 3, \u0026#39;v\u0026#39;: 1, \u0026#39;e\u0026#39;: 2, \u0026#39;p\u0026#39;: 2, \u0026#39;f\u0026#39;: 1} หากต้องการให้แสดงผลโดยเรียงตามลำดับอักษรก็ใช้ sorted\nfor q in sorted(nap): print(\u0026#39;%s: %d\u0026#39;%(q,nap[q])) หรือถ้าจะให้เรียงตามลำดับที่ปรากฏก็\nfor q in sorted(nap, key=r.lower().index): print(\u0026#39;%s: %d\u0026#39;%(q,nap[q])) การใช้ for สร้างดิกชันนารี เช่นเดียวกับลิสต์ ดิกชันนารีก็สามารถสร้างขึ้นจาก for ได้ ตัวอย่าง ลองใช้ดิกชันนารีเพื่อสร้างฟังก์ชันทางคณิตศาสตร์ขึ้นมา\nf = {x:3*x+2 for x in range(100)} # สร้างฟังก์ชัน 3x+2 ที่มีโดเมนเป็นจำนวนเต็ม 0 ถึง 99  print(\u0026#39;f(3)=%d\u0026#39;%f[3]) # ได้ f(3)=11  print(\u0026#39;f(23)=%d\u0026#39;%f[23]) # ได้ f(23)=71  print(\u0026#39;f(99)=%d\u0026#39;%f[99]) # ได้ f(99)=299 ซึ่งการเขียนแบบนี้จะมีค่าเท่ากับการใช้ for เพื่อวนเพิ่มค่าไปทีละค่า\nf = {} # สร้างดิกชันนารีเปล่าขึ้นมาก่อน  for x in range(100): f[x] = 3*x+2 # ใส่เพิ่มไปทีละค่า การลบข้อมูลในดิกชันนารี สามารถลบทีละตัวได้โดยใช้เมธอด pop แล้วระบุคีย์ที่ต้องการลบ ตัวอย่าง ดิกชันนารีที่เก็บรหัสนักศึกษาและคะแนนวิชาภาษาไพธอนเบื้องต้น 1\npython1 = {5966208114: 54, 5966100309: 59, 5966117558: 49, 5966209223: 62, 5966195674: 48, 5966119902: 43} สมมุติว่ามีนักศึกษาถอนวิชานี้ไปคนนึงเลยต้องลบข้อมูลออก\npython1.pop(5966119902) print(python1) # ได้ {5966208114: 54, 5966100309: 59, 5966117558: 49, 5966209223: 62, 5966195674: 48} หรืออาจลบโดยใช้คำสั่ง del ก็ได้\ndel ชื่อดิกชันนารี[คีย์ที่ต้องการลบ] เช่น สมมุติว่านักศึกษาอีกคนก็ถอนวิชานี้\ndel python1[5966195674] print(python1) # ได้ {5966208114: 54, 5966100309: 59, 5966117558: 49, 5966209223: 62} หากต้องการลบทั้งหมดให้ใช้เมธอด clear สมมุติว่านักศึกษาคนอื่นๆก็พากันถอนวิชานี้ออกหมด\npython1.clear() print(python1) # ได้ {} ถ้าจะลบทั้งดิกชันนารีออกก็ใช้คำสั่ง del ตามด้วยชื่อดิกชันนารีโดยไม่ต้องใส่คีย์ สมมุติว่าพอคนถอนไปหมด อาจารย์ก็ลบข้อมูลของวิชานี้ทิ้งเสียเลย\ndel python1 print(python1) # NameError: name \u0026#39;python1\u0026#39; is not defined คีย์หรือค่ามากกว่าหนึ่งตัว บางครั้งค่าที่ต้องการอาจไม่ได้มีแค่ค่าเดียวแต่ต้องการเก็บสองค่าขึ้นไป กรณีแบบนี้สามารถใช้ค่าเป็นลิสต์หรือทูเพิลได้ ตัวอย่างเช่น บันทึกการเดินหมากในเกมโกะซึ่งตารางมีขนาด 19×19 แต่ละช่องแทนด้วยพิกัดในแกน x และ y\ngoban = {} # สร้างดิกเปล่า แทนตารางโกะเปล่า  goban[\u0026#39;ดำ1\u0026#39;] = [16,4] # ฝ่ายดำลงหมากตาที่ 1  goban[\u0026#39;ขาว1\u0026#39;] = [4,4] goban[\u0026#39;ดำ2\u0026#39;] = [16,16] goban[\u0026#39;ขาว2\u0026#39;] = [4,17] goban[\u0026#39;ดำ3\u0026#39;] = [3,15] print(goban) ผลหลังเดินไป ๕ ตา\n{\u0026#39;ดำ1\u0026#39;: [16, 4], \u0026#39;ขาว1\u0026#39;: [4, 4], \u0026#39;ดำ2\u0026#39;: [16, 16], \u0026#39;ขาว2\u0026#39;: [4, 17], \u0026#39;ดำ3\u0026#39;: [3, 15]} ที่มาของหมากกระดานนี้ ศึก Google AlphaGo ปะทะ ฝานฮุย (樊麾)\nhttps://www.youtube.com/watch?v=d9bXaLUPe9I\nกรณีที่ต้องการคีย์สองตัวขึ้นไปก็สามารถทำได้เช่นกัน เพียงแต่คีย์ไม่สามารถใช้ลิสต์ได้ ต้องใช้ทูเพิลเท่านั้น เช่น ตัวอย่างที่แล้ว คราวนี้ใช้ตำแหน่งบนตารางเป็นคีย์\ngoban = {} # สร้างดิกเปล่า แทนตารางโกะเปล่า  goban[(16,4)] = \u0026#39;ดำ1\u0026#39; # ฝ่ายดำลงหมากตาที่ 1  goban[(4,4)] = \u0026#39;ขาว1\u0026#39; goban[(16,16)] = \u0026#39;ดำ2\u0026#39; goban[(4,17)] = \u0026#39;ขาว2\u0026#39; goban[(3,15)] = \u0026#39;ดำ3\u0026#39; print(goban) ผลหลังเดินไป ๕ ตา\n{(16, 4): \u0026#39;ดำ1\u0026#39;, (4, 4): \u0026#39;ขาว1\u0026#39;, (16, 16): \u0026#39;ดำ2\u0026#39;, (4, 17): \u0026#39;ขาว2\u0026#39;, (3, 15): \u0026#39;ดำ3\u0026#39;} กรณีนี้จะสะดวกเวลาที่จะค้นว่าตำแหน่งไหนมีการลงหมากไปหรือยังและเป็นหมากอะไรที่ลงไว้ เช่น\nx,y = int(input()),int(input()) # ป้อนค่าตำแหน่ง  if((x,y) in goban.keys()): print(goban[(x,y)]) # ถ้ามีหมากอยู่ก็จะบอกว่าเป็นหมากอะไร  else: print(\u0026#39;ว่างเปล่า\u0026#39;) # ถ้าไม่มีก็จะบอกว่าว่างเปล่า ดิกชันนารีซ้อนดิกชันนารี ค่าภายในดิกชันนารีนอกจากจะใช้ทูเพิลหรือลิสต์ได้แล้วก็ยังสามารถใช้เป็นดิกชัน นารีย่อยข้างในได้อีกด้วย พอซ้อนกันหลายชั้นพอเรียกใช้ก็ต้องใส่ [ ] ซึ่งมีคีย์ใส่อยู่ซ้อนกัน\nตัวอย่าง ลองสร้างดิกชันนารีเก็บข้อมูลของโปเกมอนจำนวน ๔ ตัว แต่ละตัวใช้ชื่อเป็นคีย์ พอค้นแล้วจะได้ค่าซึ่งเป็นดิกชันนารีที่ประกอบด้วย หมายเลข, ส่วนสูง, น้ำหนัก, และ ชนิด\nkhomun = {\u0026#39;ฟุชิงิดาเนะ\u0026#39;: {\u0026#39;หมายเลข\u0026#39;: \u0026#39;001\u0026#39;,\u0026#39;ส่วนสูง\u0026#39;: 0.7,\u0026#39;น้ำหนัก\u0026#39;: 6.9,\u0026#39;ชนิด\u0026#39;:[\u0026#39;พืช\u0026#39;,\u0026#39;พิษ\u0026#39;]}, \u0026#39;ฮิโตคาเงะ\u0026#39;: {\u0026#39;หมายเลข\u0026#39;: \u0026#39;004\u0026#39;,\u0026#39;ส่วนสูง\u0026#39;: 0.6,\u0026#39;น้ำหนัก\u0026#39;: 8.5,\u0026#39;ชนิด\u0026#39;:[\u0026#39;ไฟ\u0026#39;]}, \u0026#39;เซนิงาเมะ\u0026#39;: {\u0026#39;หมายเลข\u0026#39;: \u0026#39;007\u0026#39;,\u0026#39;ส่วนสูง\u0026#39;: 0.5,\u0026#39;น้ำหนัก\u0026#39;: 9.0,\u0026#39;ชนิด\u0026#39;:[\u0026#39;น้ำ\u0026#39;]}, \u0026#39;พีคาชู\u0026#39;: {\u0026#39;หมายเลข\u0026#39;: \u0026#39;025\u0026#39;,\u0026#39;ส่วนสูง\u0026#39;: 0.4,\u0026#39;น้ำหนัก\u0026#39;: 6.0,\u0026#39;ชนิด\u0026#39;:[\u0026#39;ไฟฟ้า\u0026#39;]}} เวลาเข้าถึงค่าภายในก็ เช่น\nprint(khomun[\u0026#39;พีคาชู\u0026#39;][\u0026#39;น้ำหนัก\u0026#39;]) # ได้ 6.0  print(khomun[\u0026#39;ฟุชิงิดาเนะ\u0026#39;][\u0026#39;ชนิด\u0026#39;]) # ได้ [\u0026#39;พืช\u0026#39;, \u0026#39;พิษ\u0026#39;]  print(khomun[\u0026#39;ฮิโตคาเงะ\u0026#39;][\u0026#39;หมายเลข\u0026#39;]) # ได้ 004 สามารถใช้ for เพื่อแสดงค่าทั้งหมด\nfor pk in sorted(khomun): print(\u0026#39;====\u0026#39;+pk+\u0026#39;====\u0026#39;) # แสดงชื่อ  for s in khomun[pk]: if(s!=\u0026#39;ชนิด\u0026#39;): print(s+\u0026#39;: %s\u0026#39;%khomun[pk][s]) # แสดงหมายเลข, น้ำหนัก, ส่วนสูง  else: print(s+\u0026#39;: \u0026#39;+\u0026#39; + \u0026#39;.join(khomun[pk][s])) # แสดงชนิด ผลลัพธ์\n====พีคาชู==== หมายเลข: 025 ส่วนสูง: 0.4 น้ำหนัก: 6.0 ชนิด: ไฟฟ้า ====ฟุชิงิดาเนะ==== หมายเลข: 001 ส่วนสูง: 0.7 น้ำหนัก: 6.9 ชนิด: พืช + พิษ ====ฮิโตคาเงะ==== หมายเลข: 004 ส่วนสูง: 0.6 น้ำหนัก: 8.5 ชนิด: ไฟ ====เซนิงาเมะ==== หมายเลข: 007 ส่วนสูง: 0.5 น้ำหนัก: 9.0 ชนิด: น้ำ สรุปเนื้อหา ดิกชันนารีเป็นข้อมูลอีกประเภทหนึ่งที่สามารถนำมาประยุกต์ใช้งานได้มากเช่น เดียวกับลิสต์, ทูเพิล และเซ็ต หากแยกใช้ข้อมูลแต่ละอย่างตามความเหมาะสมของงานแล้วก็จะสามารถทำงานอะไร ต่างๆได้อย่างมีประสิทธิภาพ\nอ้างอิง http://www.python-izm.com/contents/basis/dict.shtml\nhttp://www.pythonweb.jp/tutorial/dictionary\nhttp://www.tohoho-web.com/python/list.html\n Reference : https://phyblas.hinaboshi.com/tsuchinoko14\n "
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/learning-python/15_dictionary/",
	"title": "15. Dictionary",
	"tags": [],
	"description": "",
	"content": "ในบทนี้ คุณจะได้เรียนรู้เกี่ยวกับโครงสร้างข้อมูล Dictionary ในภาษา Python เราจะแนะนำให้คุณรู้จักกับ Dictionary คืออะไร และการประกาศและใช้งานสำหรับเก็บข้อมูลในการเขียนโปรแกรม นอกจากนี้ เรายังจะพูดถึงการใช้งานเมธอดและ built-in functions ของ Dictionary และตัวอย่างการใช้งานกับการเขียนโปรแกรมใบรูปแบบต่างๆ ในภาษา Python\nDictionary คือประเภทข้อมูลที่เก็บข้อมูลในรูปแบบคู่ของ Key และ Value โดยที่ Key ใช้สำหรับเป็น Index ในการเข้าถึงข้อมูลและ Value เป็นค่าข้อมูลที่สอดคล้องกับ Key ของมัน การเข้าถึงข้อมูลใน Dictionary นั้นรวดเร็วเพราะว่าข้อมูลได้ถูกทำ Index ไว้อัตโนมัติโดยใช้ Key นอกจากนี้ Dictionary ยังมีเมธอดและฟังก์ชันอำนวยความสะดวกสำหรับการทำงานทั่วไป\nการประกาศ Dictionary ในภาษา Python ในการใช้งาน Dictionary เรามักจะใช้เก็บข้อมูลที่สามารถใช้บางอย่างที่สามารถจำแนกข้อมูลออกจากกันได้ โดยกำหนดให้สิ่งนั้นเป็น Key ในการประกาศ Dictionary สมาชิกของมันจะอยู่ภายในวงเล็บปีกกา {} มาดูตัวอย่างในการประกาศ Dictionary ในภาษา Python\nscores = {\u0026#39;james\u0026#39;: 1828, \u0026#39;thomas\u0026#39;: 3628, \u0026#39;danny\u0026#39;: 9310} scores[\u0026#39;bobby\u0026#39;] = 4401 numbers = {1: \u0026#39;One\u0026#39;, 2: \u0026#39;Two\u0026#39;, 3: \u0026#39;Three\u0026#39;} print(scores) print(numbers) ในตัวอย่าง เราได้ประกาศตัวแปร Dictionary ที่มีชื่อว่า scores สำหรับเก็บคะแนนของแต่ละคนโดยใช้ชื่อเป็น Key และค่าของมันก็คือคะแนน สมาชิกของ Dictionary แต่ละตัวจะถูกกำหนดในรูปแบบ key: value และคั่นสมาชิกแต่ละตัวด้วยเครื่องหมายคอมมา เราได้กำหนดค่าเริ่มต้นสามค่าให้กับ Dictionary และสามารถกำหนดค่าให้กับ Dictionary ในรูปแบบ scores['bobby'] ได้หลังจากที่ตัวแปรถูกสร้างแล้ว สังเกตว่าเราสามารถใช้ Key เป็น String หรือประเภทข้อมูลอื่นๆ ได้ ต่อมาตัวแปร numbers เป็น Dictionary ที่มี Key เป็นตัวเลข\n{\u0026#39;james\u0026#39;: 1828, \u0026#39;thomas\u0026#39;: 3628, \u0026#39;danny\u0026#39;: 9310, \u0026#39;bobby\u0026#39;: 4401} {1: \u0026#39;One\u0026#39;, 2: \u0026#39;Two\u0026#39;, 3: \u0026#39;Three\u0026#39;} นี่เป็นผลลัพธ์ของโปรแกรมในการแสดงผลข้อมูลภายในตัวแปร Dictionary ทั้งสองที่เราได้สร้างขึ้น\nการเข้าถึงข้อมูลภายใน Dictionary หลังจากที่เราได้ประกาศ Dictionary ไปแล้ว ต่อไปจะการเข้าถึงข้อมูลเพื่ออ่านและอัพเดทข้อมูลโดยผ่านทาง Key ของมัน มาดูตัวอย่างการเข้าถึงข้อมูลใน Dictionary\nscores = {\u0026#39;james\u0026#39;: 1828, \u0026#39;thomas\u0026#39;: 3628, \u0026#39;danny\u0026#39;: 9310, \u0026#39;bobby\u0026#39;: 4401} # display data print(\u0026#39;james =\u0026gt;\u0026#39;, scores[\u0026#39;james\u0026#39;]) print(\u0026#39;thomas =\u0026gt;\u0026#39;, scores[\u0026#39;thomas\u0026#39;]) print(\u0026#39;danny =\u0026gt;\u0026#39;, scores[\u0026#39;danny\u0026#39;]) print(\u0026#39;bobby =\u0026gt;\u0026#39;, scores[\u0026#39;bobby\u0026#39;]) # update data scores[\u0026#39;james\u0026#39;] = scores[\u0026#39;james\u0026#39;] + 1000 scores[\u0026#39;thomas\u0026#39;] = 100 print(\u0026#39;james =\u0026gt;\u0026#39;, scores[\u0026#39;james\u0026#39;]) print(\u0026#39;thomas =\u0026gt;\u0026#39;, scores[\u0026#39;thomas\u0026#39;]) ในตัวอย่าง เรามีตัวแปร scores สำหรับเก็บคะแนนของผู้เล่นโดยชื่อเป็น Key ของ Dictionary ในการเข้าถึงข้อมูลนั้นจะใช้ Key ของมัน ในส่วนแรกเป็นการเข้าถึงข้อมูลภายใน Dictionary เพื่อแสดงผลคะแนนของแต่ละ Key ออกมาทางหน้าจอ ต่อมาเป็นการอัพเดทข้อมูลใน Dictionary โดยเราได้เพิ่มค่าให้กับ Key 'james' ขึ้นไปอีก 1000 และกำหนดค่าให้กับ Key 'thomas' เป็น 100 และแสดงผลอีกครั้ง\njames =\u0026gt; 1828 thomas =\u0026gt; 3628 danny =\u0026gt; 9310 bobby =\u0026gt; 4401 james =\u0026gt; 2828 thomas =\u0026gt; 100 นี่เป็นผลลัพธ์การทำงานของโปรแกรม ในการเข้าถึงข้อมูลภายใน Dictionary เพื่ออ่านค่าและอัพเดทข้อมูล\nในการเข้าถึงข้อมูลภายใน Dictionary นั้น คุณต้องตรวจสอบให้แน่ใจว่า Key นั้นมีอยู่จริง ไม่เช่นนั้นโปรแกรมจะเกิดข้อผิดพลาดขึ้น ยกตัวอย่างเช่น\nscores = {\u0026#39;james\u0026#39;: 1828, \u0026#39;thomas\u0026#39;: 3628, \u0026#39;danny\u0026#39;: 9310, \u0026#39;bobby\u0026#39;: 4401} print(scores[\u0026#39;smith\u0026#39;]) # Error # check if key smith exist if \u0026#39;smith\u0026#39; in scores.keys(): print(scores[\u0026#39;smith\u0026#39;]) ในตัวอย่างข้างบน โปรแกรมจะเกิดความผิดพลาดขึ้นเพราะเราได้เข้าถึง Key 'smith' ซึ่งไม่มีอยู่ใน scores อย่าไรก็ตาม เราสามารถตรวจว่า Key มีอยู่หรือไม่ได้โดยการใช้คำสั่ง in เพื่อตรวจสอบจาก Key ในเมธอด keys() ของ Dictionary\nการอ่านค่าใน Dictionary ด้วยคำสั่ง For loop คำสั่ง For loop นั้นเป็นคำสั่งที่ยืดหยุ่นและสามารถใช้งานได้อย่างหลากหลาย ในการอ่านค่าใน Dictionary นั้นเราสามารถใช้ For loop เพื่อวนอ่านค่าทั้ง Key และ Values ใน Dictionary ได้ มาดูตัวอย่างของโปรแกรม\ncountries = {\u0026#39;de\u0026#39;: \u0026#39;Germany\u0026#39;, \u0026#39;ua\u0026#39;: \u0026#39;Ukraine\u0026#39;, \u0026#39;th\u0026#39;: \u0026#39;Thailand\u0026#39;, \u0026#39;nl\u0026#39;: \u0026#39;Netherlands\u0026#39;} for k, v in countries.items(): print(k, v) # iterate through keys print(\u0026#39;Key:\u0026#39;, end = \u0026#39; \u0026#39;) for k in countries.keys(): print(k, end = \u0026#39; \u0026#39;) # iterate through values print(\u0026#39;\\\\nValue:\u0026#39;, end = \u0026#39; \u0026#39;) for v in countries.values(): print(v, end = \u0026#39; \u0026#39;) ในตัวอย่าง เป็นการใช้งานคำสั่ง For loop วนอ่านค่าใน Dictionary ซึ่งมี 3 loop ด้วยกัน ในลูปแรกเป็นการอ่านค่าแบบ Key และ Value ในแต่ละรอบของการทำงานเราเอาข้อมูลใน Dictionary ด้วยเมธอด items() ซึ่งจะส่งค่ากลับเป็น Key และ Value กับมาและโหลดใส่ในตัวแปร k และ v ตามลำดับ\nในลูปที่สอง เป็นการวนอ่าน Key ทั้งหมดภายใน Dictionary โดยเมธอด keys() จะส่งค่ากลับเป็น List ของ Key ทั้งหมดและโหลดใส่ในตัวแปร k แต่ละรอบของลูป และในลูปสุดท้ายนั้นเป็นการอ่าน Value ทั้งหมด และเมธอด values() เพื่อรับค่าของ Value ทั้งหมดมาและใส่ในตัวแปร v ในแต่ละรอบของลูป\nde Germany ua Ukraine th Thailand nl Netherlands Key: de ua th nl Value: Germany Ukraine Thailand Netherlands นี่เป็นผลลัพธ์การทำงานของโปรแกรม ในการใช้คำสั่ง For loop เพื่ออ่านข้อมูลใน Dictionary ในภาษา Python\nPython Dictionary methods เช่นเดียวกับข้อมูลประเภทอื่นๆ Dictionary มีเมธอดที่ให้คุณสามารถทำงานกับมันได้ง่ายขึ้น โดยส่วนมากแล้วมักจะเป็นเมธอดในการอัพเดทและรับค่าข้อมูลภายใน Dictionary ต่อไปมาดูตัวอย่างการใช้งานเมธอดของ Dictionary ในภาษา Python\ncountries = {\u0026#39;de\u0026#39;: \u0026#39;Germany\u0026#39;, \u0026#39;ua\u0026#39;: \u0026#39;Ukraine\u0026#39;, \u0026#39;th\u0026#39;: \u0026#39;Thailand\u0026#39;, \u0026#39;nl\u0026#39;: \u0026#39;Netherlands\u0026#39;} print(countries.keys()) print(countries.values()) print(countries.get(\u0026#39;de\u0026#39;)) # equal to countries[\u0026#39;de\u0026#39;] countries.setdefault(\u0026#39;tr\u0026#39;, \u0026#39;Turkey\u0026#39;) print(countries.popitem()) print(countries.popitem()) print(countries.items()) ในตัวอย่าง เป็นโปรแกรมในการใช้งานเมธอดของ Dictionary ตัวแปรของเรา countries มาจากตัวอย่างก่อนหน้าที่มี Key เป็นชื่อย่อของประเทศและ Value เป็นชื่อเต็มของประเทศ เมธอด keys() ส่งค่ากลับเป็น List ของ Key ทั้งหมดภายใน Dictionary และเมธอด values() นั้นจะส่งเป็น List ของ Value\nหลังจากนั้นเป็นการเข้าถึงข้อมูลด้วยเมธอด get() โดยมี Key เป็นอาร์กิวเมนต์ซึ่งผลลัพธ์การทำงานของมันจะเหมือนกับการเข้าถึงข้อมูลโดยตรง เช่น countries['de'] และเมธอด setdefault() ใช้รับค่าจากคีย์ที่กำหนด ถ้าไม่มีจะเป็นการเพิ่มค่าดังกล่าวเข้าไปใน Dictionary และต่อมาเมธอด popitem() จะนำสมาชิกตัวสุดท้ายออกจาก Dictionary และส่งค่าดังกล่าวกลับมาเป็น Tuple ออบเจ็ค ส่วนเมธอด items() นั้นจะค่ากลับมาเป็น List ของ Tuple ของออบเจ็คของ Key และ Value ทั้งหมด\ndict_keys([\u0026#39;de\u0026#39;, \u0026#39;ua\u0026#39;, \u0026#39;th\u0026#39;, \u0026#39;nl\u0026#39;]) dict_values([\u0026#39;Germany\u0026#39;, \u0026#39;Ukraine\u0026#39;, \u0026#39;Thailand\u0026#39;, \u0026#39;Netherlands\u0026#39;]) Germany (\u0026#39;tr\u0026#39;, \u0026#39;Turkey\u0026#39;) (\u0026#39;nl\u0026#39;, \u0026#39;Netherlands\u0026#39;) dict_items([(\u0026#39;de\u0026#39;, \u0026#39;Germany\u0026#39;), (\u0026#39;ua\u0026#39;, \u0026#39;Ukraine\u0026#39;), (\u0026#39;th\u0026#39;, \u0026#39;Thailand\u0026#39;)]) นี่เป็นผลลัพธ์การทำงานของโปรแกรม ในการใช้เมธอดใน Dictionary ในภาษา Python และจากในตัวอย่างนั้นเป็นเพียงส่วนหนึ่งของเมธอดที่มีเท่านั้น สำหรับเมธอดทั้งหมดใน Dictionary นั้นแสดงดังตารางข้างล่างนี้\nUntitled\nส่งค่ากลับเป็น List ของ Value ทั้งหมดใน Dictionary\nPython Dictionary functions ฟังก์ชันที่เป็นพื้นฐานและสามารถใช้ได้กับโครงสร้างข้อมูลทุกประเภทคือฟังก์ชัน len() เป็นฟังก์ชันที่ใช้สำหรับนับจำนวนสมาชิกของเจ็ค และ Dictionary ยังมีฟังก์ชัน iter() ที่ทำงานเหมือนกับเมธอด items() นี่เป็นตารางของฟังก์ชันที่สามารถใช้ได้กับ Dictionary\nUntitled\nคุณสามารถใช้คำสั่ง del เพื่อลบข้อมูลภายใน Dictionary ได้ เช่น คำสั่ง del countries['de'] เพื่อลบสมาชิกที่มี Key ที่กำหนดออกไป และคำสั่ง del countries นั้นเป็นการลบทั้งตัวแปร\nในบทนี้ คุณได้เรียนรู้เกี่ยวกับ Dictionary ในภาษา Python คุณได้ทราบวิธีการสร้างและใช้งาน Dictionary และสถานการณ์ที่เหมาะสมที่จะใช้ข้อมูลประเภทนี้ เราได้แสดงให้เห็นถึงการเข้าถึงข้อมูลภายใน Dictionary แบบพื้นฐานและด้วยการใช้คำสั่งวนซ้ำ For loop รวมถึงการใช้งานเมธอดและฟังก์ชันสำหรับจัดการ Dictionary\nศึกษาเพิ่มเติม  https://datagy.io/python-dictionary-comprehensions  Reference : http://marcuscode.com\n"
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/phyblas/beginer/module/",
	"title": "การเรียกใช้มอดูล (Module)",
	"tags": [],
	"description": "",
	"content": "ในบทที่ผ่านๆมาได้เรียนรู้ทั้งคำสั่งและฟังก์ชันต่างๆไปหลายรูปแบบหลายชนิด ทั้งหมดนั้นเป็นฟังก์ชันที่ถูกเตรียมไว้สามารถใช้ได้ทันทีโดยไม่ต้องมีการเตรียมการอะไรก่อน แต่ก็ยังมีฟังก์ชันหรือคำสั่งบางส่วนที่ยังไม่สามารถใช้ได้ทันทีหากไม่มีการเรียกใช้ก่อน ซึ่งก็คือฟังก์ชันที่อยู่ภายในมอดูลต่างๆ\nมอดูลภายในตัวและมอดูลเสริมภายนอก ฟังก์ชันและคำสั่งต่างๆที่สามารถเรียกมาเพิ่มเติมได้นั้นจะถูกเก็บในรูปของชุดคำสั่ง ซึ่งเรียกว่ามอดูล (module) มีมอดูลมากมายที่ติดตัวมาตั้งแต่ติดตั้งภาษาไพธอน ซึ่งเรียกมอดูลเหล่านี้ว่ามอดูลภายในตัว (built-in module)\nแต่ก็ยังมีมอดูลอีกประเภทที่ไม่ได้ติดตัวมาแต่แรก อาจถูกสร้างโดยนักเขียนโปรแกรมที่ไม่ได้มีส่วนเกี่ยวข้องกับกลุ่มผู้พัฒนาภาษาไพธอนโดยตรง แล้วก็ถูกนำมาแจกตามเว็บให้คนทั่วไปโหลด หรือเราเองก็อาจสามารถเขียนมันขึ้นมาเพิ่มเติมเองไว้ใช้เองได้ (เรื่องการสร้างมอดูลอ่านได้ในบทที่ ๓๔)\nมอดูลเสริมเหล่านี้ต้องติดตั้งเพิ่มเติมเอาเองโดยโหลดตามเว็บ บางมอดูลแค่โหลดแล้วนำมาใส่ในโฟลเดอร์ก็สามารถใช้ได้ทันที แต่ก็มีอยู่หลายอันที่ต้องมีขั้นตอนในการติดตั้ง อย่างไรก็ตามสำหรับ ใครที่ใช้โปรแกรมแพ็กเกจอย่าง anaconda spyder จะมีมอดูลเสริมติดตัวอยู่แล้วเป็นจำนวนมาก สามารถเรียกใช้ได้ทันทีเช่นเดียวกับมอดูลภายในตัว มอดูลเสริมมักถูกเก็บรวมอยู่แยกจากมอดูลภายในตัว โดยจะรวมอยู่ในโฟลเดอร์เดียว เช่น สำหรับ anaconda python3.5 ใน mac แล้วมอดูลเสริมถูกเก็บอยู่ใน\nUsers/\u0026lt;ชื่อผู้ใช้\u0026gt;/anaconda/lib/python3.5/site-packages สำหรับใน windows จะเป็น\nC:\\Anaconda3\\Lib\\site-packages การเรียกใช้ คำสั่งที่ใช้ในการเรียกใช้มอดูลก็คือ import โดยพิมพ์ import แล้วตามด้วยชื่อมอดูลที่ต้องการเรียกใช้ เช่น เรียกใช้มอดูลที่ชื่อ math ซึ่งเป็นมอดูลที่เก็บฟังก์ชันที่เกี่ยวกับการคำนวณทางคณิตศาสตร์\nimport math เพียงเท่านี้ก็จะสามารถใช้ฟังก์ชันภายในมอดูล math ได้แล้ว ขอยกตัวอย่างมาใช้ดูสักอัน เช่นฟังก์ชันชื่อ sin ซึ่งใช้คำนวณค่าไซน์ เวลาที่ใช้ก็ให้พิมพ์ชื่อมอดูลแล้วจึงตามด้วยชื่อฟังก์ชันนั้นโดยมีจุดคั่น\nmath.sin(1.57) # ได้ 0.9999996829318346 จะเห็นว่าชื่อฟังก์ชันในที่นี้อยู่ต่อจากจุด ดูแล้วคล้ายกับเมธอด แต่ความจริงแล้วไม่ใช่ ปกติจุด . เป็นตัวบอกถึงความสัมพันธ์แบบไล่เรียงหน่วยใหญ่ไปหาหน่วยเล็ก จุดในที่นี้แค่บอกว่าฟังก์ชันนี้เป็นฟังก์ชันในสังกัดของมอดูลไหนเท่านั้น\nอย่างไรก็ตามจริงๆแล้วมอดูลก็ถือเป็นออบเจ็กต์ชนิดหนึ่ง ดังนั้นอาจมองว่าฟังก์ชันเป็นเมธอดของมอดูลก็ได้เช่นกัน เพราะเมธอดก็คือฟังก์ชันที่สังกัดอยู่กับออบเจ็กต์คลาสต่างๆนั่นเอง หากใครเคยใช้ภาษาซีมาก่อนอาจคุ้นเคยกับคำว่า include คำสั่ง import ในภาษาไพธอนนี้เทียบเท่าได้กับ include ในภาษาซี คือเป็นการเรียกใช้ชุดคำสั่งที่จะมาใช้งานในโปรแกรม เพียงแต่ในภาษา ไพธอนคำสั่งพื้นฐานต่างๆสามารถใช้ได้ทันทีโดยไม่ต้องเรียกใช้ก่อน ผิดกับภาษาซีซึ่งมักจะต้องเริ่มด้วยการเรียกใช้ stdio.h และ conio.h เป็นประจำ\nดังนั้นทำให้การใช้งานในระดับพื้นฐานอาจไม่จำเป็นต้อง import อะไรเลย แต่พอต้องการใช้งานในระดับเฉพาะทางขึ้นมาหน่อยจึงจะเรียกใช้ หากลองเปรียบเทียบกับภาษาอื่นๆก็จะเห็นทั้งที่ใช้ include และ import เช่นใน php ใช้ include ใน javascript ใช้ import ความหมายเหมือนกันเพียงแต่ในแต่ละภาษาใช้ต่างกันเท่านั้น\nในภาษาไพธอนมอดูลก็ถือว่าเป็นออบเจ็กต์ชนิดหนึ่ง คือออบเจ็กต์ชนิดมอดูล ลองใช้ฟังก์ชัน type เพื่อหาชนิดดูได้\nprint(type(math)) # ได้ \u0026lt;class \u0026#39;module\u0026#39;\u0026gt; ส่วนสิ่งที่มากับมอดูลนั้นอาจเป็นออบเจ็กต์ชนิดใดก็ได้มีได้หลายอย่าง ชนิดอาจแตกต่างกันออกไป โดยส่วนใหญ่แล้วจะเป็นฟังก์ชัน เช่น\nprint(type(math.sin)) # \u0026lt;class \u0026#39;builtin_function_or_method\u0026#39;\u0026gt; เนื่องจาก math เป็นมอดูลภายในตัว ดังนั้นฟังก์ชันที่อยู่ในนี้ก็เลยมีชนิดเป็นฟังก์ชันหรือเมธอดภายในตัว แต่หากเป็นฟังก์ชันในมอดูลชนิดอื่นก็อาจมีชนิดที่ต่างกันออกไป ซึ่งก็แล้วแต่ผู้สร้างมอดูลนั้นจะกำหนด นอกจากฟังก์ชันแล้วมอดูลก็อาจประกอบด้วยข้อมูลหรือออบเจ็กต์ที่เป็นค่าตัวเลขหรือสายอักขระก็ได้ เช่น\nprint(math.pi) # ได้ 3.141592653589793 pi นี้คือค่า π เป็นแค่ค่าคงที่ตัวหนึ่ง หากหาชนิดก็จะได้ว่าเป็น float\nการลบมอดูล หากไม่ต้องการใช้มอดูลไหนแล้วก็อาจลบทิ้งโดยใช้คำสั่ง del จากนั้นก็จะไม่สามารถใช้มอดูลนั้นได้อีกจนกว่าจำเรียกใช้ใหม่\ndel math math.sin(1.57) # ได้ NameError: name \u0026#39;math\u0026#39; is not defined หรืออาจลบแค่ฟังก์ชันในมอดูลนั้นตัวเดียว เช่น\ndel math.sin แบบนี้ก็จะใช้ไม่ได้แค่ math.sin ส่วนฟังก์ชันอื่นเช่น math.cos ก็ยังใช้ได้อยู่\nการละชื่อมอดูล โดยทั่วไปฟังก์ชันที่อยู่ภายในมอดูลที่เรียกเข้ามาด้วยคำสั่ง import ธรรมดานั้นเวลาจะใช้จะต้องมีชื่อมอดูลนำหน้าเสมอ แต่ก็มีวิธีที่จะทำให้ไม่ต้องใส่ชื่อมอดูลนำหน้าก็ได้ ซึ่งทำได้โดยใช้คำสั่ง from เช่น\nfrom math import * เท่านี้ก็สามารถใช้ฟังก์ชันทั้งหมดในมอดูล math ได้โดยไม่จำเป็นต้องมี math. นำหน้าแล้ว เช่นพิมพ์แค่ sin(1.57) ง่ายๆสั้นๆ ดอกจันทน์ * ในที่นี้มีความหมายว่าเรียกใช้ทุกสิ่งทุกอย่างที่อยู่ภายในมอดูลนั้นออกมา ให้หมด แต่ว่าถ้าหากอยากเรียกใช้แค่บางอันก็ทำได้โดยแค่เปลี่ยน * เป็นชื่อของสิ่งที่ต้องการใช้ เช่น\nform math import sin ถ้าทำแบบนี้ก็จะใช้ได้แค่ฟังก์ชัน sin ส่วนฟังก์ชันอื่นจะยังใช้ไม่ได้ อย่างไรก็ตามการใช้ from กับ * นี้โดยทั่วไปแล้วจะไม่ใช้ถ้าไม่แน่ใจว่าจะไม่มีผลกระทบอะไร เนื่องจากแต่ละมอดูลอาจมีฟังก์ชันที่ชื่อเหมือนกัน ซึ่งจะทำให้เกิดการซ้อนทับกันได้ โดยฟังก์ชันจากมอดูลที่เรียกใช้ทีหลังจะไปทับของมอดูลตัวที่เรียกก่อน สำหรับผู้เริ่มฝึกหัดแล้ว เพื่อความชัดเจนบางทีก็ควรจะเหลือชื่อมอดูลต้นทางเอาไว้น่าจะดีต่อการเรียน รู้มากกว่า ดังนั้นแนะนำว่าอย่าใช้ form แต่ให้ import โดยตรงดีกว่า\nการย่อชื่อมอดูลและฟังก์ชัน หากชื่อยาวๆก็สามารถย่อลงได้ บ่อยครั้งที่ชุดคำสั่งยาวๆมักถูกย่อชื่อลง การย่อชื่อสามารถทำได้โดยเขียน as ต่อท้ายตามด้วยชื่อที่ต้องการย่อ เช่น\nimport random as rd จากนั้นเวลาเรียกใช้มอดูลนี้ก็พิมพ์แค่ชื่อที่ถูกย่อแล้วตามด้วยชื่อฟังก์ชัน เช่น\nrd.uniform(0,100) # จะได้ค่าเลขสุ่มซึ่งอยู่ในช่วง 0 ถึง 100 มอดูล random นี้เป็นมอดูลที่ประกอบด้วยฟังก์ชันที่เกี่ยวข้องกับการสุ่ม (รายละเอียดเกี่ยวมอดูล random อ่านได้ใน https://phyblas.hinaboshi.com/20160508) ฟังก์ชัน uniform นั้นจะคืนค่าเป็นจำนวนจริงสุ่มภายในช่วงระหว่างอาร์กิวเมนต์ ๒ ตัวที่ใส่ลงไป สิ่งที่ย่อชื่อได้นั้นไม่เพียงแต่ชื่อมอดูลเท่านั้น แต่ชื่อฟังก์ชันภายในมอดูลก็สามารถย่อได้เช่นกัน เช่น\nfrom random import uniform as unif เพียงเท่านี้ก็สามารถใช้ random.uniform ได้โดยพิมพ์แค่ unif(0,100) ชื่อมอดูลที่ถูกเรียกขึ้นมานั้นมีสถานะเหมือนตัวแปรตัวหนึ่ง จะใช้ชื่อนี้เป็นตัวแปรทำอย่างอื่นอีกไม่ได้ ถ้าใช้จะถูกเขียนทับ เช่น\nimport math math = 100 math.sin(1.57) # ได้ AttributeError: \u0026#39;int\u0026#39; object has no attribute \u0026#39;sin\u0026#39; นั่นเพราะพอแทนค่าลงไปแบบนี้กลายเป็นว่าตัวแปรที่ชื่อ math ไปรับค่า 100 แล้วมันก็จะไม่ใช่เป็นมอดูลที่ชื่อ math อีกต่อไป กลายเป็นค่าจำนวนเต็มธรรมดา เราจะใช้มันไม่ได้อีกจนกว่าจะ import ใหม่ หรือแม้แต่เวลาที่ใช้ชื่อย่อก็เช่นกัน ต้องระวังไม่ให้ชื่อย่อนั้นไปซ้ำกับชื่อตัวแปรที่ต้องการจะใช้\nมอดูลย่อยภายในมอดูลหลัก ปกติแล้วภายในมอดูลหนึ่งจะประกอบไปด้วยฟังก์ชันมากมายอยู่ บางทีฟังก์ชันภายในมอดูลนั้นเองก็อาจจะแบ่งเป็นหมวดหมู่ต่างๆซึ่งมีลักษณะ เฉพาะต่างกันออกไป เมื่อเป็นแบบนี้บางมอดูลจึงได้มีการแบ่งมอดูลออก เป็นส่วนย่อยๆลงไปอีก เพื่อความเป็นระเบียบ มอดูลที่เป็นหน่วยย่อยลงไปอีกนั้นเรียกว่าซับมอดูล (submodule)\nยกตัวอย่างเช่นมอดูลชื่อ os มอดูลนี้มีไว้สำหรับจัดการกับสิ่งที่เกี่ยวข้องกับระบบปฏิบัติการ เช่นฟังก์ชัน os.uname นั้นจะคืนค่าข้อมูลที่ใช้จำแนกบ่งบอกถึงตัวเครื่องนี้ os.getcwd จะคืนค่าชื่อของโฟลเดอร์ที่ใช้ทำงานอยู่ (ที่อยู่ของไฟล์ที่รัน) แต่ว่าภายในมอดูล os นี้ก็ยังประกอบไปด้วยมอดูลย่อยที่ชื่อว่า path อยู่ ภายในนี้มีฟังก์ชันที่เกี่ยวข้องกับพาธ (เส้นทางที่บ่งชี้ตำแหน่งของไฟล์หรือส่วนประกอบต่างๆ) เช่น os.path.abspath เป็นฟังก์ชันที่จะคืนค่าพาธสัมบูรณ์ของไฟล์\nตัวอย่างการใช้มอดูล os\nimport os print(os.uname()) print(os.getcwd()) print(os.path.abspath(\u0026#39;untitled0.py\u0026#39;)) จะเห็นว่าเมื่อเรียกใช้มอดูล os โดย import เฉยๆเวลาที่ใช้ os.path.abspath จะต้องพิมพ์ยาวไล่ตั้งแต่ชื่อมอดูลหลัก ตามด้วยชื่อมอดูลย่อย แล้วจึงจะเป็นชื่อฟังก์ชัน อย่างไรก็ตามสามารถย่อได้โดยใช้ from\nfrom os import path แบบนี้ก็จะสามารถละ os. ด้านหน้าไปได้ path.abspath หรือย่อกว่านั้นคือละชื่อมอดูลย่อยไปด้วย\nfrom os.path import * หรือ\nfrom os.path import abspath แบบนี้ก็จะใช้ฟังก์ชัน abspath ได้โดยพิมพ์แค่ชื่อ abspath มอดูลย่อยก็สามารถทำการย่อชื่อได้ เช่น\nfrom os import path as op หรือ\nimport os.path as op สองแบบนี้มีค่าเท่ากัน คือเวลาเรียกใช้ abspath จะต้องพิมพ์เป็น op.abspath\nจะเห็นได้ว่าการเรียกใช้มอดูลมีทางเลือกอยู่หลากหลาย มีความยืดหยุ่น ถือเป็นความสะดวกอย่างหนึ่งของภาษาไพธอน เพียงแต่อาจจะต้องเสียเวลาทำความเข้าใจกันสักเล็กน้อย อนึ่ง มอดูลย่อยนั้นก็อาจจะมีมอดูลย่อยแยกเล็กลงไปอีก ซึ่งยิ่งย่อยก็จะยิ่งคั่นด้วยจุด . ไปเรื่อยๆ อาจมีย่อยลงไปอีกกี่ชั้นก็ได้ แล้วแต่คนออกแบบมอดูลจะออกแบบมา\nคลาสที่มากับมอดูล สิ่งที่ได้มาจากการเรียกใช้มอดูลนั้นไม่ได้มีเพียงฟังก์ชันใหม่หรือตัวแปรใหม่ เท่านั้น แต่ยังทำให้สามารถใช้ออบเจ็กต์ชนิดใหม่ได้ด้วยหากในมอดูลนั้นมีการจำกัดความ คลาสใหม่เฉพาะขึ้นมา เรื่องของการสร้างคลาสนั้นจะพูดถึงในบทหลังจาก นี้ไปอีกเพราะเป็นเรื่องที่ซับซ้อน แต่ในบทนี้จะพูดถึงคร่าวๆเกี่ยวกับการใช้ออบเจ็กต์จากคลาสที่ถูกสร้างภายใน มอดูลที่เรียกใช้ ในที่นี้ขอยกตัวอย่างมอดูล fractions ซึ่งเป็นมอดูลที่ใช้จัดการเลขเศษส่วน การทำงานของมอดูลนี้ก็คือนิยามออบเจ็กต์ (หรือก็คือข้อมูล) ชนิดใหม่ขึ้นมาชนิดหนึ่ง ซึ่งก็คือ \u0026ldquo;เลขเศษส่วน\u0026rdquo;\nแนวคิดของมอดูลนี้ก็คือ ปกติแล้วจะเห็นว่าตัวเลขจำนวนจริงต่างๆที่ถูกคำนวณภายในโปรแกรมนั้นจะอยู่ใน รูปของเลขทศนิยม แม้จะเป็นตัวเลขที่เขียนเศษส่วนแล้วดูเข้าใจง่ายกว่าก็ตาม เช่น 1/3 ก็จะกลายเป็น 0.3333333333333333 ซึ่งค่าที่ได้ก็จะเป็นเพียงค่าประมาณเท่านั้น หากนำมาคำนวณก็อาจเกิดความคลาดเคลื่อนทีละเล็กน้อย\nเพื่อรองรับความ จำเป็นในการใช้เลขในรูปของเศษส่วนซึ่งอาจเกิดขึ้นในบางสถานการณ์ มอดูล fractions จึงได้นิยามข้อมูลชนิดใหม่ ซึ่งสามารถเก็บตัวเลขให้อยู่ในรูปเศษส่วนได้\nตัวอย่างการใช้\nimport fractions a = fractions.Fraction(1,3) print(a) # ได้ 1/3  print(type(a)) # ได้ชนิดของข้อมูลเป็น \u0026lt;class \u0026#39;fractions.Fraction\u0026#39;\u0026gt; ในที่นี้จะเห็นว่าตัวแปร a กลายเป็นออบเจ็กต์ชนิดใหม่ ซึ่งก็คือชนิด fractions.Fraction ชื่ออาจจะดูยาวไปสักหน่อยเพราะต้องขึ้นต้นด้วยชื่อมอดูลก่อน รงส่วน a = fractions.Fraction(1,3) นั้นเป็นการประกาศตัวแปรและใส่ค่าให้ โดยเวลาสร้างข้อมูลชนิดนี้ทำได้หลายวิธี แต่ในที่นี้ใช้วิธีที่ง่ายที่สุดก็คือใส่อาร์กิวเมนต์เป็นเลขเศษตามด้วยเลขส่วน มองดูแล้วอาจรู้สึกว่ายุ่งยากต้องพิมพ์ตั้งยาวขนาดนี้เพื่อแค่ให้ได้จำนวนเศษส่วนมาตัวหนึ่ง อย่างไรก็ตามสามารถย่อได้ เช่น\nfrom fractions import Fraction as fr a = fr(1,3) แบบนี้จะดูง่ายขึ้นเยอะ เพียงแต่ว่าเวลาถามถึงชื่อชนิดข้อมูลโดย print(type(a)) ก็ยังจะได้ผลเป็น \u0026lt;class 'fractions.Fraction'\u0026gt; เหมือนเดิม เพราะในที่นีคำว่า fr แค่มาแทน fractions.Fraction เพื่อความสะดวกเท่านั้น ข้อมูลเลขเศษส่วนเวลาที่สั่ง print จะแสดงผลออกมาเป็นเลขเศษส่วน คือเป็นเลขเศษคั่นด้วย / แล้วตามด้วยเลขส่วน นี่เป็นตัวอย่างคร่าวๆของการสร้างและใช้ออบเจ็กต์ชนิดใหม่ ที่จริงแล้วยังมีออบเจ็กต์อีกจำนวนมากมายหลายชนิดซึ่งจะต้องได้เจอต่อไปอีก เยอะ\nตัวอย่างมอดูลอื่นๆ หลังจากที่ได้ลองยกตัวอย่างมอดูลบางส่วนไปแล้ว คราวนี้จะลองยกตัวอย่างแนะนำมอดูลอื่นๆซึ่งเป็นมอดูลภายในตัว ที่จริงมีอยู่มากมายคงยกมาได้ไม่หมด เอาแค่ให้พอเห็นภาพโดยรวม\n time ทำหน้าที่จัดการเกี่ยวกับเวลา datetime ยามออบเจ็กต์ชนิดวันเวลาขึ้นมา ช่วยให้การคำนวณอะไรที่เกี่ยวกับวันเวลาเป็นไปได้อย่างสะดวก decimal นิยามเลขทศนิยมฐานสิบซึ่งมีความแม่นยำสูงกว่าเลขทศนิยมตามที่ต้องการ sys เก็บตัวแปรต่างๆที่ควบคุมจัดการระบบ io จัดการกับการรับเข้าและนำออกข้อมูล re สำหรับใช้เอ็กซ์เพรชชันแบบปกติ platform ให้ข้อมูลเกี่ยวกับแพล็ตฟอร์มที่ใช้อยู่ zipfile สำหรับจัดการไฟล์ zip เช่นอัดรวมไฟล์และแตกไฟล์  นอกจากนี้ขอยกตัวอย่างมอดูลเสริมภายนอกที่เป็นที่นิยมจำนวนหนึ่งด้วย\n numpy นิยามออบเจ็กต์ชนิดแถวอาเรย์ที่สามารถคำนวณเมทริกซ์ ใช้ในการคำนวณได้อย่างมีประสิทธิภาพ scipy เครื่องมือสำคัญที่ใช้ในการคำนวณทางวิทยาศาสตร์ matplotlib สำหรับวาดกราฟ pandas สำหรับจัดการกับข้อมูลอย่างเป็นระบบในรูปแบบตาราง mayavi สำหรับวาดกราฟสามมิติ py2exe สำหรับเปลี่ยนโปรแกรมภาษาไพธอนให้เป็น .exe xlrd สำหรับจัดการไฟล์ excel PyQt / PySide สำหรับสร้างกราฟิกยูเซอร์อินเทอร์เฟซ (GUI) OpenGL สำหรับแสดงผลภาพกราฟิก  ใน IDE ที่เป็นแพ็กเกจเช่น anaconda spyder นั้นจะมีมอดูลเสริมอยู่หลายตัวติดมาตอนลงอยู่แล้ว แต่มอดูลไหนที่ไม่มีก็สามารถติดตั้งเพิ่มได้อย่างไม่ยาก\nมอดูลเสริมมีอยู่มากมาย หากรู้ว่าตัวเองต้องการเขียนโปรแกรมสำหรับใช้งานด้านไหนก็ลองหามอดูลที่ เกี่ยวข้อง จะมีประโยชน์สามารถใช้งานอะไรได้อย่างกว้างขวาง\nสรุปเนื้อหา ในบทนี้ได้แนะนำให้รู้จักกับวิธีการเรียกใช้มอดูลและได้แนะนำมอดูลที่สำคัญไปส่วนหนึ่งแล้ว การเรียกใช้มอดูลทำให้เราสามารถใช้ฟังก์ชันได้มากขึ้น หรือใช้คลาสใหม่ที่นิยามภายในมอดูลนั้นได้ มอดูลอาจประกอบไปด้วยมอดูลย่อย การเรียกใช้มอดูลมีอยู่หลายวิธี สามารถเลือกใช้ตามความเหมาะสม\nอ้างอิง\nhttp://www.tohoho-web.com/python/module.html\nhttp://docs.python.jp/3/tutorial/modules.html\nhttp://docs.python.jp/3/library/index.html\n Reference : https://phyblas.hinaboshi.com/tsuchinoko15\n "
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/learning-python/17_module/17_module/",
	"title": "17. โมดูล (Module)",
	"tags": [],
	"description": "",
	"content": "ในการเขียนโปรแกรมในภาษา Python โมดูล (Module) คือไฟล์ของโปรแกรมที่กำหนดตัวแปร ฟังก์ชัน หรือคลาสโดยแบ่งย่อยออกไปจากโปรแกรมหลัก และสามารถนำมาใช้งานได้โดยการนำเข้ามาในโปรแกรม (Import) กล่าวอีกนัยหนึ่ง โมดูลก็คือไลบรารี่ที่สร้างไว้และนำมาใช้งานในโปรแกรม ในบทนี้ เราจะพูดถึงความหมายของโมดูล การสร้าง และการใช้งานโมดูลในการเขียนโปรแกรม นอกจากนี้ เราจะแนะนำให้คุณรู้จักกับ Package ซึ่งเป็นแนวคิดในการจัดการกับโมดูลในรูปแบบของ Namespace\nโมดูล คืออะไร โมดูล (Module) คือไฟล์หรือส่วนของโปรแกรมที่ใช้สำหรับกำหนดตัวแปร ฟังก์ชัน หรือคลาสโดยแบ่งย่อยอีกหน่วยหนึ่งจากโปรแกรมหลัก และในโมดูลยังสามารถประกอบไปด้วยคำสั่งประมวลผลการทำงานได้ ยกตัวอย่างเช่น เมื่อคุณเขียนโปรแกรมในภาษา Python คุณอาจจะมีฟังก์ชันสำหรับทำงานและจัดการกับตัวเลขเป็นจำนวนมาก และในขณะเดียวกัน คุณไม่ต้องการให้โปรแกรมหลักนั้นมีขนาดใหญ่เกินไป นั่นหมายความว่าคุณสามารถนำฟังก์ชันเหล่านี้มาสร้างเป็นโมดูล และในการใช้งานนั้นจะต้องนำเข้ามาในโปรแกรมโดยวิธีที่เรียกว่า Import\nคุณจะเห็นว่าโมดูลก็คือการแยกส่วนของโปรแกรมออกไปเป็นอีกส่วนและสามารถเรียกใช้ได้เมื่อต้องการ หรือกล่าวอีกนัยหนึ่ง โมดูลก็เหมือนไลบรารีของฟังก์ชันและคลาสต่างๆ นั่นเป็นเพราะว่าเมื่อโปรแกรมของคุณมีขนาดใหญ่ คุณสามารถแบ่งส่วนต่างๆ ของโปรแกรมออกเป็นโมดูลย่อยๆ เพื่อให้ง่ายต่อการจัดการและการใช้งาน ในภาษา Python โมดูลที่ถูกสร้างขึ้นมานั้นจะเป็นไฟล์ในรูปแบบ module_name.py และนอกจากนี้ Python ยังมี Built-in module เป็นจำนวนมาก เช่น math เป็นโมดูลเกี่ยวกับฟังก์ชันทางคณิตศาสตร์ หรือ random เป็นโมดูลเพื่อจัดการและสุ่มตัวเลข เป็นต้น\nการสร้างโมดูลในภาษา Python ในการสร้างโมดูลในภาษา Python คุณต้องนำโค้ดของโปรแกรม โดยทั่วไปแล้วจะประกอบไปด้วย ตัวแปร ฟังก์ชัน หรือคลาส ไปรวมไว้ในไฟล์ใหม่ที่ไม่ใช้ไฟล์หลักของโปรแกรม ในรูปแบบ module_name.py โดยที่ module_name นั้นเป็นชื่อของโมดูลเพื่อนำไปใช้งานในการเขียนโปรแกรม โดยการเรียกใช้ด้วยคำสั่ง import ต่อไปมาดูตัวอย่างการสร้างโมดูลในภาษา Python\n# number.py def factorial(n): # return factorial value of n if n == 0 or n == 1: return 1 else: return n * factorial(n - 1) def fibonacci(n): # return Fibonacci series up to n result = [] a, b = 0, 1 while b \u0026lt; n: result.append(b) a, b = b, a + b return result ในตัวอย่าง เป็นการสร้างโมดูลโดยไฟล์ของโมดูลนั้นมีชื่อว่า number.py นั่นหมายความว่าโมดูลนี้มีชื่อว่า number ซึ่งนี่เป็นสิ่งที่เราจะใช้สำหรับเรียกใช้งานโมดูลในการเขียนโปรแกรม ภายในโมดูลประกอบไปด้วย 2 ฟังก์ชันที่ทำงานเกี่ยวกับตัวเลข ฟังก์ชัน factorial() เป็นฟังก์ชันสำหรับหาค่า Factorial ของตัวเลขจำนวนเต็ม n ซึ่งเป็น Recursive function และฟังก์ชัน fibonacci() ใช้หาลำดับของ Fibonacci จนถึงจำนวนเต็ม n\nการนำเข้าโมดูลด้วยคำสั่ง import หลังจากที่เราได้สร้างโมดูลไปแล้ว ต่อไปจะเป็นการนำโมดูลดังกล่าวมาใช้งาน ในภาษา Python นั้นจะใช้คำสั่ง import เพื่อนำเข้าโมดูลเพื่อนำมาใช้งานในโปรแกรม มาดูตัวอย่างการใช้งานโมดูล number ในตัวอย่างก่อนหน้า นี่เป็นโค้ดของโปรแกรม\nimport number print(\u0026#39;5! = \u0026#39;, number.factorial(5)) print(number.fibonacci(100)) ในตัวอย่าง เป็นการนำโมดูล number เข้ามาใช้งานที่โปรแกรมหลัก (Main program) โดยการใช้คำสั่ง import และตามด้วยชื่อของโมดูล นี่เป็นการนำเข้าสมาชิกทั้งหมดเข้ามาในโปรแกรม ในการใช้งานฟังก์ชันในโมดูลนั้นสามารถทำได้โดยใช้ชื่อของโมดูล ตามด้วยเครื่องหมายจุด และหลังจากนั้นเป็นฟังก์ชันที่ต้องการ ในรูปแบบ module_name.object_name เราได้เข้าถึงฟังก์ชันทั้งสองในโมดูล\n5! = 120 [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89] นี่เป็นผลลัพธ์การทำงานของโปรแกรม ซึ่งนี่แสดงให้เห็นอย่างชัดเจนว่า เราสามารถใช้โมดูลในการแยกโค้ดของโปรแกรมออกไปต่างหากได้ ซึ่งจะทำให้โปรแกรมสั้นลงหรือทำเป็นไลบรารี่เพื่อนำไว้ใช้เมื่อต้องการ\nการนำเข้าโมดูลด้วยคำสั่ง from \u0026hellip; import ในการใช้งานคำสั่ง import นั้นจะเป็นการนำเข้าออบเจ็คทั้งหมดในโมดูลเข้ามายังโปรแกรม และการใช้งานฟังก์ชันหรือออบเจ็คภายในโมดูลจะต้องนำหน้าด้วยชื่อโมดูลเสมอ ในภาษา Python นั้นมีคำสั่ง from import สำหรับนำเข้าข้อมูลบางส่วนภายในโมดูล และสามารถใช้งานออบเจ็คได้โดยตรงโดยไม่ต้องมี Prefix ชื่อของโมดูล มาดูตัวอย่างการใช้งาน\nfrom number import factorial print(\u0026#39;5! = \u0026#39;, factorial(5)) print(\u0026#39;3! = \u0026#39;, factorial(3)) ในตัวอย่าง เป็นการใช้งานคำสั่ง from ... import เพื่อนำเข้าฟังก์ชันภายในโมดูล number จะเห็นได้ว่าเราได้นำเข้าเพียงฟังก์ชัน factorial() เข้ามาในโปรแกรมและในตอนใช้งานนั้นสามารถใช้ได้โดยที่ไม่ต้องใช้ Prefix ในการเรียกใช้\nfrom number import factorial, fibonacci # or from number import * ในอีกทางหนึ่ง คุณสามารถนำเข้าหลายออบเจ็ค (ฟังก์ชัน) ในโมดูลโดยการใช้เครื่องหมายคอมมา (,) เป็นตัวคั่น หรือนำเข้าทั้งหมดโดยการใช้เครื่องหมายสตาร์ (*) เหมือนในตัวอย่างด้านบน แต่อย่างไรก็ตามนี่เป็นวิธีที่ไม่แนะนำในการใช้งาน เพราะว่าวิธีดังกล่าวนั้นจะเป็นการนำเข้าที่อาจจะเกิดความขัดแย้งกัน ดังนั้นการใช้งานในรูปแบบของ Prefix จึงเป็นวิธีฝึกปฏิบัติที่ดีสำหรับการ Import โมดูลเข้ามาในโปรแกรม และนอกจากนี้ โมดูลยังสามารถ Import เป็นแบบลำดับชั้นได้ ยกตัวอย่างเช่น โมดูล B นำเข้า โมดูล A และหลังจากนั้นโมดูล C นำเข้าโมดูล B (A -\u0026gt; B -\u0026gt; C) เป็นต้น\nในการ Import โมดูลเข้ามาในโปรแกรมนั้น Python จะทำการค้นหาไฟล์ของ module_name.py จาก Built-in module ก่อน แล้วหลังจากนั้นโปรแกรมจะทำการค้นหาโมดูลภายในลิสต์ของ Directory ภายในตัวแปร sys.path\nPackages Package คือการกำหนดโครงสร้างของโมดูลในภาษา Python ที่เรียกว่า Namespace เพื่อจัดระเบียบของโมดูลต่างๆ ให้เป็นหมวดหมู่เดียวกัน แนวคิดของ Package เหมือนกับระบบจัดการไฟล์ในระบบปฏิบัติการซึ่งจะประกอบไปด้วยไฟล์และโฟล์เดอร์ โดยไฟล์ที่อยู่ในหมวดหมู่เดียวกันจะถูกเก็บไว้ในโฟล์เดอร์เดียวกัน เช่นเดียวกัน Package ใช้สำหรับจัดหมวดหมู่ให้กับโมดูล โดยโมดูลที่มีฟังก์ชันและคลาสการทำงานที่เหมือนกันจะอยู่ใน Package เดียวกัน อย่างไรก็ตาม นี่จะขึ้นกับการออกแบบของโปรแกรมเมอร์\nในการสร้าง Package คุณต้องสร้างโฟลด์เดอร์ให้มีโครงสร้างตามที่ต้องการ เนื่องจากในภาษา Python นั้น Package ก็คือโฟล์เดอร์ที่ใช้เก็บไฟล์โมดูลของโปรแกรม และสามารถซ้อนกันได้แบบลำดับชั้น นี่เป็นตัวอย่างของ Package ที่เราได้สร้างขึ้นโดยมี image เป็นรูทของ Package ภายใน Package นี้จะแบ่งย่อยออกเป็นอีกสาม Package คือ formats filters และ edit และแต่ละ Package จะมีโมดูลอยู่ภายใน\nimage/ Top-level package __init__.py Initialize the image package formats/ Subpackage for file format __init__.py jpeg.py gif.py png.py ... filters/ Subpackage for image filters __init__.py blur.py noise.py render.py ... edit/ Subpackage for editing images __init__.py crop.py grayscale.py invert.py resize.py ... ในโฟล์เดอร์ของใน Package มีจะมีไฟล์พิเศษที่ชื่อว่า __init__.py ซึ่งเป็นตัวกำหนดโมดูลภายใน Package สำหรับเพื่อให้ Python ใช้ในการค้นหา Package ภายในโฟล์เดอร์ดังกล่าวเมื่อมีการ Import ในรูปแบบ import * และไฟล์นี้สามารถที่จะไม่มีก็ได้ มาดูตัวอย่างของไฟล์ __init__.py สำหรับ Package image/formats\n__all__ = [\u0026#34;jpeg\u0026#34;, \u0026#34;gif\u0026#34;, \u0026#34;png\u0026#34;] ในตัวอย่าง เราได้กำหนดค่าให้กับไฟล์ __init__.py สำหรับ Package image/formats ในตัวแปร __all__ เป็นรายการของโมดูลหรือ Package ย่อยที่จะอนุญาติให้ Python ทำการค้นหาและโหลดเข้ามาในโปรแกรม ซึ่งนี่เป็นการบอก Python ว่าโมดูลดังกล่าวนั้นจะถูก Import เมื่อมีการใช้คำสั่ง import * และต่อไปมาดูตัวอย่างการใช้งานและการ Import โมดูลจาก Package ในภาษา Python โดยในไฟล์ image/formats/jpeg.py นั้นมีโค้ดดังต่อไปนี้\nclass JPEG: def __init__(self, w, h): self.w = w self.h = h print(\u0026#39;JPEG image created\u0026#39;) def dimension(self): print(\u0026#39;Image dimension:\u0026#39;, self.w, \u0026#39;x\u0026#39;, (self.h)) ในโมดูล jpeg ได้มีคลาส JPEG สำหรับสร้างรูปภาพประเภท jpeg เพื่อที่จะใช้งานคลาสนี้ เราจะต้องทำการ Import โมดูลดังกล่าวเข้ามาในโปรแกรม ด้วยคำสั่งดังนี้\nfrom image.formats import jpeg from image.formats import * ในตัวอย่าง เป็นสองวิธีที่คุณสามารทำได้สำหรับการ Import โมดูล jpeg เข้ามาใช้งานในโปรแกรม ในแบบแรกเป็นการ Import เพียงเฉพาะโมดูล jpeg ที่กำหนด และในแบบที่สองนั้นเป็นการเลือกทั้งหมด ซึ่งนี่จะทำให้ Python ทำการ Import โมดูลที่ถูกกำหนดไว้ในไฟล์ __init__.py ถ้าหากมีไฟล์ดังกล่าว อย่างไรก็ตาม ในวิธีที่สองนั้นไม่แนะนำในทางปฏิบัติ เพราะคุณควรจะ Import เพียงโมดูลที่ต้องการใช้งานจริงๆ เท่านั้น ซึ่งนี่จะช่วยประหยัดหน่วยความจำได้\nimport image.formats.jpeg g = jpeg.JPEG(400, 100) g.dimension() นี่เป็นตัวอย่างของการ Import โมดูลจาก Package และสร้างออบเจ็คจากคลาส JPEG คุณจะเห็นว่าในการเข้าถึงคลาสนั้นเรายังคงต้อง Prefix กับชื่อของโมดูลเสมอ\nในบทนี้ คุณได้เรียนรู้เกี่ยวกับโมดูลในภาษา Python และได้ทราบว่าการใช้งานโมดูลนั้นสามารถช่วยแบ่งโค้ดออกเป็นส่วนๆ และเรียกใช้งานได้เมื่อต้องการ เราได้พูดถึงการสร้างและการใช้งานโมดูลโดยการนำเข้าโมดูลด้วยคำสั่ง import และคำสั่ง from import การจัดหมวดหมู่ของโมดูลด้วย Package นี่เป็นสิ่งที่สำคัญเมื่อโปรแกรมของคุณมีขนาดใหญ่ขึ้น คุณอาจจะแบ่งมันออกเป็นส่วนๆ โดยแยกเป็นโมดูล และจัดกลุ่มของโมดูลด้วยการใช้ Package และนอกจากนี้ คุณยังสามารถสร้างไลบรารี่ของคุณ เพื่อให้นักพัฒนาคนอื่นๆ ได้ใช้งาน\nReference : http://marcuscode.com/lang/python/modules\n"
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/phyblas/intermediate/read_files/",
	"title": "การอ่านข้อมูลจากไฟล์",
	"tags": [],
	"description": "",
	"content": "การอ่านและเขียนไฟล์เป็นเรื่องสำคัญมากอย่างหนึ่งในการเขียนโปรแกรม เพราะบางทีเราอาจต้องการบันทึกข้อมูลเก็บเอาไว้หรือนำข้อมูลจากที่ไหนมาใช้ ไฟล์มีหลากหลายชนิดต่างกันไปตามแต่ว่าใช้ทำอะไร แต่โดยหลักๆแล้วก็จะประกอบไปด้วยตัวหนังสือ หากเปิดด้วยโปรแกรมสำหรับอ่านเขียนข้อความเช่น notepad ก็จะเห็นเป็นโค้ดตัวหนังสือเรียงต่อๆกัน\nไฟล์ยังแบ่งเป็นไฟล์ข้อความ ที่มนุษย์อ่านรู้เรื่องได้ กับไฟล์ที่มีแต่โค้ดเลขฐานสองที่คอมเท่านั้นที่อ่านได้ ซึ่งเรียกว่าไฟล์ชนิดไบนารี (binary) อย่างไรก็ตามในบทนี้จะพูดถึงการจัดการกับไฟล์ที่เป็นตัวหนังสือที่สามารถ อ่านได้ จะไม่พูดถึงไฟล์แบบไบนารี\nการจัดการไฟล์นั้นโดยรวมๆแล้วประกอบไปด้วย\n นำข้อมูลจากไฟล์มาอ่าน เขียนไฟล์ขึ้นมาใหม่ แก้ไขไฟล์ที่มีอยู่เดิม  ขั้นตอนการจัดการไฟล์นั้นมีหลักๆ ๓ ขั้น คือ\n เปิดไฟล์ ใช้ไฟล์ (เพื่ออ่านหรือเขียน) ปิดไฟล์  ในที่นี้ขอยกข้อความสำหรับเป็นไฟล์ตัวอย่าง เป็นเนื้อเพลงของเพลง nishikaze no okurimono\n(ที่มา)\nไฟล์ตัวอย่าง nishikaze.txt\nQuando Zefiro danza prendendo Flora per mano, il mar Tirreno si muta in azzurro e giunge la primavera. Finisce il cupo inverno il porto è pieno di barche tornate a casa. Quel ragazzo che cammina lungo il molo con le guance tinte tornerà dal suo amor. Per il gentile vento che soffia da est il ciel si fa via via sereno, i pesci risvegliatisi dal lungo sonno sporgon furtivamente la testa tra le onde. Quando Zefiro sussurra a Flora parole d\u0026#39;amore, i boccioli dei fiori si gonfian di rosa e giunge la primavera. I fischi a vapore giungono alla banchina il porto è pieno di gente che va in paesi lontani. Con la speranza e l\u0026#39;inquietudine nel cuore, i pionieri raggiungeranno terre mai viste. Il vento dell\u0026#39;est insieme ai fiori si dirige verso nuove città, le rondini, cantando la canzone appena imparata, gioiscono della nuova stagion. คัดลอกข้อความลงไปเซฟ ให้เซฟลงไว้ที่โฟลเดอร์เดียวกับไฟล์โปรแกรม เวลาเซฟนั้นให้ดูด้วยว่าเอนโค้ดเป็นอะไร ในที่นี้ขอให้เลือกเป็น utf-8 (ใน notepad หากเลือกเป็น unicode จะหมายถึง utf-16)\nเพื่อให้เห็นภาพรวมก่อนขอเริ่มด้วยโค้ดตั้งแต่เปิดไฟล์ ใช้ไฟล์ แล้วก็ปิดไฟล์\nf = open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) # เปิดไฟล์  print(f.read()) # อ่านไฟล์  f.close() # ปิดไฟล์ จบ ๓ ขั้นตอนสั้นๆ ผลที่ได้ก็คือข้อความจากภายในไฟล์นั้นทั้งหมดถูกแสดงผลออกมา\nต่อไปจะเริ่มอธิบายทีละส่วนอย่างละเอียด\nการเปิดไฟล์ ขั้นตอนแรกในการจัดการไฟล์ก็คือเปิดไฟล์ โดยใช้ฟังก์ชัน open\nf = open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) อาร์กิวเมนต์ ตัวแรกคือชื่อไฟล์ สามารถใส่แค่ชื่อไฟล์ถ้าหากอยู่ในโฟลเดอร์เดียวกับไฟล์โปรแกรมที่รัน แต่ถ้าไม่ใช่ก็ต้องใส่พาธไล่ตำแหน่งให้ถูก เช่นถ้าเก็บไว้ในโฟล์เดอร์ชื่อ xxx ซึ่งอยู่ที่เดียวกับไฟล์โปรแกรมก็ต้องใส่เป็น xxx/nishikaze.txt เป็นต้น สามารถใช้ได้ทั้งพาธสัมบูรณ์และพาธสัมพัทธ์\nส่วนอาร์กิวเมนต์ตัวที่สองซึ่งในที่นี้ใส่เป็น \u0026lsquo;r\u0026rsquo; นี้คือโหมดของการเปิดไฟล์ ซึ่ง r หมายถึงว่าเราจะเปิดไฟล์นี้ขึ้นมาเพื่ออ่าน\nโหมดในการเปิดไฟล์ซึ่งต้องระบุเป็นอาร์กิวเมนต์ตัวที่ ๒ ของฟังก์ชัน open นั้นมีอยู่หลากหลาย สามารถเลือกได้ดังนี้\n r เปิดเพื่ออ่านอย่างเดียว หากไม่มีไฟล์ชื่อนี้อยู่จะเกิดขัดข้องขึ้น r+ เปิดเพื่ออ่านและสามารถเขียนทับได้ หากไม่มีไฟล์ชื่อนี้อยู่จะเกิดขัดข้องขึ้น w เปิดเพื่อเขียนไฟล์ทับ หากไม่มีไฟล์ชื่อนี้อยู่จะเป็นการสร้างไฟล์ใหม่หากมีไฟล์อยู่แล้วก็จะเขียนทับ x เตรียมพื้นที่ว่างเพื่อจะเขียนไฟล์ เมื่อใช้โหมดนี้จะต้องไม่มีไฟล์ชื่อนี้อยู่ หากมีไฟล์ชื่อนี้อยู่แล้วจะเกิดขัดข้องขึ้น a เปิดเพื่อเขียนไฟล์ต่อ หากไม่มีไฟล์ชื่อนี้อยู่จะเป็นการสร้างไฟล์ใหม่ หากมีอยู่แล้วจะเป็นการเขียนต่อ  สรุปเป็นตารางเพื่อให้เข้าใจง่ายขึ้น\n   โหมด อ่าน เขียน หากไม่มีไฟล์อยู่เดิม หากมีไฟล์อยู่เดิม     r ได้ ไม่ได้ เกิดขัดข้อง เปิดอ่านได้   w ไม่ได้ ได้ สร้างไฟล์ใหม่ขึ้น ลบข้อมูลเก่าแล้วเขียนใหม่   a ไม่ได้ ได้ สร้างไฟล์ใหม่ขึ้น เขียนต่อจากที่มีอยู่เดิม   x ไม่ได้ ได้ สร้างไฟล์ใหม่ขึ้น เกิดขัดข้อง   r+ ได้ ได้ เกิดขัดข้อง เปิดอ่านได้ เมื่อเขียนจะเขียนต่อจากที่มีอยู่เดิม   w+ ได้ ได้ สร้างไฟล์ใหม่ขึ้น ลบข้อมูลเก่าแล้วเขียนใหม่   a+ ได้ ได้ สร้างไฟล์ใหม่ขึ้น เขียนต่อจากที่มีอยู่เดิม    นอกจากนี้ยังมีโหมดอื่นๆอีก เช่น b ซึ่งเป็นโหมดสำหรับเปิดไฟล์ชนิดไบนารี ซึ่งในที่นี้จะไม่พูดถึง หากไม่ได้ระบุโหมดจะถูกกำหนดเป็นโหมด r โดยอัตโนมัติ ดังนั้นหากจะเลือกโหมดอ่านไม่จำเป็นต้องใส่ ,r ก็ได้ ปล่อยว่างไว้เลย ดังนั้นจะเขียนแบบนี้ก็ได้\nf = open(\u0026#39;/Users/patn/Desktop/nishikaze.txt\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) ส่วนคีย์ encoding ที่ใส่ลงไปท้ายสุดนั้นเป็นการระบุว่าจะถอดรหัสแบบไหน ในที่นี้เลือก utf-8 ที่จริงแล้วคีย์ encoding อาจไม่จำเป็นต้องใส่หากว่าเครื่องเรากำหนดรูปแบบการถอดรหัสมาตรฐานเป็น utf-8 อยู่แล้ว ก็จะใส่แค่\nf = open(\u0026#39;/Users/patn/Desktop/nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;) อย่างไรก็ตามโดยทั่วไปอาจไม่เป็นแบบนั้น หากใส่ไปทั้ง ๆ แบบนี้ไฟล์จะถูกอ่านโดย ถอดรหัสเป็นแบบไหนก็ไม่รู้ ซึ่งก็ขึ้นอยู่กับเครื่องและระบบปฏิบัติการ มีปัจจัยมาเกี่ยวข้องด้วยมากมาย โดยปกติระบบจะกำหนดรูปแบบ การถอดรหัสมาตรฐานไว้ให้อยู่แล้ว หากไม่ได้แก้ไขเปลี่ยนแปลงอะไรไฟล์ก็จะถูกอ่านแบบนั้น เช่นบางเครื่องอาจเป็น cp874, cp932, cp1252 หรือ US-ASCII หรือบางเครื่องอาจเป็น utf-8 ก็เป็นได้\nหากบังเอิญรูปแบบการถอดรหัสมาตรฐานนี้ ไปตรงกับไฟล์ที่จะเซฟก็จะสามารถอ่านไฟล์ ได้โดยไม่มีปัญหาอะไร แต่เพื่อความปลอดภัยเพื่อให้สามารถรันได้กับทุกเครื่องแล้วระบุ encoding ไว้ตลอดดีที่สุด หากต้องการรู้ว่าเครื่องตัวเองรูปแบบการถอดรหัส มาตรฐานเป็นแบบไหนก็ทำได้โดยเรียกใช้ฟังก์ชัน getpreferredencoding ซึ่งอยู่ในมอดูล locale\nimport locale print(locale.getpreferredencoding()) ไฟล์ที่เปิดขึ้นมานั้นจะอยู่ในรูปของออบเจ็กต์ชนิดหนึ่งซึ่งออบเจ็กต์นี้จะต้องเอาตัวแปรมารับเพื่อที่จะนำไปใช้งานต่อไป ในที่นี้ใ้ชตัวแปร f มารับไฟล์ ต่อจากนี้ไปตัวแปร f ก็จะเป็นตัวแทนของไฟล์ที่เปิดขึ้นมา ซึ่งเราจะใช้เมธอดต่างๆเพื่อจัดการกับไฟล์ต่อไป\nการอ่านไฟล์ เมื่อเปิดมาแล้วขั้นตอนต่อไปก็คือการนำไฟล์มาอ่าน หรือก็คือการเอาข้อมูลภายในไฟล์มาใช้ คำสั่งที่ใช้ในการอ่านไฟล์มีอยู่หลายตัว ขอเริ่มจากวิธีที่ง่ายที่สุดก็คือใช้เมธอดที่ชื่อ read\nไฟล์ที่อ่านมานั้นโดยปกติจะเริ่มถูกอ่านจากข้อความแรกสุดไล่ไปเรื่อยๆจนจบ โดยระหว่างที่อ่านไป โปรแกรมจะมีการจำไว้ว่าอ่านถึงไหนแล้ว read เป็นเมธอดของออบเจ็กต์ของไฟล์ มีไว้สำหรับอ่านเอาข้อมูลที่มีอยู่ในไฟล์ตั้งแต่จุดที่อ่านไปถึงปัจจุบัน จนถึงสิ้นสุดไฟล์ โดยจะคืนค่าที่อ่านได้ออกมา ในที่นี้เราใช้ read ตั้งแต่เริ่ม จึงเป็นการอ่านไฟล์ ตั้งแต่ต้นรวดเดียวไปจนจบทั้งหมด\nและในที่นี้เราใช้คำสั่ง print เพื่อให้แสดงผลค่าที่อ่านได้ออกมาทันที ดังนั้นข้อความในไฟล์ทังหมดจึงถูกแสดงผลออกมาทันที และหลังจากเปิดไฟล์ขึ้นมา แล้วจัดการทำอะไรเสร็จเรียบร้อยแล้ว ขั้นตอนสุดท้ายก็คือปิดไฟล์ ซึ่งทำได้โดยเมธอด close\nการอ่านไฟล์ในตำแหน่งที่ต้องการ read นั้นถ้าไม่ได้ใส่อาร์กิวเมนต์อะไรลงไปจะเป็นการอ่านจนจบไฟล์ แต่ถ้าใส่ก็จะเป็นการอ่านจำนวนตัวอักษรเท่ากับจำนวนที่ระบุ\nf = open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) print(f.read(44)) f.close() แบบนี้จะได้ข้อความเฉพาะในบรรทัดแรกออกมา\nf = open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) while(1): s = f.read(50) if(s==\u0026#39;\u0026#39;): break #ถ้า s ว่างเปล่าแสดงว่าสิ้นสุดไฟล์อ่านไม่ได้แล้ว ให้หยุดวนซ้ำ  print(s) f.close() แบบนี้จะเป็นการอ่านไปทีละ ๕๐ ตัวจนกว่าจะจบ และจะเห็นได้ว่าเมื่อไฟล์ถูกเมธอด read อ่านไปจนจบแล้ว หากลองใช้คำสั่ง read อีกรอบผลที่ได้ก็คือจะได้สายอักขระเปล่า จะอ่านซ้ำอีกกี่รอบก็ยังคงว่างเปล่า แต่ก็ไม่ได้หมายความว่าไฟล์นี้จะไม่สามารถใช้อะไรได้แล้ว เราสามารถย้ายตำแหน่งที่อ่านได้อย่างอิสระด้วยเมธอด seek\nf.seek(0) แบบนี้จะเป็นการย้ายตำแหน่งที่อ่านไปยังจุดเริ่มต้นของไฟล์ พอทำแบบนี้แล้วก็สามารถใช้คำสั่ง read อ่านข้อความทั้งหมดได้อีกครั้ง เลข 0 ที่อยู่ในวงเล็บคือตำแหน่งของไฟล์ที่ต้องการอ่าน จะย้ายไปยังส่วนไหนของไฟล์ก็ได้ แต่ที่ต้องระวังก็คือหน่วยในการนับตำแหน่งภายในไฟล์ด้วย seek นั้นใช้เป็นหน่วยไบต์ไม่ใช่หน่วยตัวอักษรเหมือนอย่าง read และโดยทั่วไปแล้วตัวอักษรที่เป็น utf-8 นั้นจะมีจำนวนบิตในแต่ละอักษรไม่เท่ากัน อักษรที่ตรงกับ ASCII จะเป็น 1 ไบต์ แต่อักษรอื่นอาจเป็น 2 หรือ 3 ไบต์ ดังนั้นจึงนับจำนวนอักษรไปโดยตรงไม่ได้ สำหรับอักษรไทยนั้นเป็นอักษรที่ใช้ 3 ไบต์ ดังนั้นตัวหนึ่งจะคิดเป็น 3 หน่วย\nลองดูตัวอย่างอีกไฟล์ (ที่มา) ไฟล์ตัวอย่าง riki.txt บันทึกเป็น utf-8 เหมือนเดิม\nหากเปรียบโลกนี้เป็นนาฬิกาเรือนใหญ่ยักษ์ จะประกอบขึ้นจากฟันเฟืองไร้ชื่อจำนวนมหาศาลเพียงใดกัน ถึงกระนั้น แม้เพียงฟันเฟืองอันเล็กๆก็ตาม หากสั่งสมไปเรื่อยๆ ก็ย่อมทำให้โลกเปลี่ยนแปลงไปได้ทีละน้อย ลองพิมพ์\nf = open(\u0026#39;riki.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) f.seek(3) print(f.read()) f.close() ผลที่ได้ก็คือข้อความที่เหมือนที่อยู่ในไฟล์ยกเว้นแค่ตัดอักษรตัวแรกออกไป นั่นเพราะ f.seek(3) หมายความว่าเลื่อนตำแหน่งไป 3 ไบต์ ซึ่งหมายถึง 1 ตัวอักษรไทย และหากลองรันเหมือนเดิมโดยเพิ่มเลขเป็น 6, 9, 12 หรืออะไรที่หาร 3 ลงตัวไปเรื่อยๆก็จะพบว่าอักษรค่อยๆหายไปทีละตัว แต่หากเปลี่ยนตัวเลขเป็นอะไรที่หาร 3 ไม่ลงตัวเมื่อไหร่ก็จะขึ้นว่า\nUnicodeDecodeError: \u0026#39;utf-8\u0026#39; codec can\u0026#39;t decode byte 0xb8 in position 0: invalid start byte นั่นเพราะอักษรไทยประกอบด้วย 3 ไบต์ ถ้าหากไปอ่านในตำแหน่งครึ่งๆกลางๆมันก็จะไม่สามารถอ่านได้ แต่ปัญหายังมีอีก หากลอง f.seek(120) ก็จะพบว่ามีปัญหาเช่นกันแม้ว่าจะหาร 3 ลงตัว ที่เป็นแบบนี้เพราะบรรทัดแรกมีอักษรเพียง 39 ตัว ซึ่งคิดเป็นไบต์ที่ 117 และรหัสขึ้นบรรทัดใหม่นั้นคิดเป็น 1 ไบต์ ดังนั้นไบต์ที่ 117 จึงเป็นรหัสขึ้นบรรทัดใหม่ และอักษรตั้งแต่บรรทัดใหม่ก็จะเริ่มจาก 118 แล้วก็ตามด้วย 121, 124 ไปเรื่อยๆ ดังนั้นจะเห็นว่าการใช้ seek กับ utf-8 ในกรณีที่ไม่ใช่อักษร ASCII นั้นค่อนข้างลำบากทีเดียว\nดังนั้นแทนที่จะใช้ seek เพื่อไปยังตำแหน่งต่างๆในไฟล์ น่าจะใช้ seek แค่เพื่อกลับมายังจุดเริ่มต้น จากนั้นใช้ read เพื่ออ่านไล่ไปจนถึงข้อความตำแหน่งที่ต้องการจะดีกว่า เพราะ read นับจำนวนตามตัวอักษร หรือบางครั้งอาจเป็นการสะดวกกว่าหาก read ทั้งหมดเก็บไว้ในสายอักขระแล้วค่อยมาวิเคราะห์ภายในโปรแกรม เพราะสายอักขระในโปรแกรมจะนับลำดับตามตัวอักษรอยู่แล้ว ทำให้จัดการง่ายกว่า\nf = open(\u0026#39;riki.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) s = f.read() print(s[0:2]) # หา  print(s[34:39]) # ยักษ์  print(s[122:126]) # เล็ก  f.close() หากต้องการรู้ตำแหน่งว่าอ่านไปถึงไหนแล้วสามารถใช้เมธอด tell ซึ่งจะคืนค่าตำแหน่งที่อ่านไฟล์กลับมา แต่ก็เป็นหน่วยไบต์เช่นเดียวกับ seek\nการอ่านไฟล์แยกทีละบรรทัด โดยปกติแล้วการอ่านไฟล์นั้นจะนิยมอ่านแยกทีละบรรทัด เพราะข้อมูลก็มักจะเก็บแยกเป็นบรรทัดเพื่อความเป็นระเบียบเช่นกัน เมธอดที่ใช้ในการอ่านแยกบรรทัดมีอยู่ ๒ ตัวคือ readlines กับ readline\nreadlines เป็นการอ่านไฟล์ทั้งหมดเช่นเดียวกับ read แต่จะเก็บแยกเป็นบรรทัด\nf = open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) r = f.readlines() print(r) f.close() แบบนี้จะได้ว่าตัวแปร r เก็บข้อความจากไฟล์โดยแยกเป็นบรรทัด หากต้องการเข้าถึงบรรทัดไหนก็แค่ใส่ [ ] เช่น\nprint(r[1]) จะได้ข้อความบรรทัดที่ ๒ (เพราะบรรทัดแรกนับเป็น 0) โดยจะเห็นว่านบรรทัดถูกเว้น เครื่องหมายขึ้นบรรทัดใหม่ \\n ถูกรวมอยู่ในนี้ด้วย ส่วนอีกวิธีคือเมธอด readline เมธอดนี้คล้ายกับ readlines ชื่อก็คล้ายกัน ต่างกันแค่ s หายไปตัวเดียวเท่านั้น readline เป็นการอ่านข้อความทีละบรรทัด โดยการใช้ครั้งหนึ่งจะเป็นการอ่านบรรทัดหนึ่ง และพอใช้อีกครั้งก็จะอ่านซ้ำ และอ่านไปจนจบ\nf = open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) for i in range(5): r = f.readline() print(r) f.close() แบบนี้ก็จะได้ข้อความ ๕ บรรทัดแรก และหาก f.readline() อีกครั้งก็จะได้ข้อความบรรทัดที่ ๖ ออกมา\nการอ่านไฟล์ด้วย for นอกจากการอ่านไฟล์ด้วยเมธอดต่างๆแล้วมีอีกวิธีหนึ่งที่สามารถอ่านไฟล์ได้โดยไม่ จำเป็นต้องใช้เมธอดใดๆเลย นั่นคือใช้ for วนภายในออบเจ็กต์ตัวไฟล์\nf = open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) for r in f: print(\u0026#39;~~ \u0026#39;+r,end=\u0026#39;\u0026#39;) f.close() ผลที่ได้ก็คือไฟล์ถูกอ่านทีละบรรทัดและถูก print ในแต่ละรอบที่วน มองดูโค้ดแล้วอาจจะรู้สึกงงๆว่า f ซึ่งเป็นออบเจ็กต์ของไฟล์ถูกนำมาใช้เป็นตัววนภายในคำสั่ง for โดยตรงเลย แบบนี้ได้ด้วยหรือ ทั้งๆที่ปกติแล้วคำสั่ง for จะถูกใช้กับออบเจ็กต์ชนิดลำดับเช่นลิสต์, ทูเพิล, ดิกชันนารี ความจริงแล้วโค้ดนี้มีค่าเท่ากับ\nf = open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) for r in f.readlines(): # ต่างกันตรงบรรทัดนี้  print(\u0026#39;~~ \u0026#39;+r,end=\u0026#39;\u0026#39;) f.close() นั่นคือเมื่อออบเจ็กต์ของไฟล์ถูกใช้กับ for มันจะถูกตัดแบ่งเป็นบรรทัด แล้วถูกดึงข้อมูลมาอ่านทีละบรรทัด เหมือนการใช้เมธอด readlines\nการใช้ with จัดการไฟล์ ปกติแล้วหากใช้ฟังก์ชัน open จะต้องตามด้วยเมธอด close เพื่อปิดไฟล์ แต่ก็มีอีกวิธีที่สามารถทำได้แทนที่จะใช้ close นั่นคือใช้ with เพื่อกำหนดขอบเขตที่ไฟล์จะถูกเปิดใช้งาน ตัวอย่างที่แล้วหากเขียนด้วย with จะได้แบบนี้\nwith open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) as f: for r in f.readlines(): print(\u0026#39;~~ \u0026#39;+r,end=\u0026#39;\u0026#39;) จะเห็นว่าต่างกันแค่บรรทัดแรกตรง open ใช้ with แล้วบรรทัดต่อมาก็ต้องมีการร่นเข้ามา และไม่ต้องปิดท้ายด้วย close แล้ว ส่วนตรงที่ประกาศตัวแปรที่จะใช้แทนออบเจ็กต์ของไฟล์นั้น แทนที่จะใช้ f= ก็ใช้ as f แทน โครงสร้างโดยทั่วไปของการใช้ with กับ open คือ\nwith open() as `ชื่อตัวแปรที่จะเก็บออบเจ็กต์ของไฟล์`: `เนื้อหาส่วนที่จะใช้ไฟล์` การใช้โครงสร้างแบบนี้มีความหมายว่าไฟล์จะถูกเปิดอยู่เฉพาะในขอบเขตภายใน โครงสร้าง with นี้เท่านั้น พอหลุดจากตรงนี้ไปไฟล์จะถูกปิดไปโดยอัตโนมัติจึงไม่ต้อง close จะใช้วิธีไหนก็ไม่ต่างกันแต่บางคนชอบใช้วิธีนี้มากกว่าเพราะรับรองได้ว่าไฟล์จะ ถูกปิดหลังจากใช้เสร็จแน่นอน ไม่ต้องพะวงว่าจะลืมปิดท้ายด้วย close หรือในกรณีที่เกิดข้อผิดพลาดระหว่างดำเนินโปรแกรมจนทำให้หยุดทำงานไปก่อนที่จะไปถึง close แบบนี้ไฟล์ก็จะไม่ถูกปิด แต่หากใช้ with ต่อให้มีข้อผิดพลาดขึ้นมากลางคันไฟล์ก็จะถูกปิดแน่นอน ดังนั้นจึงปลอดภัยสบายใจกว่า จะเห็นว่าการเปิดไฟล์อ่านมีอยู่หลากหลายวิธี นอกจากที่กล่าวถึงไปนี้ก็ยังมีวิธีอื่นอีกด้วย เช่นใช้มอดูล linecache เป็นต้น\nสรุปเนื้อหา  การอ่านไฟล์ทำได้โดยการใช้คำสั่ง open เพื่อสร้างออบเจ็กต์ที่แทนตัวไฟล์ขึ้นมา จากนั้นใช้เมธอดต่างๆเพื่อจัดการกับไฟล์ แล้วก็ลงท้ายด้วยเมธอด close เพื่อปิด การเปิดไฟล์จำเป็นต้องกำหนดโหมดว่าจะอ่านหรือเขียน และควรระบุรูปแบบการเอนโค้ดตัวหนังสือ เมธอดที่ใช้อ่านดึงข้อมูลคือ read readline readlines หรืออาจใช้คำสั่ง for โดยไม่ใช้เมธอดก็ได้ ไฟล์จะถูกอ่านไล่ตั้งแต่ต้นจนจบ โดยมีการนับจำนวนตำแหน่งไปเรื่อยๆ เมธอด seek มีไว้ย้ายตำแหน่งที่อ่านไฟล์ไปยังจุดที่ต้องการ แต่ต้องระวังว่าหน่วยเป็นไบต์ สามารถใช้โครงสร้าง with เพื่อจัดการกับไฟล์ได้ ซึ่งจะไม่ต้องใช้ close เมื่อปิดไฟล์  Reference : https://phyblas.hinaboshi.com/tsuchinoko17\n"
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/phyblas/intermediate/write_files/",
	"title": "การเขียนข้อมูลลงไฟล์",
	"tags": [],
	"description": "",
	"content": "การเปิดไฟล์สำหรับเขียน การเขียนไฟล์นั้นก็เช่นเดียวกับการอ่านไฟล์ คือจะต้องเปิดไฟล์ขึ้นมาเสียก่อน เพียงแต่ต้องกำหนดโหมดการใช้งานเป็น w หรือ a แทนที่จะเป็น r แบบตอนอ่าน ที่อาจจะฟังดูแปลกหน่อย ก็คือแม้ว่าไฟล์ที่จะเขียนนั้นยังไม่ได้มีตัวตนอยู่ ก็ตาม แต่ก็ยังต้องใช้คำสั่ง open เพื่อเปิดอะไรที่ว่างเปล่านั้นขึ้น ซึ่งการเปิดในที่นี้นั้นเท่ากับเป็นการสร้างไฟล์ขึ้นมา หาก open ไฟล์ในโหมด w จะพบว่าไฟล์นั้นถูกสร้างขึ้นมาทันทีหากมันไม่ได้มีตัวตนอยู่แต่แรก\nf = open(\u0026#39;xxxx.txt\u0026#39;,\u0026#39;w\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) f.close() ลองไปดูจะพบว่ามีไฟล์ชื่อ xxxx.txt โผล่มาในโฟลเดอร์เดียวกับไฟล์โปรแกรม และภายในว่างเปล่าไม่มีอะไร โหมด w กับ a นั้นจะต่างกันตรงที่ว่าในกรณีที่ไฟล์เดิมมีตัวตนอยู่แล้วถ้าเป็นโหมด w ไฟล์จะถูกเขียนทับใหม่ทันที แต่ถ้าเป็น a จะเป็นการเขียนต่อจากไฟล์เดิม การเขียนไฟล์ก็ต้องเลือกรูปแบบการเอนโค้ดเช่นกัน ในที่นี้ใช้เป็น utf-8 เช่นเคย\nคำสั่งเขียนไฟล์ มี ๒ เมธอดที่ใช้ในการเขียนไฟล์ คือ write กับ writelines ข้อแตกต่างคือ write จะใช้กับสายอักขระอันเดียว แต่ writelines จะใช้กับลิสต์ของสายอักขระ กรณีที่ใช้กับสายอักขระเดียวยาวต่อเนื่อง จะใช้ write หรือ writelines ก็ได้เหมือนกันทั้งคู่\ns = \u0026#39;\u0026#39;\u0026#39;เวลาที่เข้าหาผู้อื่น ให้มีหัวใจที่อบอุ่นดั่งฤดูใบไม้ผลิ เวลาที่ทำงาน ให้มีหัวใจที่เร่าร้อนดั่งฤดูร้อน เวลาที่คิดอะไร ให้มีหัวใจที่แจ่มใสดั่งฤดูใบไม้ร่วง เวลาที่เผชิญหน้ากับตัวเอง ให้มีหัวใจที่เข้มงวดดั่งฤดูหนาว\u0026#39;\u0026#39;\u0026#39; f = open(\u0026#39;samejima.txt\u0026#39;,\u0026#39;w\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) f.write(s) #หรือ f.writelines(s)  f.close() (ที่มาของข้อความ)\nแต่ถ้ามีสายอักขระหลายๆอันแยกกันอยู่จะใช้ได้แต่ writelines เช่น\ns = [\u0026#39;เวลาที่เข้าหาผู้อื่น ให้มีหัวใจที่อบอุ่นดั่งฤดูใบไม้ผลิ\u0026#39;, \u0026#39;เวลาที่ทำงาน ให้มีหัวใจที่เร่าร้อนดั่งฤดูร้อน\u0026#39;, \u0026#39;เวลาที่คิดอะไร ให้มีหัวใจที่แจ่มใสดั่งฤดูใบไม้ร่วง\u0026#39;, \u0026#39;เวลาที่เผชิญหน้ากับตัวเอง ให้มีหัวใจที่เข้มงวดดั่งฤดูหนาว\u0026#39;] f = open(\u0026#39;samejima.txt\u0026#39;,\u0026#39;w\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) f.writelines(s) f.close() เพียงแต่ว่าจะไม่มีการเว้นบรรทัดให้ระหว่างสายอักขระแต่ละท่อน ถ้าต้องการก็ต้องเพิ่มเอาเอง ถ้าจะใช้ write ก็อาจใช้เป็น f.write('\\n\u0026rsquo;.join(s)) คือใช้เมธอด join เพื่อรวมสายอักขระเข้าด้วยกันโดยมีการขึ้นบรรทัดใหม่เป็นตัวแบ่ง หรืออาจจะเขียนต่อๆกันไปเลยก็ได้ การใช้คำสั่ง write หลายครั้งจะเป็นการเขียนต่อไปเรื่อยๆ โดยจะไม่มีการขึ้นบรรทัดใหม่ให้ดังนั้นต้องเติม \u0026lsquo;\\n\u0026rsquo; ไปด้วย\nfor a in s: f.write(a+\u0026#39;\\n\u0026#39;) สิ่งที่จะเขียนได้นั้นต้องเป็นสายอักขระเท่านั้น หากไม่ใช่สายอักขระก็ต้องแปลงก่อน\nตัวอย่าง โปรแกรมเขียนเลข 1 ถึง 10000 ลงไฟล์\nf = open(\u0026#39;10000.txt\u0026#39;,\u0026#39;w\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) for i in range(1,10001): f.write(\u0026#39;|%d|\u0026#39;%i) if(i%100==0): f.write(\u0026#39;\\n\u0026#39;) # ขึ้นบรรทัดใหม่ถ้านับถึง 100  f.close() แค่พิมพ์โค้ดสั้นๆแค่นี้ก็มีเลขโผล่ขึ้นมาถึงหมื่นภายในพริบตา ขนาดไฟล์หลายสิบกิโลไบต์ ลองคิดดูว่าถ้าเปลี่ยนจากหมื่นเป็นพันล้านจะเป็นอย่างไร เท่านี้ก็สามารถไปประยุกต์สร้างไวรัสอย่างง่ายๆได้แล้ว ลองเขียนโปรแกรมทำนองนี้แล้วส่งให้ไปรันในเครื่องคนอื่นก็จะเกิดไฟล์ขนาดใหญ่ขึ้นอย่างรวดเร็ว แค่คิดก็น่ากลัวแล้ว ตัวอย่างทั้งหมดนี้ใช้โหมด r คือพอเปิดไฟล์มาก็จะถูกลบทิ้งแล้วเริ่มเขียนใหม่ทันที ถ้าอยากให้ไฟล์เขียนต่อก็แค่เปลี่ยน r เป็น a เท่านั้น ลองทำดูกันได้\nการคัดลอกไฟล์ เมื่อสามารถเปิดอ่านและสามารถเขียนไฟล์ได้แล้ว ต่อไปสิ่งที่จะทำได้ตามมาอย่างไม่ยากก็คือการนำข้อมูลจากไฟล์หนึ่งคัดลอกไปลงในอีกไฟล์ ซึ่งก็คือการอ่านไฟล์หนึ่ง ดึงข้อมูลมา แล้วก็นำไปเขียนในอีกไฟล์ ลองดูตัวอย่าง\nf1 = open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) # เปิดไฟล์ต้นฉบับ  f2 = open(\u0026#39;nishikaze2.txt\u0026#39;,\u0026#39;w\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) # กำหนดไฟล์ใหม่ที่จะเขียน  a = f1.read() # นำข้อมูลจากไฟล์ต้นฉบับมาเก็บในตัวแปร  f2.write(a) # นำข้อมูลจากตัวแปรมาเขียนลงในไฟล์ใหม่  f1.close() # ปิดไฟล์ต้นฉบับ  f2.close() # ปิดไฟล์ที่เขียนเสร็จ เท่านี้ก็จะได้ไฟล์ใหมที่เหมือนกับไฟล์ต้นฉบับทุกประการ แต่ความจริงแล้วนอกจากนี้ยังมีอีกวิธีที่ง่ายกว่านั้น นั่นคือใช้ฟังก์ชัน copyfile ในมอดูล shutil\nimport shutil shutil.copyfile(\u0026#39;nishikaze.txt\u0026#39;, \u0026#39;nishikaze2.txt\u0026#39;) นอกจากนี้ยังมีฟังก์ชัน move เอาไว้ย้ายไฟล์\nimport shutil shutil.move(\u0026#39;nishikaze2.txt\u0026#39;, \u0026#39;nishikaze3.txt\u0026#39;) เท่านี้ข้อมูลจากไฟล์เดิมก็ย้ายไปอยู่ในไฟล์ชื่อใหม่ แค่การคัดลอกมาทั้งหมดอาจดูง่ายไปไม่ค่อยมีอะไร เราลองมาทำอะไรที่ต้องออกแรงมากกว่านั้นสักหน่อย ต่อไปเป็นการนำข้อความจากไฟล์ต้นฉบับมาแตกออกเป็นไฟล์ย่อยแบ่งทีละบรรทัด\nf = open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) # เปิดไฟล์ต้นฉบับ  i = 1 for r in f: # วนซ้ำเพื่อแยกวิเคราะห์ทีละบรรทัด  if(r==\u0026#39;\\n\u0026#39;): continue # หากบรรทัดไหนว่างเปล่าก็ข้ามไปเลย ไม่ต้องสร้างไฟล์ บรรทัดที่ว่างคือบรรทัดที่มีแต่ \\n คือคำสั่งขึ้นบรรทัดใหม่  fw = open(\u0026#39;n%02d.txt\u0026#39;%i,\u0026#39;w\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) # สร้างไฟล์ใหม่ ตั้งชื่อเป็น n ตามด้วยหมายเลข  fw.writelines(r) # เขียนข้อมูลที่อ่านได้ในบรรทัดนั้นลงไฟล์  fw.close() # ปิดไฟล์ที่เขียน  i += 1 f.close() # ปิดไฟล์ต้นฉบับ การจัดเก็บข้อมูลเพื่อใช้งาน โดยทั่วไปแล้วข้อมูลมักจะถูกจัดเก็บเป็นแถวๆอย่างเป็นระเบียบเพื่อให้อ่านง่ายและสะดวกต่อการใช้งาน เราอาจเก็บข้อมูลในลักษณะคล้ายตารางโดยแยกเป็นแถวและมีการเว้นวรรคระหว่างข้อมูลแต่ละตัว ยกตัวอย่าง เช่นสร้างระบบบันทึกคะแนนสอบโดยให้นักเรียนแต่ละคนป้อนคะแนนสอบแต่ละวิชาแล้วข้อมูลก็ถูกบันทึกลงไปเรื่อยๆ\nrahat = input(\u0026#39;ป้อนรหัสผู้สอบ: \u0026#39;) physics = input(\u0026#39;คะแนนฟิสิกส์: \u0026#39;) chemi = input(\u0026#39;คะแนนเคมี: \u0026#39;) chiwa = input(\u0026#39;คะแนนชีวะ: \u0026#39;) f = open(\u0026#39;khanaen.txt\u0026#39;,\u0026#39;a\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) f.write(\u0026#39;%s%s%s%s\\n\u0026#39;%(rahat,physics,chemi,chiwa)) f.close() แบบนี้พอรันโปรแกรมแต่ละครั้งก็จะมีข้อความขึ้นมาให้กรอกรหัส แตามด้วยคะแนนแต่ละวิชา เมื่อกรอกครบคะแนนก็จะถูกบันทึกลงไฟล์ สมมุติว่ามีนักศึกษามาบันทึกคะแนนแล้วทั้งหมด ๓ คน ไฟล์ก็จะออกมาในลักษณะนี้\n590001 90 76 84 590003 99 90 88 590007 80 92 100 ข้อมูลแบบนี้นำมาใช้งานได้ง่าย หากต้องการดึงข้อมูลคะแนนทั้งหมดมาวิเคราะห์ก็เปิดไฟล์ขึ้นมาอ่านแล้ว read แล้ว split แยกเอาแต่ละส่วน เช่นเอาข้อมูลที่ได้นี้มาหาค่าต่ำสุด สูงสุด และค่าเฉลี่ย\nf = open(\u0026#39;khanaen.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) physics = [] chemi = [] chiwa = [] for s in f: a = s.split() physics += [int(a[1])] chemi += [int(a[2])] chiwa += [int(a[3])] f.close() print(\u0026#39;คะแนนฟิสิกส์ ต่ำสุด=%d, สูงสุด=%d, เฉลี่ย=%.2f\u0026#39;%(min(physics),max(physics),sum(physics)/len(physics))) print(\u0026#39;คะแนนเคมี ต่ำสุด=%d, สูงสุด=%d, เฉลี่ย=%.2f\u0026#39;%(min(chemi),max(chemi),sum(chemi)/len(chemi))) print(\u0026#39;คะแนนชีววิทยา ต่ำสุด=%d, สูงสุด=%d, เฉลี่ย=%.2f\u0026#39;%(min(chiwa),max(chiwa),sum(chiwa)/len(chiwa))) บางครั้งตัวกั้นข้อมูลก็อาจใช้แท็บ \\t หรือในกรณีไฟล์ชนิด .csv จะกั้นด้วยจุลภาค , จะใช้เป็นอะไรก็ได้ แต่เวลาเปิดอ่านข้อมูลก็ต้องรู้และระบุตัวแยกให้ถูกต้อง\nสรุปเนื้อหา  การเขียนไฟล์ก็คล้ายกับการอ่านไฟล์ ต้องเปิดไฟล์ขึ้นมาก่อน โดยต้องเลือกโหมดเป็น w หรือ a w กับ a ต่างกันตรงที่ w เป็นการเขียนทับ ส่วน a เป็นการเขียนต่อ เมธอดที่ใช้เขียนคือ write และ writelines write ใช้กับสายอักขระ ส่วน writelines ใช้กับลิสต์ของสายอักขระ การคัดลอกไฟล์ทำได้โดยเปิดไฟล์ขึ้นมาอ่านแล้วเขียนใส่อีกไฟล์ หรือใช้ shutil.copyfile ก็ได้ สามารถใช้การอ่านและเขียนไฟล์เพื่อจัดการกับข้อมูลอย่างเป็นระบบได้  อ้างอิง\nhttp://docs.python.jp/3/library/functions.html\nhttp://diveintopython3-ja.rdy.jp/files.html\nhttp://www.ops.dti.ne.jp/ironpython.beginner/textfile.html\nhttp://www.yukun.info/blog/2008/09/python-file-write-writelines.html\nReference : https://phyblas.hinaboshi.com/tsuchinoko18\n"
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/phyblas/intermediate/create_function/",
	"title": "การสร้างฟังก์ชัน",
	"tags": [],
	"description": "",
	"content": "หลังจากที่ได้เห็นฟังก์ชันต่างๆมากมายที่เป็นพื้นฐานที่ใช้กันทั่วไปแล้ว ได้เวลาที่จะมาลองสร้างฟังก์ชันขึ้นมาใช้เอง ปกติเราจะสร้างฟังก์ชันขึ้นมาใช้ก็ต่อเมื่อพบว่ามีคำสั่งอะไรบางส่วนที่มีความเป็นระบบและต้องการนำมาใช้บ่อย ๆ เช่นถ้ามีชุดคำสั่งหนึ่งที่ยาวๆแล้วต้องถูกใช้บ่อยหลายครั้งภายในโปรแกรมของเรา หากเราเอาโค้ดตรงส่วนนั้นมาทำเป็นฟังก์ชันอันหนึ่งเราก็จะเขียนมันแค่ครั้งเดียว จากนั้นพอต้องใช้ชุดคำสั่งตรงนั้นเมื่อไหร่เราก็เรียกใช้ฟังก์ชันขึ้นมา\nพอทำแบบนี้ก็จะประหยัดแรงในการเขียน โค้ดโดยรวมจะดูสั้นลงมาก และเข้าใจง่ายขึ้น การสร้างฟังก์ชัน จะทำให้การเขียนโปรแกรมของเราดูมีระบบระเบียบขึ้นมามาก.\nการสร้างและเรียกใช้ฟังก์ชัน ฟังก์ชันในทางภาษาคอมพิวเตอร์ก็คล้ายกับฟังก์ชันในทางคณิตศาสตร์ คือใส่อาร์กิวเมนต์เข้าไปแล้วได้ผลลัพธ์เป็นค่าอะไรบางอย่างคืนกลับออกมา ตัวอย่างการสร้างฟังก์ชันและใช้งาน\ndef f(x): # นิยามฟังก์ชัน f ที่มีพารามิเตอร์เป็น x  return x**3+3*x**2+3*x+1 # ค่าคืนกลับของฟังก์ชัน  print(f(7)) # เรียกใช้ฟังก์ชัน ได้ 512  print(f(13)) # เรียกใช้ฟังก์ชัน ได้ 2744 คำสั่งที่ใช้ในการสร้างฟังก์ชันก็คือ def ซึ่งก็ย่อมาจาก definition ซึ่งแปลว่าการนิยามนั่นเอง คำสั่งนี้มีไว้นิยามฟังก์ชันขึ้นมา จากนั้นหลังคำว่า def ก็ใส่ชื่อของฟังก์ชันที่ต้องการ ในที่นี้ตั้งชื่อง่ายๆว่า f จากนั้นก็ตามด้วยวงเล็บซึ่งภายในบรรจุสิ่งที่เรียกว่า พารามิเตอร์ (parameter) ซึ่งก็คือตัวแปรที่จะรับเข้ามาและเป็นตัวกำหนดอะไรต่างๆภายในฟังก์ชัน\nการตั้งชื่อฟังก์ชันเป็นไปตามกฏการตั้งชื่อตัวแปรทั่วไป\nหลังชื่อฟังก์ชันและพารามิเตอร์แล้วก็จะตามด้วยโคลอน : จากนั้นก็ขึ้นบรรทัดใหม่โดยมีการร่น และภายในส่วนนั้นจะเป็นรายละเอียดของฟังก์ชัน สำหรับฟังก์ชันที่มี การคืนค่าคืนกลับนั้น ค่าคืนกลับกำหนดโดยคำสั่ง return โดยพิมพ์คำว่า return แล้วเว้นวรรคตามด้วยค่าที่ต้องการให้คืนกลับ ในตัวอย่างนี้ค่าคืนกลับคือผลการคำนวณทางคณิตศาสตร์ตามที่เราต้องการ\nการนิยามฟังก์ชันก็สิ้นสุดลงเพียงเท่านี้ การประกาศสร้างฟังก์ชันจะใส่ไว้ตรงไหนก็ได้ภายในตัวโปรแกรม คำสั่งที่อยู่ภายในฟังก์ชันจะไม่มีการทำงานจนกว่าจะถูกเรียกใช้\nการเรียกใช้ฟังก์ชันทำได้โดยพิมพ์ชื่อของฟังก์ชันตามด้วยวงเล็บที่ใส่ อาร์กิวเมนต์ที่สอดคล้องกับพารามิเตอร์ที่ของฟังก์ชันนั้นไว้ข้างใน คำว่าพารามิเตอร์นั้นมีความหมายใกล้เคียงกับอาร์กิวเมนต์ แต่พารามิเตอร์คือตัวแปรที่ใช้ตอนสร้างฟังก์ชัน แต่เวลาที่เรียกใช้ฟังก์ชันค่าที่ป้อนเข้าไปจะเรียกว่าอาร์กิวเมนต์\nในตัวอย่างนี้ใส่ค่าอาร์กิวเมนต์เป็น 7 จากนั้นค่านี้จะถูกนำไปแทนพารามิเตอร์ x ภายในฟังก์ชัน แล้วก็ถูกนำไปคำนวณแล้วได้ค่า 7**3+3*7**2+3*7+1 = 512 กลับออกมา หลังจากนั้นพอใส่อาร์กิวเมนต์เป็น 13 ก็ทำในลักษณะเดียวกัน แต่จะได้ผลลัพธ์ต่างกัน\nพารามิเตอร์อาจไม่จำเป็นต้องมีเลยก็ได้ ถ้าไม่ต้องการรับค่าอะไรมาใช้ในฟังก์ชัน แบบนั้นวงเล็บหลังชื่อฟังก์ชันก็เว้นว่างเป็น f() หรืออาจมีหลายตัว ซึ่งก็จะคั่นด้วยจุลภาค โดยที่เวลาเรียกใช้จะต้องใส่ลำดับของอาร์กิวเมนต์ให้ตรงกับพารามิเตอร์ที่สอดคล้องกันด้วย ตัวอย่าง สมการในทฤษฎีสัมพัทธภาพพิเศษของไอนสไตน์ E = mc^2 พลังงานเท่ากับมวลคูณความเร็วแสงกำลังสอง\ndef E(m,c): return m*c**2 m = 9.10938356e-31 # มวลอิเล็กตรอน  c = 2.99792458e8 # ความเร็วแสง  print(E(m,c)) # พลังงานจากมวลของอิเล็กตรอน ในการป้อนค่าให้พารามิเตอร์นั้นนอกจากใส่ในรูปแบบของอาร์กิวเมนต์แล้วก็ยังสามารถใส่ในรูปแบบคีย์เวิร์ดได้ด้วย\nprint(E(m=9.10938356e-31,c=2.99792458e8)) กรณีใช้คีย์เวิร์ดจะมีข้อดีคือสามารถสลับลำดับยังไงก็ได้ ไม่จำเป็นต้องเรียง ดังนั้นจะเขียนแบบนี้ก็ได้ผลเหมือนเดิม\nprint(E(c=2.99792458e8,m=9.10938356e-31)) หรือจะใส่ปนกันทั้งคีย์และอาร์กิวเมนต์ก็ได้ แต่ว่าอาร์กิวเมนต์ต้องขึ้นก่อนเสมอ\nprint(E(m,c=2.99792458e8)) แต่จะไม่สามารถใส่ตัวแรกเป็นคีย์เวิร์ดและตัวที่สองเป็นอาร์กิวเมนต์ได้ เพราะถ้ามีอาร์กิวเมนต์อยู่สักตัวจะถูกตีความว่าเป็นพารามิเตอร์ตัวแรกสุดก่อนแล้วไล่ลำดับมา\nprint(E(2.99792458e8,m=9.10938356e-31)) # ได้ TypeError: E() got multiple values for argument \u0026#39;m\u0026#39; กรณีนี้ 2.99792458e8 ถูกตีความเป็นค่า m ซึ่งเป็นพารามิเตอร์ตัวแรก พอมีการใส่คีย์เวิร์ด m= ลงไปอีกจึงกลายเป็นว่าได้ค่าซ้อนกัน จึงขัดข้องทันที ฟังก์ชันอาจไม่จำเป็นต้องมีการคืนค่าเสมอไป หากไม่มีการคืนค่าก็ไม่ต้องใส่คำสั่ง return ตัวอย่าง ฟังก์ชันที่จะพิมพ์ดอกจันตามจำนวนที่ป้อนเข้าไป\ndef daodaodao(x,y): # นิยามฟังก์ชัน พารามิเตอร์คือจำนวนดาวในแนวนอนและแนวตั้งตามลำดับ  for i in range(y): for j in range(x): print(\u0026#39;*\u0026#39;,end=\u0026#39;\u0026#39;) # พิมพ์ดอกจัน  print(\u0026#39;\u0026#39;) # ขึ้นบรรทัดใหม่  daodaodao(30,10) # เรียกใช้ สร้างดอกจันแถวละ ๓๐ ดอก จำนวน ๑๐ แถว การแตกลิสต์มาใช้เป็นอาร์กิวเมนต์ของฟังก์ชัน บางครั้งเราอาจเก็บข้อมูลที่จะนำมาใช้เป็นอาร์กิวเมนต์ของฟังก์ชันไว้ในรูปแบบของลิสต์ ซึ่งบางครั้งก็สะดวกกว่า กรณีแบบนี้แทนที่จะต้องมาไล่เขียนแจกแจงสมาชิกในลิสต์ สามารถแตกสมาชิกทั้งหมดของลิสต์มาใช้เป็นอาร์กิวเมนต์ได้โดยเติมดอกจัน หน้าตัวแปรลิสต์\ndef f(x,y,z): print((x**2+y**2+z**2)**0.5) xyz = [3,4,12] f(*xyz) # แทนที่จะต้องมาเขียน f(xyz[0],xyz[1],xyz[2])  # ได้ 13.0 จะใส่ลิสต์ปนกับข้อมูลเดี่ยวแบบนี้ก็ได้เช่นกัน\ndef f(x,y,z,t): print((x**2+y**2+z**2+t**2)**0.5) xyz = [3,4,12] t = 20 f(*xyz,t) วิธีการนี้จะใช้กับฟังก์ชันอะไรก็ได้ ไม่เพียงแต่ฟังก์ชันที่เราสร้างขึ้นเอง เช่นฟังก์ชัน print เองก็สามารถใช้ตัวแปรลิสต์ที่มีดอกจัน\nการใช้ดิกชันนารีเป็นคีย์เวิร์ด ในขณะที่ลิสต์สามารถใช้เป็นอาร์กิวเมนต์ได้ ดิกชันนารีก็สามารถใช้เป็นคีย์เวิร์ดได้ ซึ่งการใช้นั้นทำได้โดยใส่ดอกจันสองอันนำหน้าตัวแปรดิกชันนารี\ndef f(x,y,z): print((x**2+y**2+z**2)**0.5) xyz = {\u0026#39;x\u0026#39;:3,\u0026#39;y\u0026#39;:4,\u0026#39;z\u0026#39;:12} f(**xyz) # แทนที่จะใส่ f(xyz[\u0026#39;x\u0026#39;],xyz[\u0026#39;y\u0026#39;],xyz[\u0026#39;z\u0026#39;])  # ได้ 13.0 ในที่นี้ดิกชันนารี xyz มีคีย์เป็น x, y และ z คีย์แต่ละอันจะกลายมาเป็นคีย์เวิร์ดในฟังก์ชัน\nพารามิเตอร์แบบมีกี่ตัวก็ได้ ถ้านิยามฟังก์ชันโดยกำหนดพารามิเตอร์โดยทั่วไปแล้วจำนวนอาร์กิวเมนต์หรือคีย์เวิร์ดที่ใช้ในฟังก์ชันจะตายตัวอยู่แล้ว แต่ในบางสถานการณ์ก็อาจจะต้องการส่งค่าจำนวนมากเข้าฟังก์ชันโดยที่ไม่รู้ว่าจะ มีกี่ตัว ซึ่งสามารถทำได้โดยใช้ * หรือ ** กับพารามิเตอร์ กรณีใช้ดอกจันอันเดียว * ตัวแปรนั้นจะเก็บค่าอาร์กิวเมนต์ในรูปของลิสต์ ตัวอย่าง ผลบวกกำลังสองของอาร์กิวเมนต์ทุกตัวที่ใส่ลงไป\ndef f(*arg): a = 0 for x in arg: a += x**2 a **= 0.5 print(a) f(3,4,12) # ได้ 13.0  f(7,24,60) # ได้ 65.0 กรณีใช้ดอกจันสองอัน ** ตัวแปรนั้นจะเก็บค่าคีย์เวิร์ดในรูปของดิกชันนารี\ndef f(**kw): print((kw[\u0026#39;x\u0026#39;]**2+kw[\u0026#39;y\u0026#39;]**2+kw[\u0026#39;z\u0026#39;]**2)**0.5) f(x=3,y=4,z=12) # ได้ 13.0 พารามิเตอร์ที่มี * และ ** สามารถใช้ปนกันกับพารามิเตอร์ธรรมดาได้ แต่ต้องวางไว้ข้างหลัง\ndef f(t,**kw): print((kw[\u0026#39;x\u0026#39;]**2+kw[\u0026#39;y\u0026#39;]**2+kw[\u0026#39;z\u0026#39;]**2+t**2)**0.5) f(x=7,y=24,z=60,t=156) # ได้ 169.0 โดยในกรณีนี้เฉพาะ t เท่านั้นที่มีกำหนดพารามิเตอร์แยกไว้ต่างหาก ดังนั้นจะไม่ถูกนำมารวมใน kw ด้วย หากใช้ปนกันทั้งพารามิเตอร์ธรรมดาและที่มี * และ ** ก็จะต้องเรียงเอาพารามิเตอร์ธรรมดาไว้ก่อน แล้วค่อยตามด้วย * แล้วค่อย **\ndef f(t,*arg,**kw): a = 0 for x in arg: a += x**2 a **= 0.5 print((a**2+kw[\u0026#39;x\u0026#39;]**2+kw[\u0026#39;y\u0026#39;]**2+t**2)**0.5) f(12,15,16,x=36,y=48) # ได้ 65.0 กรณีนี้ t จะเป็น 12 ส่วน arg จะเป็น [15,16] และ kw เป็น {'x':36,'y':48}\nค่าตั้งต้นของตัวแปรในฟังก์ชัน บางครั้งฟังก์ชันก็ไม่จำเป็นจะต้องรับค่าอาร์กิวเมนต์หรือคีย์เวิร์ดให้ ครอบคลุมทุกพารามิเตอร์ที่กำหนดไว้ หากฟังก์ชันมีการกำหนดค่าตั้งต้นของพารามิเตอร์ไว้\nให้ลองนึกถึงฟังก์ชันบางตัวที่โปรแกรมมีอยู่แล้ว เช่น open สำหรับเปิดไฟล์ (บทที่ ๑๗) โดยปกติแล้วจะต้องเลือกโหมดว่าจะอ่านหรือเขียน คือเป็น r, w, a หรืออื่นๆ แต่หากไม่ใส่เลยก็จะเป็น r ไปโดยอัตโนมัติ หรืออย่างฟังก์ชัน print ที่กำหนดตัวปิดท้ายเป็นการขึ้นบรรทัดใหม่ \u0026quot;\\n\u0026quot; ไปโดยอัตโนมัติ ยกเว้นว่าเราจะใส่คีย์เวิร์ด end= เพิ่มเข้าไป\nการกำหนดค่าตั้งต้นให้พารามิเตอร์ทำได้โดยใส่ค่าไปตอนที่ประกาศพารามิเตอร์ คือในวงเล็บหลังฟังก์ชัน ค่าตั้งต้นนี้จะถูกใช้เฉพาะในกรณีที่ไม่มีการป้อนค่าให้พารามิเตอร์\nตัวอย่าง พ่อค้าคนหนึ่งมีสินค้าอยู่ ๔ ชนิด แต่ละชนิดราคาไม่เท่ากัน บางวันบางอันก็ขายดีบ้างไม่ดีบ้าง จะหารายได้ที่ได้ในแต่ละวัน\ndef raidai(a=0,b=0,c=0,d=0): print(a*200+b*300+c*400+d*500) raidai(b=15,c=20) # มี b และ c ได้ 12500  raidai(15,20,10) # มี a, b และ c ได้ 13000  raidai(15,20,d=10) # มี a, b และ d ได้ 14000  raidai() # ไม่มีอะไรเลย ได้ 0 ในตัวอย่างนี้จะเห็นว่าใส่ค่าให้ตัวแปร a b c d ไม่ครบแต่ฟังก์ชันก็ทำงานได้ตามปกติ โดยตัวแปรไหนที่ไม่ได้รับค่าก็จะเป็น 0 ซึ่งเป็นไปตามค่าที่กำหนดตั้งต้นไว้ กรณีที่ใส่เป็นอาร์กิวเมนต์ พารามิเตอร์ตัวแรกๆจะได้ค่าไปก่อน ถ้าอยากให้ตัวหลังๆมีค่าในขณะที่ตัวแรกๆไม่มีก็ต้องใช้คีย์เวิร์ดเท่านั้น\nการคืนกลับข้อมูลเป็นกลุ่ม โดยปกติแล้วฟังก์ชันที่มีค่าคืนกลับจะคืนค่าได้เพียงตัวเดียวเท่านั้น เพราะพอเจอคำสั่ง return แล้วการทำงานของฟังก์ชันจะสิ้นสุดลงทันที ไม่สามารถ return หลายครั้งได้\nแต่หากต้องการให้คืนกลับหลายตัวก็ทำได้ด้วยการให้คืนกลับเป็นข้อมูลชนิดกลุ่ม เช่นลำดับ, ทูเพิล, ดิกชันนารี ตัวอย่าง ฟังก์ชันที่คืนค่า x ยกกำลังตั้งแต่ 1 ไปจนถึงยกกำลัง n\ndef yok(x,n): return [x**i for i in range(1,n+1)] print(yok(2,12)) # ได้ [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096]  print(yok(3,7)) # ได้ [3, 9, 27, 81, 243, 729, 2187] ขอบเขตของตัวแปร ปกติแล้วหากในฟังก์ชันมีการสร้างตัวแปรขึ้นมา ตัวแปรนั้นจะหายไปทันทีที่จบการใช้งานฟังก์ชันนั้น หากเรียกใช้ตัวแปรนั้นหลังจากนั้นก็จะพบว่ามันไม่มีตัวตนอยู่แล้ว ไม่สามารถใช้งานได้\ndef baba(): c = 1 baba() print(c) # ได้ NameError: name \u0026#39;c\u0026#39; is not defined หากต้องการให้ตัวแปรที่ถูกนิยามภายในฟังก์ชันั้นคงอยู่ต่อไปแม้ฟังก์ชันจะทำงาน จบลงแล้ว แบบนี้จะต้องใช้คำสั่ง global เพื่อประกาศว่าตัวแปรนั้นเป็นตัวแปรสากล สามารถใช้ได้ทั้งโปรแกรม การประกาศนั้นต้องทำการที่จะป้อนค่าให้ตัวแปร\ndef baba(): global c c = 1 baba() print(c) # ได้ 1 นอกจากนี้ global ยังใช้ในกรณีที่ต้องการให้ตัวแปรที่นิยามจากนอกฟังก์ชัน สามารถแก้ไขเปลี่ยนแปลงค่าภายในฟังก์ชันได้ โดยปกติแล้วกรณีที่ตัวแปรภายในฟังก์ชัน ชื่อซ้ำกับนอกฟังก์ชันจะถือว่าเป็น ตัวแปรคนละตัวเดียวกัน และการกระทำภายในฟังก์ชันนั้น จะเป็นการทำกับตัวแปรภายในฟังก์ชัน ไม่ส่งผลต่อตัวแปรนอกฟังก์ชัน\ndef baba(): a = 3 # กำหนดค่าตัวแปร a ขึ้นมาใหม่ ไม่เกี่ยวกับนอกฟังก์ชัน  print(a) # ได้ 3  a = 2 baba() print(a) # ได้ 2 เพราะไม่ได้รับผลจากการเปลี่ยนแปลงค่าที่เกิดในฟังก์ชัน แต่ในกรณีที่ภายในฟังก์ชันไม่ได้กำหนดตัวแปรชื่อเดียวกันอยู่ ตัวแปรภายในฟังก์ชันนั้น จึงเป็นตัวแปรที่ถูกนิยามจากภายนอก\ndef baba(): print(a) # แสดงผลค่า a ซึ่งกำหนดจากนอกฟังก์ชัน  a = 2 baba() สรุปคือเวลาที่มีการเรียกใช้ตัวแปรภายในฟังก์ชัน โปรแกรมจะทำการหาว่ามีตัวแปรชื่อนั้น อยู่ภายในฟังก์ชันหรือเปล่าก่อน ถ้ามีก็ใช้ตัวแปรนั้น แต่ถ้าไม่มีจึงไปหานอกฟังก์ชัน\nข้อควรระวังคือ หากมีการป้อนค่าให้กับตัวแปรภายในฟังก์ชัน โปรแกรมจะถือว่าตัวแปรนั้น เป็นตัวแปรในฟังก์ชัน หากมีการเรียกใช้ก่อนส่วนที่ให้ค่าจะขัดข้องทันที\ndef baba(): print(a) # ถูกเรียกใช้ก่อนป้อนค่า  a = 3 a = 2 baba() # ได้ UnboundLocalError: local variable \u0026#39;a\u0026#39; referenced before assignment หากต้องการให้ตัวแปรสามารถทั้งใช้และเปลี่ยนแปลงค่าได้ภายในฟังก์ชันจำเป็นต้องใช้คำสั่ง global ตัวอย่าง\ndef baba(): global b a=1 b=1 a=2 b=2 baba() print(a) # ได้ 2  print(b) # ได้ 1 ในนี้จะเห็นว่ามีการกำหนดค่าให้ทั้ง a และ b ๒ ที่คือทั้งในและนอกฟังก์ชัน ที่ต่างกันคือ b มีการกระกาศ global แต่ a ไม่มี ซึ่งทำให้ค่า b ภายในฟังก์ชันกลายเป็นตัวเดียวกับ b นอกฟังก์ชัน\nความเปลี่ยนแปลงค่าของตัวแปรที่ถูกใช้เป็นอาร์กิวเมนต์ โดยปกติแล้วค่าของตัวแปรที่ถูกใช้เป็นอาร์กิวเมนต์ของฟังก์ชันจะไม่มีการ เปลี่ยนค่า เพราะฟังก์ชันแค่ดึงค่าของตัวแปรไปใช้เพื่อทำอะไรบางอย่าง หากต้องการใช้ฟังก์ชัน เพื่อให้ตัวแปรมีการเปลี่ยนแปลงค่าจะไม่สามารถทำได้ โดยตรงแต่ต้องใช้ = กับฟังก์ชันอีกที เช่น\ndef f(x): return x+1 x = f(x) แบบนี้ x จะมีค่าเพิ่มขึ้นมา 1 อย่างไรก็ตาม หากตัวแปรที่เป็นอาร์กิวเมนต์คือลิสต์ ความเปลี่ยนแปลงอาจเกิดขึ้นกับสมาชิกในลิสต์ได้ ในกรณีที่มีการป้อนค่าใหม่ให้สมาชิกนั้นโดยตรงในฟังก์ชัน\ndef plian(s): s[0] = \u0026#39;k\u0026#39; s[3] = \u0026#39;ng\u0026#39; listA = [\u0026#39;ก\u0026#39;,\u0026#39;ข\u0026#39;,\u0026#39;ค\u0026#39;,\u0026#39;ง\u0026#39;] plian(listA) print(listA) # ได้ [\u0026#39;k\u0026#39;, \u0026#39;ข\u0026#39;, \u0026#39;ค\u0026#39;, \u0026#39;ng\u0026#39;] ที่เป็นอย่างนี้เพราะตัวแปรลิสต์นั้นมีหน้าที่ชี้ตำแหน่งของตัวแปร แม้ว่าตัวแปรลิสต์ภายในกับภายนอกฟังก์ชันจะเป็นคนละตัวกัน แต่การที่ฟังก์ชันรับค่าลิสต์นั้นมาก็เท่ากับว่ารับเอาตำแหน่งที่ถูกชี้นั้นมา ดังนั้นลิสต์ภายในและนอกฟังก์ชันจะชี้ไปที่ตัวแปรตัวเดียวกัน เมื่อมีการแก้ไขค่าตัวแปรนั้นก็จะเปลี่ยนแปลงตามไปด้วย แต่ว่าถ้าหากเป็นการป้อนค่า ให้กับลิสต์นั้นเท่ากับเป็นการแก้ตัวลิสต์ทั้งลิสต์ ไม่ได้เป็นการแก้ตัวแปรที่ถูกลิสต์ชี้อยู่ ดังนั้นค่าในลิสต์เดิมจะไม่มีการเปลี่ยนแปลงไป\ndef plian2(s): s = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;] return s listA = [\u0026#39;ก\u0026#39;,\u0026#39;ข\u0026#39;,\u0026#39;ค\u0026#39;,\u0026#39;ง\u0026#39;] plian2(listA) print(listA) # ได้ [\u0026#39;ก\u0026#39;, \u0026#39;ข\u0026#39;, \u0026#39;ค\u0026#39;, \u0026#39;ง\u0026#39;] อ้างอิง\n http://docs.python.jp/3/reference/compound_stmts.html http://www.python-izm.com/contents/application/function.shtml http://www.geocities.jp/m_hiroi/light/python02.html http://www.ops.dti.ne.jp/ironpython.beginner/argskw.html   Reference : https://phyblas.hinaboshi.com/tsuchinoko19\n "
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/phyblas/intermediate/recursive_function/",
	"title": "ฟังก์ชันเวียนเกิด",
	"tags": [],
	"description": "",
	"content": "ฟังก์ชันเวียนเกิด (Recursive Function) คือฟังก์ชันที่มีการคืนค่าเป็นตัวฟังก์ชันนั้นเอง ทำให้ต้องมีการเรียกใช้ตัวฟังก์ชันนั้นซ้ำ และในฟังก์ชันที่เรียกซ้ำนั้น ก็มีการเรียกฟังก์ชันเดิมซ้ำอีก วนเวียนอย่างนี้ไปเรื่อยๆ จนถึงจุดหนึ่ง จะมีเงื่อนไขที่ทำให้ฟังก์ชันนั้นคืน ค่ากลับโดยที่ไม่ต้องเรียกฟังก์ชันซ้ำอีก การวนซ้ำจึงหยุดลง อธิบายด้วยคำพูดแบบนี้ยังไงก็คงจะยังเข้าใจยากอยู่ มาดูตัวอย่างน่าจะช่วยให้เห็นภาพชัดกว่า\nแฟ็กทอเรียล ฟังก์ชันแฟ็กทอเรียลนั้นเป็นหนึ่งในตัวอย่างที่ง่ายที่สุดของการใช้ฟังก์ชันเวียนเกิด\nลองดูตัวอย่างการใช้ สร้างฟังก์ชัน fac(x) = x! = 1×2×3×...×x\ndef fac(x): if(x\u0026gt;1): return fac(x-1)*x else: return 1 print(fac(6)) # ได้ 720 จะเห็นว่าฟังก์ชัน fac ในที่นี้มีการเรียกตัวมันเองคือฟังก์ชัน fac ซ้ำอีกภายในนั้น การเรียกซ้ำนี้จะเกิดขึ้นตราบใดที่ยังมากกว่า 1 แต่ถ้าเป็น 1 จะคืนค่า 1 โดยไม่มีการเรียกซ้ำ ลองนึกตามทีละขั้น สมมุติเราเรียกใช้ฟังก์ชันโดยใส่อาร์กิวเมนต์เป็น 1 คือ fac(1)\nแบบนี้ฟังก์ชันจะเข้า else ทันทีเพราะ x เป็น 1 ดังนั้นจึงคืนค่า 1 กลับมา ซึ่งเป็นไปตามที่ควรจะเป็น\nต่อไปลองคิดกรณี fac(2) กรณี นี้เมื่อเรียกใช้ x=2 จะเข้าเงื่อนไขแรก ซึ่งจะต้อง return fac(x-1)*x ทำให้มีการเรียกใช้ฟังก์ชันนั้นซ้ำ แต่คราวนี้อาร์กิวเมนต์ต่างไปโดยลดลงไป 1 เป็น x-1 ก็คือเหลือ 1 ซึ่งจะคืนค่า 1 กลับมา จากนั้นก็ถูกนำไปคูณกับ x ก็คือ 2 ดังนั้นผลที่ได้ก็คือได้ 2\nคิดต่อไป กรณี fac(3)\nเมื่อ เรียกใช้ x=3 จะเข้าเงื่อนไขแรก เรียก return fac(x-1)*x เมื่อแทนค่า x จะได้เป็น return fac(2)*3 ซึ่ง fac(2) ก็รู้ค่าแล้วจากกรณี x=2 ว่าเป็น 2 ดังนั้นเอามาคูณกันก็ได้ผลลัพธ์เป็น 6\nกรณี x=4 ก็จะ return fac(3)*4 จึงได้ผลเป็น 24\nกรณี x=5 ก็จะ return fac(4)*3 จึงได้ผลเป็น 120\nกรณี x=6 ก็จะ return fac(5)*4 จึงได้ผลเป็น 720\nเป็นอย่างนี้ซ้ำไปเรื่อยๆเป็นจำนวนครั้งตามค่าของ x ที่ใส่ลงไป เพราะเมื่อเรียกใช้ฟังก์ชัน ภายในฟังก์ชันจะมีการเรียกฟังก์ชันเดิมซ้ำด้วย x ที่ต่ำลงไปทีละขั้น พอเรียกซ้ำก็จะเรียก x ที่ต่ำลงไปเรื่อยๆจนในที่สุดก็เป็น 1 และไม่มีการเรียกซ้ำอีก\nสุดท้ายผลที่ได้จึงเป็นการคูณสะสมเพิ่มไปเรื่อยๆ กลายเป็นฟังก์ชันแฟ็กทอเรียลตามที่ต้องการ หากจะลองเขียนเป็นฟังก์ชันธรรมดาที่ไม่ต้องมีการเวียนเกิดก็สามารถทำได้โดยใช้การวนทำซ้ำ ลองเปรียบเทียบกันดู\ndef fac(x): f = 1 # ตั้งต้นที่ 1  for i in range(2,x+1): # ใช้ for วนซ้ำ ไล่ตั้งแต่ 2  f = f*i # คูณเพิ่มไปเรื่อยๆ  return f # คืนผลลัพธ์ที่ได้กลับไป  print(fac(6)) ข้อดีข้อเสียของการใช้ฟังก์ชันแบบเวียนเกิดเมื่อเทียบกับการไม่ใช้ ข้อดี\n หากใช้ได้คล่องแล้วจะมองปัญหาออกได้ง่ายขึ้น เข้าใจง่ายกว่า เขียนแล้วดูสั้นกว่า ง่ายกว่ามากในกรณีที่มีการทำซ้ำซ้อนกันเป็นวังวนในจำนวนที่ไม่แน่นอน  ข้อเสีย\n เปลืองหน่วยความจำมากกว่า ในบางกรณีอาจทำงานช้ากว่า  สรุปก็คือวิธีการนี้ไม่ได้ทำให้โปรแกรมทำงานเร็วขึ้น แถมอาจช้าลงอีก เพียงแต่ในบางปัญหาจะทำให้ดูเรียบง่ายขึ้น เขียนฟังก์ชันสั้นเกินคาดทั้งๆที่น่าจะซับซ้อน ดังนั้นที่สำคัญคือมองปัญหาให้ออกว่าเวลาไหนควรจะใช้ เลือกใช้ตามความเหมาะสม เพื่อให้เห็นภาพชัดลองดูตัวอย่างอื่นเปรียบเทียบกันอีก\nฟีโบนัชชี ลำดับฟีโบนัชชี (Fibonacci) คือลำดับที่มีสมาชิก ๒ ตัวแรกมีค่าเท่ากับ 1 นอกนั้นตัวถัดไปจะมีค่าเท่ากับสองตัวก่อนหน้าบวกกัน\n1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, ... ลองมาเขียนเป็นฟังก์ชันในไพธอนดู\ndef fib(x): if(x\u0026gt;2): return fib(x-1)+fib(x-2) else: return 1 print(fib(8)) จะเห็นว่าฟังก์ชันนี้มีการกำหนดเงื่อนไขตามที่ได้กล่าวข้างต้น คือถ้า x เป็นตัวที่ 1 หรือ 2 จะมีค่าเป็น 1 แต่ถ้าเป็นตัวถัดจากนั้นจะมีค่าเท่ากับสองตัวก่อนหน้าบวกกัน ฟังก์ชันแบบนี้ถ้าไม่ใช้เป็นแบบเวียนเกิด ใช้การวนซ้ำธรรมดาจะเป็นอย่างไร\ndef fib(x): a = 1 b = 1 f = 1 for i in range(3,x+1): f = a+b a = b b = f return f print(fib(8)) คราวนี้จะเห็นว่าใช้ฟังก์ชันแบบเวียนเกิดดูแล้วการเขียนดูเรียบง่ายกว่าพอสมควร แต่อย่างไรก็ตาม ภายใต้ความเรียบง่ายของมัน ก็แฝงไปด้วยความน่ากลัว ลองพิจารณาดูจะเห็นว่ากรณีใช้ฟังก์ชันเวียนเกิดนั้นเมื่อเรียกใช้ฟังก์ชันครั้ง หนึ่งจะมีการเรียกตัวมันเองถึง ๒ ครั้ง คือ fib(x) จะมีการเรียก fib(x-1) และ fib(x-2) ขึ้นมา และภายในนั้น fib(x-1) ก็จะทำการเรียก fib(x-2) และ fib(x-3) ส่วน fib(x-2) ก็ไปเรียก fib(x-3) กับ fib(x-4) แล้วก็วนเรียกซ้ำเพิ่มไปเรื่อยๆ จำนวนครั้งที่เรียกมีแต่จะเพิ่มขึ้นเรื่อยๆเป็นทวีคูณ\nการเรียกในแต่ละครั้งเป็นการคำนวณใหม่ทุกครั้ง แม้ว่า fib(x-2) จะถูกเรียกซ้ำ 2 ครั้ง fib(x-3) ถูกเรียกซ้ำ 3 ครั้ง แต่มันก็ไม่ได้เก็บค่าเดิมเอาไว้ แต่กลับคำนวณใหม่แยกกัน ผลก็คือเครื่องทำงานหนักและประสิทธิภาพการทำงานต่ำ ในขณะที่ถ้าใช้ for วนซ้ำธรรมดา ตัวแปรมีการเก็บค่าเสร็จแล้วก็นำมาใช้แล้วล้างใหม่ทุกรอบ พอเป็นแบบนี้แล้วเครื่องจึงทำงานเบากว่ามาก\nสรุป กรณีนี้ฟังก์ชันเวียนเกิดเขียนง่ายแต่ประสิทธิภาพแย่ ฟิโบนัชชีจึงเป็นตัวอย่างของกรณีที่ไม่ควรจะใช้ บางครั้งการเขียนสั้นไม่ได้แปลว่าเป็นโปรแกรมที่ดี ต้องพิจารณาด้วยว่าโปรแกรมมีการทำงานอย่างไรอยู่เบื้องหลังคำสั่งนั้น\nฟังก์ชันสำหรับยุบลิสต์ ลองดูตัวอย่างการใช้ที่ไม่ได้เกี่ยวข้องกับฟังก์ชันทางคณิตศาสตร์กันบ้าง ตัวอย่างหนึ่งที่จะช่วยให้เห็นว่าใช้ฟังก์ชันเวียนเกิดแล้วง่ายก็คือการยุบลิสต์ สมมุติว่ามีลิสต์หน้าตาซับซ้อนแบบนี้อยู่ [[['a','b'],['c','d']],[['e','f'],['g',['h','i']]],['j','k'],'l']\nจะเห็นว่าเป็นลิสต์ซ้อนกันหลายชั้น สูงสุดคือ h กับ i นี้ซ้อนอยู่ในชั้นที่ ๔ คือเป็นลิสต์ในลิสต์ในลิสต์ในลิสต์ เราจะทำให้ทั้งหมดนี้มาอยู่ในลิสต์อันเดียว คือกลายเป็น ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l'] สามารถทำได้ด้วยการสร้างฟังก์ชันเวียนเกิด\ndef yup(l): y = [] # สร้างลิสต์เปล่าขึ้นมาก่อน  for c in l: if(type(c)==list): # ตรวจชนิดของสมาชิกว่าเป็นลิสต์หรือเปล่า  y += yup(c) # ถ้าเป็นลิสต์ให้เรียกฟังก์ชันซ้ำเพื่อยุบก่อนค่อยเพิ่มเข้าไป  else: y += [c] # ถ้าไม่ใช่ลิสต์ให้เพิ่มเข้าไปในสมาชิก  return y # คืนค่าลิสต์ที่ได้  lia = [[[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;],[\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;]],[[\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;],[\u0026#39;g\u0026#39;,[\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;]]],[\u0026#39;j\u0026#39;,\u0026#39;k\u0026#39;],\u0026#39;l\u0026#39;] print(yup(lia)) ในนี้จะเห็นว่าฟังก์ชัน yup มีการเรียกใช้ตัวมันเองในกรณีที่สมาชิกเป็นลิสต์ เพื่อให้ลิสต์นั้นยุบก่อนที่จะบวกเพิ่มเข้าไป ถ้าภายในลิสต์นั้น มีลิสต์อยู่อีกจึงทำการเรียกตัวเองซ้ำอีก ปัญหานี้ยากที่จะใช้การวนซ้ำด้วย for เพราะเราไม่รู้ว่าจะต้องมีวังวนซ้อนอยู่กี่ชั้น\nหอคอยฮานอย ตัวอย่างปัญหาอีกอย่างที่ดูเหมือนจะยากแต่ถ้าใช้ฟังก์ชันเวียนเกิดจะดูแล้วง่ายลงไปทันที\nรายละเอียดเขียนไว้ใน https://phyblas.hinaboshi.com/20160301\nอ้างอิง\nhttp://www2.cc.niigata-u.ac.jp/~takeuchi/tbasic/BackGround/Recursive.html\n Reference : https://phyblas.hinaboshi.com/tsuchinoko20\n "
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/learning-python/20_classes/",
	"title": "21. Classes &amp; Objects",
	"tags": [],
	"description": "",
	"content": "ในบทนี้ คุณได้เรียนรู้เกี่ยวกับโมดูลในภาษา Python และได้ทราบว่าการใช้งานโมดูลนั้นสามารถช่วยแบ่งโค้ดออกเป็นส่วนๆ และเรียกใช้งานได้เมื่อต้องการ เราได้พูดถึงการสร้างและการใช้งานโมดูลโดยการนำเข้าโมดูลด้วยคำสั่ง import และคำสั่ง from import การจัดหมวดหมู่ของโมดูลด้วย Package นี่เป็นสิ่งที่สำคัญเมื่อโปรแกรมของคุณมีขนาดใหญ่ขึ้น คุณอาจจะแบ่งมันออกเป็นส่วนๆ โดยแยกเป็นโมดูล และจัดกลุ่มของโมดูลด้วยการใช้ Package และนอกจากนี้ คุณยังสามารถสร้างไลบรารี่ของคุณ เพื่อให้นักพัฒนาคนอื่นๆ ได้ใช้งาน\nก่อนที่จะเริ่มต้น มาทำความเข้าใจกับคำศัพท์ที่จำเป็นต้องทราบสำหรับการเขียนโปรแกรมเชิงวัตถุในภาษา Python\n คลาส คือประเภทข้อมูลที่สร้างโดยผู้ใช้ โดยจะนำไปใช้สร้างออบเจ็ค กล่าวอีกนัยหนึ่ง คลาสคือประเภทข้อมูลของออบเจ็ค ออบเจ็ค คือสิ่งที่สร้างมาจากคลาสหรือ class instances แอตทริบิวต์ (instance attributes) คือข้อมูลที่เป็นสมาชิกของแต่ละออบเจ็ค โดยมักจะกำหนดไว้ในเมธอด __init__() ของคลาส เมธอด คือฟังก์ชันการทำงานที่กำหนดไว้ในคลาส คลาสแอตทริบิวต์ (class attributes) คือตัวแปรที่ประกาศไว้ในคลาส ซึ่งจะแชร์กับออบเจ็คทั้งหมดที่สร้างจากคลาสนั้นๆ  คลาสคืออะไร คลาส คือสิ่งที่ใช้กำหนดรูปแบบของข้อมูล (Attributes) และเมธอด (Methods) การทำงานเข้าด้วยกัน การสร้างคลาส หมายถึงการสร้างประเภทของออบเจ็คขึ้นมา กล่าวอีกนัยหนึ่ง คลาสคือประเภทข้อมูลของออบเจ็คโดยคลาสนั้นสร้างขึ้นโดยผู้ใช้ (User-defined type) โดยปกติแล้ว ประเภทข้อมูลพื้นฐานในภาษา Python นั้นคือคลาส เมื่อคุณสร้างตัวแปรใดๆ ขึ้นมา ตัวแปรเหล่านั้นเป็นออบเจ็คของคลาส เพื่อทำให้คุณเข้าใจมากขึ้นมาดูตัวอย่างต่อไปนี้\na = 1 b = 1.34 c = \u0026#39;marcuscode.com\u0026#39; print(type(a)) print(type(b)) print(type(c)) ในตัวอย่าง เราได้ประกาศตัวแปรสามตัวคือ Integer Floating และ String ตามลำดับ ดังนั้นตัวแปรเหล่านี้ถือว่าเป็นออบเจ็คของคลาส ดังผลลัพธ์ข้างล่าง\n\u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; เหมือนที่คุณเห็น เราใช้ฟังก์ชัน type() เพื่อดูประเภทข้อมูลของออบเจ็คใดๆ หรือใช้สำหรับดูประเภทของคลาสที่มันสร้างมาจาก จากตัวอย่างนั้น เราเรียกคลาส int float และ str ว่า build-in type สำหรับในบทนี้ เรากำลังจะพูดเกี่ยวกับการสร้างคลาสซึ่งเป็น User-defined type นั่นเอง\nการสร้างคลาสและออบเจ็ค คลาส จะประกอบไปด้วยสมาชิกสองประเภท คือ แอตทริบิวต์หรือตัวแปร ที่ใช้ในการเก็บข้อมูลภายในคลาสนั้นๆ และเมธอด (methods) เป็นฟังก์ชันการทำงานหรือจัดการข้อมูลในคลาสนั้น เมธอดนั้นคล้ายกับฟังก์ชัน แต่ในบริบทของการเขียนโปรแกรมเชิงวัตถุแล้วเราจะเรียกว่าเมธอดแทน เพราะว่ามันถูกประกาศอยู่ภายในคลาส นี่เป็นรูปแบบของการสร้างคลาสในภาษา Python\nclass ClassName: # statements เราจะใช้คำสั่ง class สำหรับสร้างคลาสในภาษา Python และตามด้วยชื่อของคลาส ClassName ชื่อของคลาสควรจะขึ้นต้นด้วยตัวใหญ่และเป็นรูปแบบ camel case หลังจากนั้นเป็นคำสั่งในการกำหนดตัวแปรและเมธอดของคลาส ต่อไปมาดูตัวอย่างการสร้างคลาสในภาษา Python\nclass Book: def __init__(self, name, price): self.name = name self.price = price def getDetail(self): print(\u0026#39;Name: %s\u0026#39; % self.name) print(\u0026#39;Price: %dUSD\u0026#39; % self.price) ในตัวอย่าง เราได้สร้างคลาส Book และภายในมีเมธอด __init__() ซึ่งเป็นคอนสตรัคเตอร์ (Constructor) ซึ่งจะถูกเรียกอัตโนมัติเมื่อออบเจ็คถูกสร้างสำเร็จ พารามิเตอร์แรกของเมธอดจะเป็น self เสมอ นี่จะใช้เป็นตัวแปรในการอ้างถึงออบเจ็คปัจจุบัน คลาสนี้จะมีสองแอตทริบิวต์คือ name และ price ใช้สำหรับเก็บชื่อและราคาของหนังสือของแต่ละออบเจ็ค หลังจากที่เราได้สร้างคลาสเสร็จแล้ว ต่อไปเราจะนำมาสร้างออบเจ็ค\nb1 = Book(\u0026#39;Python language\u0026#39;, 59) b2 = Book(\u0026#39;C++ language\u0026#39;, 69) b1.getDetail() b2.getDetail() b1.price = 99 b1.getDetail() ในตัวอย่าง เราได้สร้างตัวแปรออบเจ็คจากคลาส Book สองตัวแปร คือ b1 และ b2 สำหรับพารามิเตอร์แรกในคอนสตรัคเตอร์นั้นเราได้ละเว้นไป เพราะ Python จะใส่เป็นออบเจ็คปัจจุบันให้อัตโนมัติ ดังนั้นพารามิเตอร์ที่เราจะต้องใส่คือชื่อและราคาของหนังสือ\nหลังจากที่ออบเจ็คถูกสร้างแล้ว ทั้ง b1 และ b2 จะมีแอตทริบิวต์ name price และเมธอด getDetail() เป็นของตัวเองที่ไม่เกี่ยวข้องกัน ในการเข้าถึงสมาชิกภายในออบเจ็คจะใช้เครื่องหมายจุด (.) ดังนั้นเมื่อเราเรียก b1.getDetail() จะเป็นการแสดงรายละเอียดข้อมูลในออบเจ็ค b1 ซึ่ง b2 ก็เช่นเดียวกัน และต่อมาเราได้เปลี่ยนค่า price ของออบเจ็ค b1 ให้มีค่าเป็น 99 และแสดงรายละเอียดอีกครั้ง และนี่เป็นผลลัพธ์การทำงานของโปรแกรม\nName: Python language Price: 59 USD Name: C++ language Price: 69 USD Name: Python language Price: 99 USD ในตอนนี้ คุณได้เห็นแล้วว่าคลาสหนึ่งคลาสสามารถนำไปสร้างเป็นออบเจ็คกี่อันก็ได้ ซึ่งนี่เองถือว่าเป็นแนวคิดที่สำคัญของการเขียนโปรแกรมเชิงวัตุในการนำโค้ดกลับมาใช้ซ้ำ\nหลังจากที่คุณได้เห็นการประกาศคลาสและสร้างออบเจ็คในเบื้องต้นแล้ว ต่อไปมาดูตัวอย่างเพิ่มเติมสำหรับการทำงานกับคลาสในภาษา Python\nclass Person: def __init__(self, firstName, lastName): self.firstName = firstName self.lastName = lastName def getName(self): return self.firstName + \u0026#39; \u0026#39; + self.lastName p = Person(\u0026#39;Chase\u0026#39;, \u0026#39;Rice\u0026#39;) p.career = \u0026#39;Singer\u0026#39; p.country = \u0026#39;USA\u0026#39; print(\u0026#39;Name: \u0026#39; + p.getName()) print(\u0026#39;Career: \u0026#39; + p.career) print(\u0026#39;Country: \u0026#39; + p.country) p2 = Person(\u0026#39;Max\u0026#39;, \u0026#39;Graham\u0026#39;) p2.genres = [\u0026#39;Electronica\u0026#39;, \u0026#39;trance\u0026#39;, \u0026#39;tech house\u0026#39;, \u0026#39;techno\u0026#39;] print(\u0026#39;Name: \u0026#39; + p2.getName()) print(\u0026#39;Genres: \u0026#39;, p2.genres) ในตัวอย่าง เราได้สร้างคลาส Person ที่ประกอบไปด้วยแอตทริบิวต์ firstName และ lastName และเมธอด getName() สำหรับรับชื่อกับนามสกุลพร้อมกัน และเราได้กำหนดค่าให้กับแอตทริบิวต์ career และ country ในภายหลัง ซึ่งโดยปกติแล้วในการกำหนดแอตทริบิวต์เริ่มต้นควรจะทำในเมธอด __init__() ดังนั้น นี่จะทำให้คุณเห็นว่าในภาษา Python เราสามารถสร้างแอตทริบิวต์ใดๆ ในขณะที่โปรแกรมทำงานได้\nName: Chase Rice Career: Singer Country: USA Name: Max Graham นี่เป็นผลลัพธ์การทำงานของโปรแกรม คุณได้เห็นแล้วว่าการเขียนโปรแกรมในภาษา Python นั้นค่อนข้างยืดหยุ่น คุณไม่จำเป็นต้องประกาศแอตทริบิวต์ทั้งหมดไว้ในตอนแรกก็ได้ คุณอาจจะเพิ่มเข้ามาในภายหลังเฉพาะออบเจ็คที่ต้องการได้ เหมือนในออบเจ็ค p2 ไม่ได้ต้องการมีแอตทริบิวต์เหมือนกับออบเจ็ค p แต่ทั้งสองยังมีแอตทริบิวต์บางอย่างที่เหมือนกัน\nConstructor และ Destructor ต่อมาเราจะพูดเกี่ยวกับการใช้งาน Constructor และ Destructor ในภาษา Python นั้นมีเมธอดพิเศษ (Special methods) ที่สร้างให้อัตโนมัติเมื่อคุณสร้างคลาสขึ้นมา เพื่อใช้งานเราจะต้อง override เมธอดเหล่านั้น เมธอดแรกคือ __init__() ซึ่งเมธอดนี้จะทำงานเมื่อออบเจ็คถูกสร้างสำเร็จ หรือเรียกว่า Constructor มันมักจะใช้ในการกำหนดแอตทริบิวต์และค่าเริ่มต้นให้กับออบเจ็ค ต่อมาคือเมธอด __del__() ซึ่งเมธอดนี้จะทำงานเมื่อออบเจ็คถูกทำลาย หรือเรียกว่า Destructor มาดูตัวอย่างการใช้งาน\nclass Person: def __init__(self, firstName, lastName): self.firstName = firstName self.lastName = lastName print(\u0026#39;Object was created\u0026#39;) def getName(self): return self.firstName + \u0026#39; \u0026#39; + self.lastName def __del__(self): print(\u0026#39;Object was destroyed\u0026#39;) p = Person(\u0026#39;Chase\u0026#39;, \u0026#39;Rice\u0026#39;) print(p.getName()) del p ในตัวอย่าง เราได้ทำการ override เมธอด __init__() มันถูกเรียกอัตโนมัติเมื่อเราสร้างออบเจ็คสำเร็จ จากคำสั่ง Person('Chase', 'Rice') หลังจากนั้นเราได้ทำการ override เมธอด __del__() ซึ่งเมธอดนี้จะถูกเรียกใช้งานก่อนที่ออบเจ็คจะถูกทำลาย ในโค้ดเราได้ทำลายออบเจ็คด้วยคำสั่ง del p ซึ่งจะทำให้ออบเจ็คถูกลบออกไปจากหน่วยความจำ\nObject was created Chase Rice Object was destroyed นี่เป็นผลลัพธ์การทำงานของโปรแกรม เมื่อสร้างออบเจ็คสำเร็จเราได้แสดงข้อความในเมธอด __init__() ว่าสร้างออบเจ็คสำเร็จแล้ว และเมื่อเราลบออบเจ็คโปรแกรมแสดงข้อความในเมธอด __del__() ว่าออบเจ็คถูกทำลายไปแล้ว ซึ่งการทำงานเหล่านี้จะเกิดขึ้นอัตโนมัติ แน่นอนว่าในภาษา Python เรามักจะใช้คอนสตรัคเตอร์เสมอ แต่ว่า Destructor มักจะไม่ได้ใช้บ่อยนัก อย่างไรก็ตามยังมีเมธอดพิเศษอื่นๆ อีกที่เรายังไม่ได้พูดถึงในบทนี้\nStatic variables และ Static methods สำหรับเรื่องสุดท้ายที่คุณจะได้เรียนในบทนี้ คือการใช้งาน static variable และ static method โดย static variable หรือคลาสแอตทริบิวต์ คือตัวแปรที่ประกาศภายในคลาสซึ่งตัวแปรนี้จะแชร์กับออบเจ็คทุกอันที่สร้างจากคลาสนี้ ส่วน static method เป็นเมธอดที่สร้างไว้ในคลาสแต่ไม่ได้มีส่วนเกี่ยวกับข้องกับการจัดการออบเจ็ค มาดูตัวอย่างการใช้งาน\nclass Box: # shared variable for all object create by this class color = \u0026#39;green\u0026#39; # class method for object def __init__(self, width, height, dept): self.width = width self.height = height self.dept = dept # class method for object def getVolume(self): return self.width * self.height * self.dept @staticmethod def compare(a, b): if a.getVolume() \u0026gt; b.getVolume(): return \u0026#39;greater than\u0026#39; elif a.getVolume() == b.getVolume(): return \u0026#39;equal\u0026#39; else: return \u0026#39;less than\u0026#39; a = Box(2, 3, 4) b = Box(1, 2, 5) Box.color = \u0026#39;red\u0026#39; print(\u0026#39;Box a volume = %d\u0026#39; % a.getVolume()) print(\u0026#39;Box b volume = %d\u0026#39; % b.getVolume()) print(\u0026#39;Box a color = %s\u0026#39; % a.color) print(\u0026#39;Box b color = %s\u0026#39; % b.color) print(\u0026#39;Box a volume a is %sbox b\u0026#39; % Box.compare(a, b)) ในตัวอย่าง เราได้ประกาศคลาส Box โดยคลาสนี้มีตัวแปรของคลาส คือ color นั่นหมายความว่าตัวแปรนี้จะถูกใช้งานร่วมกันกับทุกออบเจ็คที่สร้างจากคลาสนี้ ต่อมาภายในเมธอด __init__() เป็นการกำหนดข้อมูลให้กับออบเจ็คแต่ละอันที่จะมีความกว้าง ความยาว และความสูง และเมธอด getVolume() สำหรับรับปริมาตรของกล่อง\nภายในคลาส Box เราได้สร้าง static method compare() โดยใช้ decorator @staticmethod นำหน้าก่อนหนึ่งบรรทัด เมธอดนี้ไม่ได้มีส่วนเกี่ยวข้องกับข้อมูลภายในคลาส สังเกตว่ามันไม่มีพารามิเตอร์ self ถูกส่งเข้ามา สำหรับการเรียกใช้งาน static variables หรือ static method นั้นจะไม่ขึ้นกับออบเจ็ค นั่นหมายความว่าเราจะใช้ชื่อของคลาสแทน ในคำสั่ง Box.color = 'red' เป็นการกำหนดสีให้กับกล่องทุกกล่องเป็นสีแดง และคำสั่ง Box.compare(a, b) เป็นการเปรียบเทียบปริมาตรของกล่องทางซ้ายว่ามากกว่าทางขวาหรือไม่\nBox a volume = 24 Box b volume = 10 Box a color = red Box b color = red Box a volume a is greater than box b นี่เป็นผลลัพธ์การทำงานของโปรแกรม จะเห็นว่าเราได้ทำการเปลี่ยนค่าสีของกล่องเป็นสีแดงในคำสั่งเดียว แต่มันถูกนำไปใช้กับทุกกล่อง และเมธอดสำหรับเปรียบเทียบปริมาตรของกล่องมันสามารถใช้ได้โดยไม่ขึ้นกับออบเจ็คใดๆ นั่นหมายความว่า static method อาจจะเป็นเมธอดที่ทำงานเกี่ยวกับออบเจ็คที่สร้างจากคลาสนี้ แต่ไม่ได้เป็นเมธอดสำหรับจัดการข้อมูลในคลาสโดยตรง\nในบทนี้ คุณได้เรียนรู้เกี่ยวกับคลาสและออบเจ็คในภาษา Python ซึ่งเป็นสิ่งที่คุณควรจะทำความเข้าใจเพื่อที่จะใช้ประโยชน์จาก OOP ซึ่งมันช่วยให้การเขียนโปรแกรมมีประสิทธิภาพและรวดเร็วขึ้น นอกจากนี้เรายังพูดเกี่ยวกับเมธอดพิเศษ Constructor และ Destructor และสมาชิกที่เป็น static ของคลาส สำหรับเนื้อหาของ OOP ยังไม่จบเพียงเท่านี้ มันยังมีการสืบทอด (Inheritance) ซึ่งคุณจะได้เรียนในบทต่อไป\n Reference : http://marcuscode.com/lang/python/classes-and-objects\n "
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/phyblas/intermediate/lambda/",
	"title": "คำสั่งพิเศษที่เกี่ยวข้องกับฟังก์ชัน",
	"tags": [],
	"description": "",
	"content": "ในบทนี้จะพูดถึงคำสั่งบางอย่างที่เกี่ยวข้องกับฟังก์ชัน ซึ่งความจริงแล้ว อาจไม่ได้มีความจำเป็นต้องใช้มากนัก เพียงแต่ในบางกรณี ก็ทำให้การเขียนโค้ดดูสั้นกระชับเรียบง่ายขึ้น จึงเหมาะใน บางกรณี และต่อให้บางคนไม่ได้กะจะใช้แต่ก็อาจเรียนรู้ไว้เผื่อไปศึกษาโค้ดของคนอื่น ได้ คำสั่งเหล่านั้นได้แก่ lambda, map, filter, any และ all\nlambda นอกจากการนิยามฟังก์ชันแบบทั่วไปที่ใช้กันแล้ว สำหรับฟังก์ชันที่แค่ต้องการให้มีการคืนค่า โดยที่ไม่ได้มีการดำเนินการอะไรอาจสามารถนิยามได้โดยใช้คำสั่ง lambda ลองยกตัวอย่างฟังก์ชันคำนวณง่ายๆ\ndef f(x): return x**3+4*x**2+5**x+1 หากนิยามโดยใช้ lambda ก็จะเป็น\nf = lambda x:x**3+4*x**2+5**x+1 รูปแบบการเขียนอาจดูเข้าใจยากสักหน่อย แต่จะเห็นว่าดูแล้วเขียนสั้นลงเล็กน้อย\nสรุปรูปแบบการเขียนคือ\n\u0026lt;ชื่อตัวแปรที่ต้องการให้เป็นฟังก์ชัน\u0026gt; = lambda \u0026lt;อาร์กิวเมนต์\u0026gt;:\u0026lt;ค่าคืนกลับ\u0026gt; ผลที่ได้ก็จะมีค่าเท่ากับการใช้ def ลองเทียบกันดู\ndef \u0026lt;ชื่อตัวแปรที่ต้องการให้เป็นฟังก์ชัน\u0026gt;(\u0026lt;อาร์กิวเมนต์\u0026gt;): return \u0026lt;ค่าคืนกลับ\u0026gt; หากมีอาร์กิวเมนต์หลายตัวก็ใช้จุลภาคคั่นเช่นเดียวกับการนิยามฟังก์ชันทั่วไป เช่น\nf = lambda x,y,z:x+y+z print(f(3,4,5)) # ได้ 12 จะได้ฟังก์ชันสำหรับบวกค่าตัวเลข ๓ ตัว\nข้อด้อยของการใช้ lambda ก็คือไม่สามารถสร้างฟังก์ชันสำหรับดำเนินการอะไรได้ ทำได้แต่ฟังก์ชันสำหรับคืนค่า แต่ข้อดีคือถ้าต้องการแค่ประกาศฟังก์ชันที่มีแค่การคืนค่าแล้วละก็ จะเขียนสั้นกว่าใช้ def สามารถสร้างฟังก์ชันพร้อมกันหลายๆตัวได้อย่างรวดเร็ว เช่นตัวอย่างนี้ สร้างฟังก์ชันบวกลบคูณหารพร้อมกัน\nf4 = [lambda x,y:x+y,lambda x,y:x-y,lambda x,y:x*y,lambda x,y:x/y] print(f4[0](4,5)) # 9  print(f4[1](4,5)) # -1  print(f4[2](4,5)) # 20  print(f4[3](4,5)) # 0.8 การทำแบบนี้ถ้าใช้ def ก็ต้องประกาศฟังก์ชันทีละตัว แล้วค่อยเอาชื่อฟังก์ชันมาเก็บรวมกันในลิสต์ ไม่สามารถทำทุกอย่างในบรรทัดเดียวได้แบบที่ใช้ lambda นอกจากนี้ lambda ยังมีข้อดีตรงที่สามารถสร้างแล้วใช้งานได้ทันทีโดยที่อาจไม่ต้องตั้งชื่อ ฟังก์ชัน (ไม่ต้องสร้างตัวแปรออบเจ็กต์ฟังก์ชัน) ซึ่งทำให้สะดวก ใช้งานได้รวดเร็ว เช่น\nprint((lambda x:x**2)(10)) # ได้ 100  print([(lambda x:x+10)(x) for x in range(10,20)]) # ได้ [20, 21, 22, 23, 24, 25, 26, 27, 28, 29] ด้านหลังโคลอน : จะต้องเป็นค่าอะไรสักอย่างที่ต้องการให้คืนกลับ แต่จะใส่เป็นฟังก์ชันที่สั่งให้ทำงานอะไรบางอย่างก็ได้ แต่ในกรณีแบบนั้นหากฟังก์ชันนั้นไม่ได้ส่งค่าคืนกลับมาก็จะได้ None\nprint((lambda x:print(x*2))(7)) # จะมีเลข 14 ถูก print ออกมาก่อน จากนั้นจะได้ None ดังนั้นเราอาจใช้สร้างฟังก์ชันธรรมดาที่ไม่มีการคืนค่าก็ได้ เช่นฟังก์ชันที่จะพิมพ์เลข ๒ เท่าของที่ใส่เข้าไป\nprintx2 = lambda x:print(x*2) printx2(12) # ได้ 24 หลัง lambda อาจไม่จำเป็นจะต้องใส่ตัวแปรเลยก็ได้ กรณีแบบนี้ก็จะได้ฟังก์ชันที่ไม่ต้องการอาร์กิวเมนต์\nprint((lambda:1)()) # ได้ 1 map บางครั้งมีลิสต์อยู่อันหนึ่ง และมีฟังก์ชันอยู่อันหนึ่งซึ่งต้องการจะให้ใช้สมาชิกในลิสต์นั้นเพื่อเป็น อาร์กิวเมนต์ของฟังก์ชันแล้วคืนค่าออกมาโดยแยกกัน โดยทั่วไปก็จะต้องใช้ for เพื่อวนทำซ้ำให้ครบทุกตัว\ndef f(x): return x**3 xxxx = [2,7,11,16] x3 = [] for x in xxxx: x3 += [f(x)] print(x3) # ได้ [8, 343, 1331, 4096] แต่ว่ามีวิธีที่จะเขียนให้ง่ายและสั้นขึ้นมาก คือการใช้คำสั่ง map\ndef f(x): return x**3 xxxx = [2,7,11,16] x3 = list(map(f,xxxx)) print(x3) # ได้ [8, 343, 1331, 4096] map นั้นเป็นคำสั่งสำหรับให้คืนค่าที่ฟังก์ชันหนึ่งทำกับกลุ่มข้อมูลหนึ่ง การใช้ map นั้นเป็นการสร้างออบเจ็กต์ชนิดหนึ่งคือชนิด map ซึ่งเป็นอิเทอเรเตอร์ตัวหนึ่ง ถ้าต้องการให้เป็นลิสต์ก็ต้องคร่อมด้วย list() ไปอีกทีดังตัวอย่าง\nออบเจ็กต์ map สามารถทำงานได้เหมือนกับเป็นลิสต์เมื่อใช้คู่กับ for ดังนั้นในกรณีที่จะใช้กับ for อยู่แล้วก็ไม่จำเป็นต้องแปลงเป็นลิสต์ก็ได้\nสรุปโครงสร้างของการใช้ map\n\u0026lt;ตัวแปรที่รับค่าออบเจ็กต์ map\u0026gt; = map(\u0026lt;ฟังก์ชัน\u0026gt;,\u0026lt;ลิสต์\u0026gt;) หรือถ้าต้องการเปลี่ยนเป็นลิสต์ทันที\n\u0026lt;ตัวแปรที่รับค่าออบเจ็กต์ map\u0026gt; = list(map(\u0026lt;ฟังก์ชัน\u0026gt;,\u0026lt;ลิสต์\u0026gt;)) อนึ่ง ที่จริงแล้ววิธีที่เขียนสั้นๆได้อีกวิธีคือใช้ for สร้างลิสต์\nx3 = [f(x) for x in xxxx] ผลที่ได้ก็เหมือนกัน จะใช้แบบไหนก็แล้วแต่กรณี แล้วแต่ความถนัด ออบเจ็กต์ map เป็นอิเทอเรเตอร์ ซึ่งมีข้อดีคือจะประหยัดหน่วยความจำกว่าลิสต์และทำงานเร็วกว่าในกรณีที่ไม่มีความ จำเป็นต้องใช้งานในรูปแบบลิสต์ บางครั้ง map ยังใช้คู่กับ lambda เพื่อจะได้ไม่ต้องนิยามฟังก์ชันขึ้นมาก่อน ทำให้การเขียนยิ่งสั้นกะทัดรัด\nxxxx = [2,7,11,16] x3 = list(map(lambda x:x**3,xxxx)) print(x3) # ได้ [8, 343, 1331, 4096] ลองประยุกต์ใช้กับอย่างอื่นอีก เช่น เปลี่ยนตัวเลขเป็นสายอักขระ\nprint(list(map(str,range(10)))) # ได้ [\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;]  print(\u0026#39;\u0026#39;.join(map(str,range(10)))) # ได้ 0123456789 จะเห็นว่าเมธอด join สามารถใช้กับออบเจ็กต์ map ได้โดยตรงโดยไม่ต้องแปลงเป็นลิสต์ก่อน\nmap คืนค่าเป็นอิเทอเรเตอร์แบบนี้แค่ในไพธอน 3 เท่านั้น ส่วนในไพธอน 2 นั้น map จะคืนค่าเป็นลิสต์ไม่ใช่อิเทอเรเตอร์ ดังนั้นไม่ต้องมาแปลงเป็นลิสต์อีกทีเพื่อแสดงผล\nfilter ก็เช่นเดียวกัน\n รายละเอียด\n filter บางครั้งเรามีลิสต์อยู่อันหนึ่ง แล้วต้องการคัดกรองส่วนประกอบบางอย่างออกไป โดยทั่วไปแล้วก็อาขใช้ for วนเพื่อตรวจแต่ละอันแล้วดูเงื่อนไขว่าตรงหรือเปล่าถ้าไม่ตรงก็คัดออก ตัวอย่าง มีลิสต์อยู่อันหนึ่งที่มีสายอักขระอยู่หลายตัว จะกรองเอาเฉพาะสายอักขระที่สั้นกว่า 6 ตัวอักษร\nk = [\u0026#39;egao\u0026#39;,\u0026#39;kibou\u0026#39;,\u0026#39;yuuki\u0026#39;,\u0026#39;jishin\u0026#39;,\u0026#39;kagayaki\u0026#39;,\u0026#39;ai\u0026#39;,\u0026#39;yasashisa\u0026#39;] f = [] for s in k: if(len(s)\u0026lt;6): f += [s] print(f) # ได้ [\u0026#39;egao\u0026#39;, \u0026#39;kibou\u0026#39;, \u0026#39;yuuki\u0026#39;, \u0026#39;ai\u0026#39;] หรืออาจเขียนสั้นๆด้วยวิธีการสร้างลิสต์ใหม่จาก for เป็น\nf = [s for s in k if(len(s)\u0026lt;6)] print(f) # ได้ [\u0026#39;egao\u0026#39;, \u0026#39;kibou\u0026#39;, \u0026#39;yuuki\u0026#39;, \u0026#39;ai\u0026#39;] แต่ก็มีอีกวิธีหนึ่งที่สามารถใช้ได้ คือใช้ filter ซึ่งมีวิธีการเขียนดังนี้\ndef filt(s): # นิยามฟังก์ชันสำหรับคัดกรองขึ้นมาก่อน  return len(s)\u0026lt;6 f = list(filter(filt,k)) print(f) # ได้ [\u0026#39;egao\u0026#39;, \u0026#39;kibou\u0026#39;, \u0026#39;yuuki\u0026#39;, \u0026#39;ai\u0026#39;] เขียนแบบนี้อาจดูเข้าใจยากสักหน่อย อาร์กิวเมนต์ตัวแรกของ filter คือฟังก์ชันซึ่งจะถูกพิจารณาค่าความจริงเท็จ ในที่นี้ชื่อ filt ส่วนตัวที่สองคือลิสต์ที่จะนำมาคัดกรอง คือลิสต์ k filter จะทำการกรองสมาชิกในลิสต์ที่แทนค่าลงในฟังก์ชันนั้นแล้วได้ค่าความจริงเป็น จริง เอาที่ให้ค่าเป็นเท็จออกไป ในที่นี้จะเป็นจริงเมื่อความยาวของสายอักขระน้อยกว่า 6 ผลที่ได้จะอยู่ในรูปของออบเจ็กต์ชนิด filter ซึ่งก็เป็นอิเทอเรเตอร์เช่นเดียวกับ map filter มักใช้คู่กับ lambda เพื่อจะทำให้ไม่จำเป็นต้องนิยามฟังก์ชันขึ้นมาก่อน ดูกะทัดรัดขึ้นมาก\nf = list(filter(lambda s:len(s)\u0026lt;6,k)) print(f) # ได้ [\u0026#39;egao\u0026#39;, \u0026#39;kibou\u0026#39;, \u0026#39;yuuki\u0026#39;, \u0026#39;ai\u0026#39;] ตัวอย่างการใช้ การหาเลขจำนวนเฉพาะโดยวิธีการตะแกรงของเอราโตสเธเนส\nตะแกรงของเอราโตสเธเนส (Ἐρατοσθένης) มีที่มาจากนักคณิตศาสตร์กรีกโบราณ เป็นการคัดกรองหาเลขที่เป็นจำนวนเฉพาะโดยการไล่ตัดตัวเลขที่หารจำนวนเฉพาะ ลงตัวไปทีละนิด โดยเริ่มดูจาก 2 ตามด้วย 3 แล้วก็ 5 ไปเรื่อยๆ กล่าวคือ เริ่มไล่ดูว่าตัวไหนหาร 2 ลงตัวก็ตัดจำนวนนั้นออก จากนั้นทำซ้ำกับ 3 ส่วนเลข 4 ถูกตัดไปแล้วจึงข้ามไปทำ 5 แล้วก็ข้ามไป 7 และ 11 ต่อไปเรื่อยๆ\nn = 121 # จำนวนตัวเลขที่จะพิจารณา  ch = range(2,n+1) i = 0 # ตำแหน่งของสมาชิกในลิสต์ที่จะใช้เป็นตัวกรอง เริ่มจากตัวแรก  while(ch[i]\u0026lt;=n**0.5): # ให้วนกรองไปเรื่อยๆจนกว่าจะถึงตัวเลขที่เท่ากับรากที่สองของ n  ch = list(filter(lambda x:x%ch[i]!=0 or x==ch[i],ch)) # คัดกรองเอาไว้เฉพาะตัวที่หารตัวที่เป็นตัวกรองอยู่ไม่ลงตัว และตัวกรองเอง  print(\u0026#39;รอบที่ %d: \u0026#39;%(i+1)+\u0026#39;,\u0026#39;.join(map(str,ch))) # แสดงผลเลขที่เหลืออยู่ในแต่ละรอบ  i += 1 # พิจารณาตัวถัดไป ผลลัพธ์\nรอบที่ 1: 2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,93,95,97,99,101,103,105,107,109,111,113,115,117,119,121 รอบที่ 2: 2,3,5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,79,83,85,89,91,95,97,101,103,107,109,113,115,119,121 รอบที่ 3: 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,49,53,59,61,67,71,73,77,79,83,89,91,97,101,103,107,109,113,119,121 รอบที่ 4: 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,121 รอบที่ 5: 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113 any กับ all any เป็นฟังก์ชันสำหรับตรวจสอบความจริงเท็จของข้อมูลกลุ่ม ถ้าในกลุ่มมีข้อมูลที่มีค่าความจริงเท็จเป็น True แม้แต่ตัวเดียวจะได้ค่า True ทันที any(ลิสต์) เทียบเท่ากับ (1 in ลิสต์)\nprint(1 in [1,0,1]) # ได้ True  print(any([1,0,1])) # ได้ True  print(any([0,0,0])) # ได้ False ส่วน all นั้นจะตรวจว่าข้อมูลในกลุ่มเป็นจริงทั้งหมดหรือเปล่า ถ้ามี False แม้แต่ตัวเดียวจะเป็น False ทันที all(ลิสต์) เทียบเท่ากับ (1 in ลิสต์)\nprint(0 not in [1,0,1]) # ได้ False  print(all([1,0,1])) # ได้ False  print(all([1,1,1])) # ได้ True การประยุกต์ใช้นั้นเช่นเดียวกับ filter คือสามารถใช้คู่กับ map และ lambda ได้ โดยใช้ lambda สร้างฟังก์ชันที่ตรวจสอบเงื่อนไขที่ต้องการ จากนั้นใช้ map เพื่อให้ฟังก์ชันนั้นทำกับทุกตัวในลิสต์ ผลที่ได้ก็คือจะได้ลิสต์ที่มีค่า True หรือ False (1 หรือ 0)\nprint(any(map(lambda x:x\u0026gt;0,[-7,-1,2,6]))) # ได้ True  print(all(map(lambda x:x\u0026gt;0,(-5,0,3,9)))) # ได้ False  print(all(map(lambda x:x%2,range(-7,9,2)))) # ได้ True  print(any(map(lambda x:x%2==0,range(-5,13,4)))) # ได้ False สรุปเนื้อหา\nทั้ง lambda, map และ filter นั้นลักษณะการเขียนอาจดูแล้วเข้าใจยากในช่วงแรกๆ แต่หากใช้เป็นแล้วในบางกรณีจะช่วยให้การเขียนง่ายขึ้นมาก\nแต่ก็ไม่ใช่คำสั่งที่ขาดไม่ได้ ดังนั้นบางคนอาจไม่เคยต้องใช้มันเลย แต่ก็อาจควรเรียนรู้ไว้สักหน่อยเผื่อว่าไปอ่านโค้ดที่คนอื่นเขียนแล้วเขาใช้ จะได้เข้าใจได้\nอ้างอิง\nhttp://python.keicode.com/lang/functions-lambda.php\nhttp://atkonn.blogspot.com/2008/02/python-python27-lambda.html\nhttp://python.civic-apps.com/map-reduce-filter\nhttp://python.civic-apps.com/list-comprehensions\nhttp://diveintopython3-ja.rdy.jp/porting-code-to-python-3-with-2to3.html\nhttp://jutememo.blogspot.com/2008/09/python-map-filter-reduce.html\nhttp://cortyuming.hateblo.jp/entry/20080821/p1\n Reference : https://phyblas.hinaboshi.com/tsuchinoko21\n "
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/learning-python/21_inheritance/",
	"title": "22. Inheritance",
	"tags": [],
	"description": "",
	"content": "ในบทก่อนหน้า คุณได้เรียนรู้พื้นฐานการเขียนโปรแกรมเชิงวัตถุในการสร้างคลาสและออบเจ็คไปแล้ว และในบทนี้ คุณจะได้เรียนรู้เกี่ยวกับคุณสมบัติอีกอย่างหนึ่งของ OOP คือการสืบทอดคลาส (Inheritance) ซึ่งเป็นความสามารถที่สำคัญในภาษา Python ที่จะทำให้สามารถนำคลาสที่เขียนไว้แล้วมาใช้อีกครั้งและเพิ่มความสามารถเพิ่มเติมเข้ามา ก่อนที่จะเริ่ม มาทำความเข้าใจกับแนวคิดของการสืบทอดก่อน\nInheritance คืออะไร Inheritance หรือการสืบทอด คือการที่คลาสหรือออบเจ็ค ได้รับการถ่ายทอดแอตทริบิวต์และเมธอดจากคลาสอื่น นั่นจะทำให้คลาสดังกล่าวมีแอตทริบิวต์และเมธอดเหมือนคลาสที่มันสืบทอดมาเรียกคลาสนั้นว่า super class หรือ base class ส่วนคลาสที่ได้รับการสืบทอดเรียกว่า sub class หรือ child class นอกจากนี้ เรายังสามารถขยายความสามารถโดยการเพิ่มแอตทริบิวต์หรือเมธอด หรือทำการ override เมธอดของ super class ได้ นี่เป็นแนวคิดในการนำโค้ดเดิมกลับมาใช้โดยไม่ต้องเขียนขึ้นใหม่ และเพิ่มความสามารถของเดิมที่มีอยู่ ในภาษา Python นั้นยังสนับสนุน Multiple inheritance ซึ่งอนุญาติให้คลาสสืบทอดจากคลาสหลายๆ คลาสได้ในเวลาเดียวกัน\nนี่เป็นรูปแบบของการสืบทอดคลาสในภาษา Python\nclass DerivedClassName(BaseClassName): pass class DerivedClassName(BaseClassName1, BaseClassName2, ...): pass ในตัวอย่าง เป็นรูปแบบการสืบทอดคลาส โดยแบบแรกเป็นการสืบทอดจากคลาสเดียว ซึ่งชื่อของ super class จะอยู่ในวงเล็บ (BaseClassName) และสำหรับตัวอย่างต่อมา คือการสืบทอดแบบหลายคลาส โดยจะมีเครื่องหมายคอมมา (,) แยกระหว่างแต่ละคลาสออกจากกัน ต่อไปมาดูตัวอย่างการสร้างคลาสที่สืบทอดจากคลาสอื่นในภาษา Python\nการสืบทอดคลาส ในการสืบทอดคลาสนั้น เราจะยกตัวอย่างโดยการสร้างคลาสสำหรับเก็บข้อมูลของบุคคลชื่อ Person หลังจากนั้นเราจะสร้างคลาสของลูกจ้าง Employee ซึ่งคลาสนี้จะสืบทอดมาจากคลาสก่อนหน้า มาดูส่วนของโปรแกรมของเรา\nclass Person: def __init__(self, firstName, lastName): self.firstName = firstName self.lastName = lastName def getName(self): return self.firstName + \u0026#39; \u0026#39; + self.lastName class Employee(Person): def setWorkDetail(self, department, position): self.department = department self.position = position def getWorkDetail(self): return self.position + \u0026#39;, \u0026#39; + self.department emp1 = Employee(\u0026#39;Mladen\u0026#39;, \u0026#39;Solomun\u0026#39;) emp1.setWorkDetail(\u0026#39;Software Engineer\u0026#39;, \u0026#39;C++ programmer\u0026#39;) print(\u0026#39;Name: \u0026#39; + emp1.getName()) print(\u0026#39;Work: \u0026#39; + emp1.getWorkDetail()) emp2 = Employee(\u0026#39;John\u0026#39;, \u0026#39;Askew\u0026#39;) emp2.setWorkDetail(\u0026#39;Sound Engineer\u0026#39;, \u0026#39;Musical acoustics\u0026#39;) print(\u0026#39;Name: \u0026#39; + emp2.getName()) print(\u0026#39;Work: \u0026#39; + emp2.getWorkDetail()) ในตัวอย่าง เราได้สร้างคลาส Person ซึ่งคลาสนี้เป็น super class เพื่อที่จะนำไปให้คลาสอื่นสืบทอด ในคลาสมีสองแอตทริบิวต์คือ firstName ใช้สำหรับเก็บชื่อ และ lastName ใช้สำหรับเก็บนามสกุล และมีเมธอด getName() เพื่อรับชื่อและนามสกุลได้ในพร้อมกัน\nclass Employee(Person): ... หลังจากนั้นเราได้สร้างคลาส Employee ซึ่งได้สืบทอดมาจากคลาส Person นั่นหมายความว่าแอตทริบิวต์และเมธอดทั้งหมดจากคลาส Person จะถูกถ่ายทอดมายังคลาสนี้ด้วย นั่นจะทำให้มันมีทุกอย่างเหมือนที่คลาสหลักมี และนอกจากนี้ในคลาสนี้ยังมีเมธอดและแอตทริบิวต์เพิ่มเติมของมันเอง โดยเมธอด setWorkDetail() เป็นเมธอดสำหรับกำหนดรายละเอียดการทำงานโดยมีตำแหน่งงานและแผนกที่สังกัด และเมธอด getWorkDetail() แสดงข้อมูลเกี่ยวกับการทำงาน\nemp1 = Employee(\u0026#39;Mladen\u0026#39;, \u0026#39;Solomun\u0026#39;) emp1.setWorkDetail(\u0026#39;Software Engineer\u0026#39;, \u0026#39;C++ programmer\u0026#39;) print(\u0026#39;Name: \u0026#39; + emp1.getName()) print(\u0026#39;Work: \u0026#39; + emp1.getWorkDetail()) emp2 = Employee(\u0026#39;John\u0026#39;, \u0026#39;Askew\u0026#39;) emp2.setWorkDetail(\u0026#39;Sound Engineer\u0026#39;, \u0026#39;Musical acoustics\u0026#39;) print(\u0026#39;Name: \u0026#39; + emp2.getName()) print(\u0026#39;Work: \u0026#39; + emp2.getWorkDetail()) หลังจากเราได้สร้างคลาสเสร็จแล้ว ต่อไปเป็นการนำมาใช้งาน เราได้สร้างออบเจ็คของ Employee ขึ้นมาสองออบเจ็คคือ emp1 และ emp2 แต่ละออบเจ็คได้มีการกำหนดชื่อและนามสกุล และมีการกำหนดข้อมูลการทำงาน หลังจากนั้นเป็นการแสดงข้อมูลเกี่ยวกับแต่ละคน โดยแสดงชื่อและข้อมูลการทำงาน\nName: Mladen Solomun Work: C++ programmer, Software Engineer Name: John Askew Work: Musical acoustics, Sound Engineer นี่เป็นผลลัพธ์การทำงานของโปรแกรม คุณจะเห็นได้ว่าการสืบทอดนั้นทำให้เรานำคลาสเดิมกลับมาใช้ได้ และนอกจากนี้ยังสามารถเพิ่มแอตทริบิวต์และเมธอดเข้าไปอีก ซึ่งจะทำให้ช่วยประหยัดเวลาในการเขียนโปรแกรม ลดความซ้ำซ้อนของโค้ด\nMultiple Inheritance ในตัวอย่างก่อนหน้า เป็นการสืบทอดคลาสจากเพียงแค่คลาสเดียว อย่างไรก็ตามในภาษา Python นั้นสนับสนุนการสืบทอดจากหลายคลาสได้ในพร้อมกัน ต่อไปมาดูตัวอย่างของโปรแกรมที่จะใช้ประโยชน์จากการสืบทอดหลายคลาส\nclass Geographic: def setCordinate(self, latitude, longitude): self.latitude = latitude self.longitude = longitude def getCordinate(self): return str(self.latitude) + \u0026#39;, \u0026#39; + str(self.longitude) def getTimeZone(self): timezone = round(self.longitude / 12 - 1) if timezone \u0026gt; 0: return \u0026#39;+\u0026#39; + str(timezone) else: return str(timezone) def getClimate(self): if self.latitude \u0026lt;= -66.5 or self.latitude \u0026gt;= 66.5: return \u0026#39;Polar zone\u0026#39; elif self.latitude \u0026lt;= -23.5 or self.latitude \u0026gt;= 23.5: return \u0026#39;Temperate zone\u0026#39; else: return \u0026#39;Tropical zone\u0026#39; class Temperature: def setCelsius(self, celsius): self.celsius = celsius def getFahrenheit(self): return self.celsius * 1.8 + 32 def getKelvin(self): return self.celsius + 273.15 def getWeather(self): if self.celsius \u0026lt;= 0: return \u0026#39;freezing\u0026#39; elif self.celsius \u0026lt;= 18: return \u0026#39;cold\u0026#39; elif self.celsius \u0026lt;= 28: return \u0026#39;warm\u0026#39; else: return \u0026#39;hot\u0026#39; class Country(Geographic, Temperature): def __init__(self, name, area, population): self.name = name self.area = area self.population = population def getPopulationDensity(self): return self.population / self.area def showDetails(self): print(\u0026#39;Country: %s\u0026#39; % self.name) print(\u0026#39;Area: %.2fsq km\u0026#39; % self.area) print(\u0026#39;Population: %d\u0026#39; % self.population) print(\u0026#39;Density: %.2fperson per sq km\u0026#39; % self.getPopulationDensity()) print(\u0026#39;Decimal cordinate: %s\u0026#39; % self.getCordinate()) print(\u0026#39;Time zone: %s\u0026#39; % self.getTimeZone()) print(\u0026#39;Climate: %s\u0026#39; % self.getClimate()) print(\u0026#39;Temperature in Celsius: %.2fdegree\u0026#39; % self.celsius) print(\u0026#39;Temperature in Fahrenheit: %.2fdegree\u0026#39; % self.getFahrenheit()) print(\u0026#39;Temperature in Kelvin: %.2f\u0026#39; % self.getKelvin()) print(\u0026#39;The weather is %s\u0026#39; % self.getWeather()) print() ในตัวอย่าง เราได้สร้าง super class มาสองคลาสคือ Geographic เป็นคลาสจัดการการทำงานในทางภูมิศาสตร์ และคลาสที่สอง Temperature เป็นคลาสสำหรับจัดการอุณหภูมิ ต่อไปเราจะมาอธิบายการทำงานของคลาสเหล่านี้อย่างละเอียด เพื่อให้คุณเข้าใจในการทำงานของมัน คุณอาจจะหยิบแก้วกาแฟของคุณมาดื่มไปด้วยก็ได้ เพราะมันอาจจะยาวสักหน่อย แต่เชื่อเถอะว่ามันสนุกแน่นอน\nclass Geographic: def setCordinate(self, latitude, longitude): self.latitude = latitude self.longitude = longitude def getCordinate(self): return str(self.latitude) + \u0026#39;, \u0026#39; + str(self.longitude) def getTimeZone(self): timezone = round(self.longitude / 12 - 1) if timezone \u0026gt; 0: return \u0026#39;+\u0026#39; + str(timezone) else: return str(timezone) def getClimate(self): if self.latitude \u0026lt;= -66.5 or self.latitude \u0026gt;= 66.5: return \u0026#39;Polar zone\u0026#39; elif self.latitude \u0026lt;= -23.5 or self.latitude \u0026gt;= 23.5: return \u0026#39;Temperate zone\u0026#39; else: return \u0026#39;Tropical zone\u0026#39; คลาสแรกของเราคือคลาส Geographic คลาสนี้รับผิดชอบการทำงานเกี่ยวกับภูมิศาสตร์ โดยเรามีเมธอด setCordinate() สำหรับกำหนดค่า latitude และ longitude ซึ่งนี่เป็นพิกัดที่ตั้งของสิ่งต่างๆ บนโลก ในคลาสนี้เราได้มีเมธอดที่สำคัญคือ getTimeZone() เป็นเมธอดสำหรับหาค่า timezone จาก longitude ซึ่งลองจิจูดหรือเส้นแวง เป็นเส้นระยะตามยาวของพื้นผิวโลก มันใช้สำหรับกำหนดเขตเวลาบนโลกออกเป็นเขตต่างๆ เนื่องจากโลกของเราเป็นทรงกลม ดังนั้นจึงทำให้เวลาในแต่ละพื้นที่แตกต่างกัน ดังรูปข้างล่าง\nต่อมาเป็นเมธอด getClimate() เมธอดนี้จะนำค่า latitude เส้นละติจูดหรือที่เรียกกันว่าเส้นรุ้ง ซึ่งมันใช้เป็นตัวแบ่งสภาพอากาศของโลกออกเป็นสามแบบใหญ่ๆ คือเขตร้อน เขตอบอุ่น และเขตขั้วโลก ดังนั้นเมธอดนี้จะบอกว่าพื้นที่นั้นอยู่ในเขตอากาศแบบไหน โดยคำนวณจากค่าละติจูด\nclass Temperature: def setCelsius(self, celsius): self.celsius = celsius def getFahrenheit(self): return self.celsius * 1.8 + 32 def getKelvin(self): return self.celsius + 273.15 def getWeather(self): if self.celsius \u0026lt;= 0: return \u0026#39;freezing\u0026#39; elif self.celsius \u0026lt;= 18: return \u0026#39;cold\u0026#39; elif self.celsius \u0026lt;= 28: return \u0026#39;warm\u0026#39; else: return \u0026#39;hot\u0026#39; ต่อมาเป็นคลาส Temperature คลาสนี้จัดการเกี่ยวกับอุณหภูมิ โดยมีเมธอด setCelsius() สำหรับรับค่าอุณหภูมิในหน่วยองศาเซลเซียส หลังจากนั้นเราได้มีเมธอดแปลงค่าหน่วยนี้ไปยังหน่วยอื่นๆ ในองศาฟาเรนไฮต์ และเคลวิน และมีเมธอด getWeather() สำหรับคำนวณหาสภาพอากาศว่าร้อน อบอุ่น หนาว หรือแช่แข็ง\nclass Country(Geographic, Temperature): def __init__(self, name, area, population): self.name = name self.area = area self.population = population def getPopulationDensity(self): return self.population / self.area def showDetails(self): print(\u0026#39;Country: %s\u0026#39; % self.name) print(\u0026#39;Area: %.2fsq km\u0026#39; % self.area) print(\u0026#39;Population: %d\u0026#39; % self.population) print(\u0026#39;Density: %.2fperson per sq km\u0026#39; % self.getPopulationDensity()) print(\u0026#39;Decimal cordinate: %s\u0026#39; % self.getCordinate()) print(\u0026#39;Time zone: %s\u0026#39; % self.getTimeZone()) print(\u0026#39;Climate: %s\u0026#39; % self.getClimate()) print(\u0026#39;Temperature in Celsius: %.2fdegree\u0026#39; % self.celsius) print(\u0026#39;Temperature in Fahrenheit: %.2fdegree\u0026#39; % self.getFahrenheit()) print(\u0026#39;Temperature in Kelvin: %.2f\u0026#39; % self.getKelvin()) print(\u0026#39;The weather is %s\u0026#39; % self.getWeather()) print() ตอนนี้เราได้สร้าง super class เสร็จไปแล้ว และคุณได้เข้าใจการทำงานของมันทั้งหมด ต่อไปเป็นการสร้างคลาส Country ซึ่งคลาสนี้สืบทอดจากคลาสทั้งสองก่อนหน้า นั่นจะทำให้มันมีแอตทริบิวต์และเมธอดทั้งหมดเหมือนกับ super class ของมัน\nสำหรับในคลาส Country เป็นคลาสของประเทศที่จะเก็บรายละเอียดต่างๆ โดยมีแอตทริบิวต์ name เป็นชื่อของประเทศ area เป็นขนาดพื้นที่มีหน่วยในตารางกิโลเมตร และ population เป็นจำนวนประชากรทั้งหมดในประเทศ และคลาสนี้มีสองเมธอดคือ getPopulationDensity() เป็นเมธอดสำหรับคำนวณความหนาแน่นของประชากรต่อพื้นที่หนึ่งตารางกิโลเมตร และเมธอด showDetails() สำหรับแสดงรายละเอียดทั้งหมดเกี่ยวกับประเทศ\nc = Country(\u0026#39;Thailand\u0026#39;, 513120, 68863514) c.setCordinate(13.75, 100.483333) c.setCelsius(28.5) c.showDetails() c2 = Country(\u0026#39;England\u0026#39;, 130279, 55268100) c2.setCordinate(51.5, -0.116667) c2.setCelsius(9) c2.showDetails() c2 = Country(\u0026#39;Canada\u0026#39;, 9984670, 35151728) c2.setCordinate(45.4, -75.666667) c2.setCelsius(-3) c2.showDetails() หลังจากสร้างคลาสเสร็จแล้ว ต่อไปเป็นการนำคลาส Country มาสร้างออบเจ็คของสามประเทศคือ ไทย อังกฤษ และแคนาดา โดยในแต่ละออบเจ็คได้กำหนดข้อมูลของประเทศ กำหนดพิกัดด้วยเมธอด setCordinate() กำหนดอุณหภูมิด้วยเมธอด setCelsius() และสุดท้ายเรียกดูรายละเอียดทั้งหมดด้วยเมธอด showDetails()\nCountry: Thailand Area: 513120.00 sq km Population: 68863514 Density: 134.21 person per sq km Decimal cordinate: 13.75, 100.483333 Time zone: +7 Climate: Tropical zone Temperature in Celsius: 28.50 degree Temperature in Fahrenheit: 83.30 degree Temperature in Kelvin: 301.65 The weather is hot Country: England Area: 130279.00 sq km Population: 55268100 Density: 424.23 person per sq km Decimal cordinate: 51.5, -0.116667 Time zone: -1 Climate: Temperate zone Temperature in Celsius: 9.00 degree Temperature in Fahrenheit: 48.20 degree Temperature in Kelvin: 282.15 The weather is cold Country: Canada Area: 9984670.00 sq km Population: 35151728 Density: 3.52 person per sq km Decimal cordinate: 45.4, -75.666667 Time zone: -7 Climate: Temperate zone Temperature in Celsius: -3.00 degree Temperature in Fahrenheit: 26.60 degree Temperature in Kelvin: 270.15 The weather is freezing นี่เป็นผลลัพธ์การทำงานของโปรแกรม ซึ่งเป็นการแสดงข้อมูลทางภูมิศาสตร์ อุณหภูมิและสภาพอากาศของแต่ละประเทศ ในตอนนี้คุณเห็นแล้วว่าเราได้ใช้การสืบทอดคลาสเพื่อทำให้คลาส Country มีความสามารถที่หลายหลากเหมือนกับ super class ของมัน\nMethod overriding สำหรับเรื่องสุดท้ายในบทนี้ จะเป็นการเรียนรู้เกี่ยวกับการ override เมธอด ซึ่งคือการที่ sub class ทำการกำหนดการทำงานให้กับเมธอดจาก super class ใหม่ โดยยังคงใช้ชื่อเดิม ซึ่งจะทำให้เกิดคลาสใหม่ในบริบทของ sub class และเมธอดจาก super class จะไม่สามารถเข้าถึงได้ มาดูตัวอย่างการทำงานของโปรแกรม\nclass Animal: def move(self): print(\u0026#39;Animal is moving\u0026#39;) class Dog(Animal): def move(self): print(\u0026#39;Dog is running\u0026#39;) def parentMove(self): print(\u0026#39;Call parent method\u0026#39;) Animal.move(self) a = Animal() a.move() d = Dog() d.move() d.parentMove() ในตัวอย่าง เราได้สร้างคลาส Animal โดยคลาสนี้มีเมธอด move() สำหรับแสดงข้อความการเคลื่อนที่ของสัตว์ ต่อมาเราได้สร้างคลาส Dog ซึ่งเป็นคลาสที่สืบทอดมาจากคลาส Animal ในคลาส Dog เราได้ทำการเขียนการทำงานของเมธอด move() ใหม่ เพื่อบอกว่าการเคลื่อนที่ของสุนัขนั้นคือการวิ่ง ดังนั้นการทำงานของเมธอดในคลาสหลักจึงถูกทับไป\nอย่างไรก็ตาม เรายังคงสามารถเรียกใช้งานเมธอดจากคลาสหลักได้ ในเมธอด parentMove() เป็นการเรียกใช้งานเมธอดจาก super class ในคำสั่ง Animal.move(self) ในตอนนี้ถึงแม้ว่าเราจะได้ทำการ override เมธอดนี้ไปแล้ว แต่เราก็ยังสามารถเรียกใช้มันได้เช่นเดิม\nAnimal is moving Dog is running Call parent method Animal is moving นี่เป็นผลลัพธ์การทำงานของโปรแกรม จะเห็นว่าการ override เมธอดนั้นเป็นการเขียนทับการทำงานเมธอดของ super class นี่มักจะใช้ในกรณีที่คุณต้องการการทำงานใหม่ที่แตกต่างจากเดิม แต่ยังคงต้องการใช้ชื่อเมธอดเดิมอยู่ และไม่ต้องการที่จะไปเปลี่ยนการทำงานของเมธอดใน super class\nในบทนี้ คุณได้เรียนรู้เกี่ยวกับการสืบทอดคลาสในภาษา Python ซึ่งเป็นแนวคิดการนำโค้ดเดิมกลับมาใช้โดยที่ไม่ต้องสร้างคลาสใหม่ที่มีแอตทริบิวต์และเมธอดเหมือนกันใหม่ทั้งหมด ซึ่งนี่จะทำให้คุณสามารถทำงานได้เร็วขึ้น และนอกจากนี้คุณยังได้เรียนรู้เกี่ยวกับการสืบทอดแบบหลายคลาส และการ override การทำงานของเมธอด\nReference : http://marcuscode.com\n"
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/learning-python/22_thread/",
	"title": "23. Thread",
	"tags": [],
	"description": "",
	"content": "ในบทนี้ คุณจะได้เรียนรู้เกี่ยวกับ Thread ในภาษา Python เราจะพูดเกี่ยวกับการสร้างและใช้งาน Thread และวิธีการนำ Thread มาช่วยเพื่อเพิ่มประสิทธิภาพให้กับโปรแกรมของเรา\nThread คืออะไร Thread (เทร็ด) คือลำดับการทำงานของชุดคำสั่งโปรแกรมที่เล็กที่สุดซึ่งโดยทั่วไปแล้วจะอยู่ภายใน Process โดยที่ในหนึ่ง Process นั้นจะสามารถมีได้หลาย Thread การใช้งาน Thread จะทำให้เราสามารถเขียนโปรแกรมที่ทำงานแบบคู่ขนานและใช้ทรัพยากรบางอย่างร่วมกัน ยกตัวอย่างเช่น หน่วยความจำ เมื่อมีหลาย Thread ทำงานพร้อมกัน เราจะเรียกการเขียนโปรแกรมในรูปแบบนี้ว่า Multi-thread\nรูปภาพแสดงการทำงานของ Thread และ Process\nโดยทั่วไปแล้ว โปรแกรมที่เราเขียนในภาษา Python นั้นจะรันอยู่ภายใน Thread หลัก ซึ่งเป็น Thread เริ่มต้นเมื่อโปรแกรมของภาษา Python เริ่มทำงาน ซึ่งภายใน Thread หลักนี้เอง เราสามารถสร้าง Thread อื่นๆ เพื่อใช้ประโยชน์จากมันได้\nการสร้าง Thread ในภาษา Python ในการสร้าง Thread นั้นเราสามารถสร้างได้จากคลาส Thread ที่อยู่ภายในโมดูล threading ซึ่งโมดูลนี้ประกอบไปด้วยคลาสต่างๆ ที่ใช้สำหรับสร้างและทำงานเกี่ยวกับ Thread นี่เป็นตัวอย่างการสร้าง Thread ในภาษา Python\nthread1.py\nimport threading def thread_callback(): print(\u0026#34;Hello inside Thread\u0026#34;) thr = threading.Thread(target=thread_callback) thr.start() นี่เป็นผลลัพธ์การทำงานของโปรแกรม\nHello inside Thread ในตัวอย่าง เราได้สร้าง Thread อย่างง่ายขึ้นมา โดย Thread นี้ใช้สำหรับแสดงข้อความทักทายง่ายๆ จากภายใน Thread\nimport threading คลาส Thread เป็นคลาสที่อยู่ภายใต้โมดูล theading ดังนั้นเราจึงต้องทำการ import โมดูลเข้ามาก่อนที่จะใช้งานคลาสที่ต้องการได้\nthr = threading.Thread(target=thread_callback) thr.start() หลังจากนั้นเราสร้าง Thread ใหม่ขึ้นมาเก็บไว้ในตัวแปร thr ในคอนสตรัคเตอร์นั้นเราสามารถส่งอาร์กิวเมนต์ target ซึ่งจะต้องเป็นฟังก์ชันที่สามารถเรียกใช้งานได้ และฟังก์ชันนี้จะทำงานเมื่อเราเรียกเมธอด start() บนออบเจ็ค Thread เพื่อให้ Thread เริ่มทำงาน\nในบางครั้ง คุณอาจจะต้องการส่งค่าเพื่อนำเข้าไปใช้งานในฟังก์ชัน callback คุณสามารถทำได้โดยการส่งผ่านอาร์กิวเมนต์ args ดังในตัวอย่างต่อไปนี้\nthread2.py\nimport threading def thread_callback(name, loop): for i in range(1, loop + 1): print(\u0026#34;%s: %i\u0026#34; % (name, i)) thr = threading.Thread(target=thread_callback, args=[\u0026#34;Thread-1\u0026#34;, 5]) thr.start() ในตัวอย่าง เราได้กำหนดค่าให้กับฟังก์ชัน thread_callback โดยการกำหนดผ่านอาร์กิวเมนต์ args ซึ่งเป็นอาเรย์ของค่าที่เราต้องการส่งเข้าไป เมื่อเราเรียกใช้งานเมธอด start() ค่าที่เราส่งผ่าน args จะถูกส่งเข้าไปยังพารามิเตอร์ name และ loop ตามลำดับ\nโดยที่ name นั้นเป็นชื่อที่เราต้องการกำหนดให้กับ Thread ส่วน loop นั้นเป็นจำนวนรอบที่เราต้องการแสดงตัวเลขภายใน Thread\nThread-1: 1 Thread-1: 2 Thread-1: 3 Thread-1: 4 Thread-1: 5 นี่เป็นผลลัพธ์การทำงานของโปรแกรม\nการสร้างคลาส Thread ในตัวอย่างก่อนหน้า เราได้สร้าง Thread ออบเจ็คจากคลาส Thread ซึ่งเป็นคลาสไลบรารี่ของภาษา Python ที่ใช้สำหรับสร้าง Thread ที่ไม่ซับซ้อนมาก อย่างไรก็ตาม คุณสามารถสร้างคลาส Thread ของคุณได้โดยการสืบทอดคลาสของคุณจากคลาส Thread นี่เป็นตัวอย่าง\nthread3.py\nfrom threading import Thread class MyThread(Thread): def __init__(self, firstName): Thread.__init__(self) self.firstName = firstName def run(self): print(\u0026#34;Hello \u0026#34; + self.firstName + \u0026#34; from \u0026#34; + self.name) thr1 = MyThread(\u0026#34;Meteo\u0026#34;) thr2 = MyThread(\u0026#34;Danny\u0026#34;) thr1.start() thr2.start() นี่เป็นผลลัพธ์การทำงานของโปรแกรม\nHello Meteo from Thread-1 Hello Danny from Thread-2 ในตัวอย่าง เราได้สร้างคลาสที่มีชื่อว่า MyThread และคลาสนี้ได้ทำการสืบทอดคลาสมาจากคลาส Thread ภายในคอนสตรัคเตอร์ของคลาสมีหนึ่งอาร์กิวเมนต์ firstName สำหรับกำหนดชื่อที่ต้องการแสดงการทักทายใน Thread\ndef run(self): print(\u0026#34;Hello \u0026#34; + self.firstName + \u0026#34; from \u0026#34; + self.name) คลาสที่ทำการสืบทอดมาจากคลาส Thread นั้นจะต้องทำการ override เมธอด run() ซึ่งเมธอดนี้จะทำงานเมื่อเราเรียกใช้งานเมธอด start() บนออบเจ็คของ Thread โดยเมธอดนี้ทำหน้าเหมือนกับเมธอด thread_callback() ในตัวอย่างก่อนหน้า\nภายในเมธอด run() มีสองแอตทริบิวต์ที่เราแสดงออกมาทางหน้าจอ แอตทริบิวต์แรกคือ self.firstName ซึ่งเป็นชื่อของคนที่ต้องการกล่าวทักทายที่เราส่งมาในตอนสร้างออบเจ็ค และแอตทริบิวต์ที่สอง self.name นั้นเป็นแอตทริบิวต์ชื่อของ Thread ที่สืบทอดมาจากคลาส Thread\nthr1 = MyThread(\u0026#34;Meteo\u0026#34;) thr2 = MyThread(\u0026#34;Danny\u0026#34;) thr1.start() thr2.start() หลังจากนั้นเราได้นำคลาสที่เราสร้างขึ้นมาสร้างออบเจ็ค Thread โดยการส่งชื่อที่ต้องการให้โปรแกรมกล่าวคำทักทายผ่านทางคอนสตรัคเตอร์ของคลาส และเรียกใช้งานเมธอด start() เพื่อให้ Thread เริ่มทำงาน\nการเขียนโปรแกรมแบบ Multi-thread Thread นั้นจะทำงานพร้อมกันแบบคู่ขนาน รวมทั้ง Thread หลักด้วย เพื่อแสดงให้คุณได้เห็น มาดูตัวอย่างของ Thread ที่มีการทำงานนานกว่าในตัวอย่างที่เราได้เห็นก่อนหน้า เราจะเขียนโปรแกรมเพื่อแสดงตัวเลข 1 - 5 จากภายใน Thread\nthread4.py\nfrom threading import Thread class Counter(Thread): def __init__(self, end): Thread.__init__(self) self.end = end def run(self): for i in range(1, self.end + 1): print(self.name + \u0026#34;: \u0026#34; + str(i)) thr1 = Counter(5) thr2 = Counter(5) thr1.start() thr2.start() จากในโค้ดตัวอย่างนั้น คลาส Counter นั้นเป็นคลาสที่สืบทอดมาจากคลาส Thread หน้าที่ของมันคือการแสดงตัวเลขระหว่าง 1 - end ภายใน Thread โดยที่ค่า end เป็นค่าที่ส่งเข้ามาในตอนสร้าง Thread\ndef run(self): for i in range(1, self.end + 1): print(self.name + \u0026#34;: \u0026#34; + str(i)) ภายในเมธอด run() เราได้เขียนคำสั่ง for loop เพื่อวนแสดงตัวเลขจาก 1 - end โดยที่ในตอนสร้าง Thread ทั้งสองเราได้ส่งค่า end ซึ่งมีค่าเท่ากับ 5 ดังนั้น Thread จะแสดงตัวเลขจาก 1 - 5 นั่นเอง และนอกจากนี้เรายังได้แสดงชื่อของ Thread จากแอตทริบิวต์ self.name เพื่อบอกให้ทราบว่าตัวเลขทีแสดงนั้นทำงานอยู่ใน Thread ไหน\nthr1 = Counter(5) thr2 = Counter(5) thr1.start() thr2.start() หลังจากที่เราสร้างคลาสเสร็จสิ้น เราได้นำคลาสของเรามาสร้าง Thread ออบเจ็ค โดยการกำหนดค่าสิ้นสุดของการนับเป็น 5 ผ่านทางคอนสตรัคเตอร์ คุณสามารถเปลี่ยนเป็นค่าอื่นได้ เพื่อให้โปรแกรมนับไปถึงจำนวนที่ต้องการ\nนี่เป็นผลลัพธ์การทำงานของโปรแกรม\nThread-1: 1 Thread-2: 1 Thread-1: 2 Thread-2: 2 Thread-1: 3 Thread-2: 3 Thread-1: 4 Thread-1: 5 Thread-2: 4 Thread-2: 5 จากตัวอย่างด้านบน เราสามารถเขียนในรูปแบบของฟังก์ชัน callback ได้ดังนี้ ซึ่งทั้งสองวิธีนั้นให้ผลลัพธ์ที่เหมือนกัน แต่ในวิธีนี้ คุณจะไม่สามารถเข้าถึงแอตทริบิวต์ self.name สำหรับชื่อของ Thread ที่สร้างอัตโนมัติได้ ดังนั้นถ้าหากต้องการกำหนดชื่อให้กับ Thread เราจำเป็นต้องกำหนดผ่านทางอาร์กิวเมนต์ args เพื่อส่งเข้าไปยังฟังก์ชันแทน\nfrom threading import Thread def thread_callback(name, end): for i in range(1, end + 1): print(name + \u0026#34;: \u0026#34; + str(i)) thr1 = Thread(target=thread_callback, args=[\u0026#39;Thread-1\u0026#39;, 5]) thr2 = Thread(target=thread_callback, args=[\u0026#39;Thread-2\u0026#39;, 5]) thr1.start() thr2.start() Thread Joining เมธอด join() นั้นเป็นเมธอดที่รอให้ Thread ทำงานให้จบก่อนที่จะทำในคำสั่งต่อไป เราใช้เมธอดนี้ในกรณีที่ต้องการรอการทำงานบางอย่างจาก Thread ยกตัวอย่างเช่น ก่อนที่จะทำงาน Thread ที่สองอาจจะต้องรอผลลัพธ์การทำงานจาก Thread แรกก่อน ดังนั้นก่อนที่เรียกใช้งาน Thread ที่สอง เราจำเป็นต้องรอให้ Thread แรกทำงานเสร็จก่อน มาดูตัวอย่าง\nthread_join1.py\nfrom threading import Thread class Counter(Thread): def __init__(self, end): Thread.__init__(self) self.end = end def run(self): for i in range(1, self.end + 1): print(self.name + \u0026#34;: \u0026#34; + str(i)) thr1 = Counter(5) thr1.start() # Block until thread 1 is done  thr1.join() thr2 = Counter(5) thr2.start() ในตัวอย่าง เป็นโปรแกรมนับตัวเลขเหมือนในตัวอย่างก่อนหน้า แต่ในตัวอย่างนี้ เราต้องการให้โปรแกรมทำงานใน Thread แรกเสร็จก่อน แล้วค่อยทำ Thread ที่สองต่อ ดังนั้นก่อนที่จะเริ่มการทำงานของ Thread ที่สอง เราสามารถเรียกใช้งานเมธอด join() เพื่อให้โปรแกรมรอการทำงานใน Thread แรกให้เสร็จก่อนได้\nThread-1: 1 Thread-1: 2 Thread-1: 3 Thread-1: 4 Thread-1: 5 Thread-2: 1 Thread-2: 2 Thread-2: 3 Thread-2: 4 Thread-2: 5 นี่เป็นผลลัพธ์การทำงานของโปรแกรม สังเกตว่าโปรแกรมจะแสดงตัวเลขใน Thread แรกจนเสร็จก่อนแล้วค่อยทำงานใน Thread ที่สอง นั่นเป็นเพราะผลของคำสั่ง join() ที่เราเรียกใช้งานก่อน Thread ที่สองเริ่มต้นทำงานนั่นเอง\nอีกตัวอย่างสำหรับการใช้งานเมธอด join() คือเมื่อเราต้องการรอผลลัพธ์จากหลาย Thread ก่อนที่จะทำงานต่อ ต่อไปมาดูตัวอย่างโปรแกรมเรียงตัวเลขในลิสต์ โดยใช้ความสามารถจาก Thread เข้ามาช่วย นี่เป็นโค้ดของโปรแกรม\nthread_join2.py\nfrom threading import Thread class BubbleSorting(Thread): def __init__(self, numbers): Thread.__init__(self) self.numbers = numbers def run(self): n = len(self.numbers) for i in range(0, n): for j in range(0, n - i - 1): if self.numbers[j] \u0026gt; self.numbers[j+1]: temp = self.numbers[j] self.numbers[j] = self.numbers[j + 1] self.numbers[j + 1] = temp # List of numbers to sort numbers = [8, 14, 4, 2, 1, 17, 12, 3, 0, 4, 16, 11] # Slice list into half and supply to each thread thr1 = BubbleSorting(numbers[0:6]) thr2 = BubbleSorting(numbers[6:12]) thr1.start() thr2.start() # Wait for all threads to complete thr1.join() thr2.join() # Obtain sorted lists from threads list1 = thr1.numbers list2 = thr2.numbers len1 = len(list1) len2 = len(list2) # Merge sorted lists to final list sorted_numbers = [] i = j = 0 while i \u0026lt; len1 and j \u0026lt; len2: if list1[i] \u0026lt;= list2[j]: sorted_numbers.append(list1[i]) i += 1 else: sorted_numbers.append(list2[j]) j += 1 while (i \u0026lt; len1): sorted_numbers.append(list1[i]) i += 1 while (j \u0026lt; len2): sorted_numbers.append(list1[j]) j += 1 print(\u0026#34;Sorted from Thread-1:\u0026#34;) print(list1) print(\u0026#34;Sorted from Thread-2:\u0026#34;) print(list2) print(\u0026#34;Final sorted:\u0026#34;) print(sorted_numbers) และนี่เป็นผลลัพธ์การทำงานของโปรแกรม\nSorted from Thread-1: [1, 2, 4, 8, 14, 17] Sorted from Thread-2: [0, 3, 4, 11, 12, 16] Final sorted: [0, 1, 2, 3, 4, 4, 8, 11, 12, 14, 16, 17] ในตัวอย่าง เป็นโปรแกรมเรียงตัวเลขจากน้อยไปมาก โดยเราจะแบ่งลิสต์ของตัวเลขออกเป็นสองส่วนเท่าๆ กัน และส่งลิสต์เหล่านั้นเข้าไปจัดเรียงภายในคลาส BubbleSorting ด้วยอัลกอริทึม Bubble sort หลังจากทีทุก Thread เรียงตัวเลขเสร็จแล้ว เราได้นำลิสต์ทั้งสองมารวมกันใน Thread หลัก ต่อไปจะเป็นการอธิบายการทำงานของโค้ดในแต่ละส่วน\nclass BubbleSorting(Thread): def __init__(self, numbers): Thread.__init__(self) self.numbers = numbers def run(self): n = len(self.numbers) for i in range(0, n): for j in range(0, n - i - 1): if self.numbers[j] \u0026gt; self.numbers[j+1]: temp = self.numbers[j] self.numbers[j] = self.numbers[j + 1] self.numbers[j + 1] = temp ในตอนแรกของโปรแกรม เราได้สร้างคลาส BubbleSorting คลาสนี้มีหน้าที่รับเอาลิสต์ของตัวเลขและนำมาเรียงจากน้อยไปมากด้วยอัลกอริทึม Bubble sort ที่เรากำหนดการทำงานไว้ในเมธอด run()\nnumbers = [8, 14, 4, 2, 1, 17, 12, 3, 0, 4, 16, 11] thr1 = BubbleSorting(numbers[0:6]) thr2 = BubbleSorting(numbers[6:12]) เรามีลิสต์ของตัวเลขที่ยังไม่ได้จัดเรียง และเราได้แบ่งลิสต์ออกเป็นสองลิสต์เท่าๆ กันและส่งเข้าไปยัง Thread เพื่อจัดเรียง หลังจากนั้นสั่งให้ Thread ทั้งสองเริ่มต้นทำงานด้วยเมธอด start()\nthr1.join() thr2.join() list1 = thr1.numbers list2 = thr2.numbers เนื่องจากว่าเราต้องการนำผลลัพธ์จาก Thread ทั้งสองมารวมกัน ดังนั้นเราได้เรียกใช้งานเมธอด join() เพื่อรอให้ Thread ทั้งสองเรียงตัวเลขให้เสร็จก่อน แล้วค่อยนำมาตัวเลขที่จัดเรียงแล้วออกมารวมกันอีกที\nsorted_numbers = [] i = j = 0 while i \u0026lt; len1 and j \u0026lt; len2: if list1[i] \u0026lt;= list2[j]: sorted_numbers.append(list1[i]) i += 1 else: sorted_numbers.append(list2[j]) j += 1 while (i \u0026lt; len1): sorted_numbers.append(list1[i]) i += 1 while (j \u0026lt; len2): sorted_numbers.append(list1[j]) j += 1 หลังจากที่เราได้ลิสต์จากทั้งสอง Thread ที่จัดเรียงแล้ว เราสามารถนำลิสต์ที่เรียงแล้วนั้นมา Merge เข้าด้วยกันได้\n Time Complexity เนื่องจากการเรียงตัวเลขจากลิสต์นั้นใช้เวลา O(n^2) เมื่อ n คือจำนวนของสมาชิกภายในลิสต์ ดังนั้นจากการลดขนาดของลิสต์ออกเป็นครึ่งหนึ่งทำให้เราลดเวลาเหลือเพียง O(n/2^2) ซึ่งถือว่าเร็วขึ้นมากๆ เนื่องจากการนำลิสต์ที่จัดเรียงแล้วมาเรียงกันใช้เวลาเพียง O(n) คุณสามารถเรียนรู้เพิ่มเติมเกี่ยวกับเรื่องนี้ได้ในวิชาอัลกอริทึมในหัวข้อ Time Complexity\n จากตัวอย่างก่อนหน้า เป็นเพียงการแสดงวิธีการใช้เมธอด join() เพื่อรอผลลัพธ์จากทั้งสอง Thread ให้ทำงานเสร็จเท่านั้น อย่างไรก็ตามในการเรียงข้อมูลในลิสต์นั้นคุณสามารถใช้เมธอด sort() ได้ ซึ่งนี่จะได้ผลลัพธ์เหมือนกับโปรแกรมด้านบน\n# Achieve the same result numbers = [8, 14, 4, 2, 1, 17, 12, 3, 0, 4, 16, 11] print(\u0026#34;Initial list\u0026#34;) print(numbers) numbers.sort() print(\u0026#34;Sorted list\u0026#34;) print(numbers) Thread synchronization Thread synchronization คือการที่ Thread ตั้งแต่สอง Thread ขึ้นไปเข้าถึงขอบเขตของโปรแกรมบางส่วนพร้อมกันๆ ในเวลาเดียวกัน ยกตัวอย่างเช่น การเข้าถึงตัวแปรตัวเดียวกัน ซึ่งขอบเขตดังกล่าวนั้นเรียกว่า Critical section ซึ่งเมื่อเกิดเหตุการณ์นี้ขึ้นอาจทำให้โปรแกรมทำงานผิดพลาดหรือไม่ได้ผลลัพธ์อย่างที่คาดหวังได้ ดังนั้นในภาษา Python มีคลาสสำหรับจัดการเกี่ยวกับ Thread synchronization เช่น Lock, RLock และ Semaphor ซึ่งคุณจะได้เรียนรู้ในบทต่อไป\nในบทนี้ เราได้ครอบคลุมเกี่ยวกับการใช้งาน Thread ในภาษา Python เบื้องต้น ในตอนนี้คุณสามารถใช้ประโยชน์จาก Thread เพื่อให้โปรแกรมทำงานแบบคู่ขนานกันได้\nReference : http://marcuscode.com/lang/python/threads\n"
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/phyblas/intermediate/inheritance/",
	"title": "การรับทอด",
	"tags": [],
	"description": "",
	"content": "นอกจากการสร้างคลาสขึ้นมาใหม่ตั้งแต่เริ่มต้นแล้วเรายังสามารถนำคลาสที่มี อยู่แล้วมาเสริมให้เป็นคลาสใหม่ได้ วิธีการนี้เรียกว่าการรับทอด (inheritance)\nวิธีการนี้มีประโยชน์เพราะสามารถใช้ประโยชน์จากคลาส เดิมที่มีอยู่แล้วโดยไม่ต้องสร้างใหม่แค่นำมาเปลี่ยนแปลงแก้ไขให้เข้ากับการใช้งานตามที่ต้องการมากขึ้นเท่านั้น\nเมื่อเราสร้างคลาสใหม่ขึ้นด้วย วิธีการรับทอด คลาสใหม่ที่สร้างจะถูกเรียกว่าเป็นซับคลาส (subclass) ของคลาสเดิม และคลาสเดิมก็จะเรียกว่าเป็นซูเปอร์คลาส (superclass) ของคลาสใหม่ คลาสที่สร้างมาจากการรับทอดจะมีแอตทริบิวต์และเมธอด เหมือนกับซูเปอร์คลาสของมัน แต่สามารถเพิ่มเมธอดหรือแอตทริบิวต์ใหม่ลงไป หรือเขียนทันของเก่าได้\nอินสแตนซ์ของซับคลาสจะเป็นอินสแตนซ์ของซูเปอร์คลาสไปด้วย แต่อินสแตนซ์ของซูเปอร์คลาสจะไม่เป็นอินสแตนซ์ของซับคลาสไปด้วย การรับทอดทำได้โดยการใส่ชื่อคลาสที่ต้องการรับทอดไว้ในวงเล็บหลังชื่อคลาสใหม่ตอนที่ประกาศสร้างคลาสใหม่ขึ้น\nการสร้างคลาสด้วยการรับทอด จะขอยกตัวอย่างที่ต่อเนื่องจากบทที่แล้ว ในบทที่แล้วได้สร้างคลาส \u0026quot;ผู้กล้า\u0026quot; ขึ้น ซึ่งผู้กล้านี้ก็อาจสามารถแบ่งย่อยเป็นอาชีพต่างๆได้อีกเช่นนักรบหรือจอมเวทย์\nในบทนี้เราจะสร้างคลาสเหล่านี้ขึ้นมาใหม่โดยรับทอดจากคลาส \u0026quot;ผู้กล้า\u0026quot;\nclass อาวุธ: def __init__(self,ชื่อ,พลังโจมตีกายภาพ,พลังโจมตีเวทย์,ความทนทาน): self.ชื่อ = ชื่อ self.พลังโจมตีกายภาพ = พลังโจมตีกายภาพ self.พลังโจมตีเวทย์ = พลังโจมตีเวทย์ self.ความทนทาน = ความทนทาน class เสื้อผ้า: def __init__(self,ชื่อ,พลังป้องกัน,ความทนทาน): self.ชื่อ = ชื่อ self.พลังป้องกัน = พลังป้องกัน self.ความทนทาน = ความทนทาน class ผู้กล้า: def __init__(self,ชื่อ,เลเวล=1,ความแข็งแรง=4,ความอดทน=4,hpสูงสุด=10): self.ชื่อ = ชื่อ self.เลเวล = เลเวล self.ความแข็งแรง = ความแข็งแรง self.ความอดทน = ความอดทน self.hpสูงสุด = hpสูงสุด self.hp = hpสูงสุด เสื้อผ้า = เสื้อผ้า(\u0026#39;ชุดเก่าๆ\u0026#39;,3,5) อาวุธ = อาวุธ(\u0026#39;มีดสั้นเก่าๆ\u0026#39;,3,0,5) เงินเดือน = 500 def พลังโจมตี(self): return self.ความแข็งแรง + self.อาวุธ.พลังโจมตีกายภาพ def พลังป้องกัน(self): return self.ความอดทน + self.เสื้อผ้า.พลังป้องกัน def ถูกโจมตี(self,ความเสียหาย): if(ความเสียหาย\u0026gt;self.พลังป้องกัน()): self.hp -= ความเสียหาย - self.พลังป้องกัน() else: self.hp -= 1 if(self.hp\u0026lt;0): self.hp = 0 class นักรบ(ผู้กล้า): เสื้อผ้า = เสื้อผ้า(\u0026#39;ชุดนักรบฝึกหัด\u0026#39;,5,5) อาวุธ = อาวุธ(\u0026#39;ดาบฝึกหัด\u0026#39;,5,0,5) class จอมเวทย์(ผู้กล้า): def __init__(self,ชื่อ,เลเวล=1,ความแข็งแรง=4,พลังเวทย์=4,ความอดทน=4,hpสูงสุด=10,mpสูงสุด=10): self.ชื่อ = ชื่อ self.เลเวล = เลเวล self.พลังเวทย์ = พลังเวทย์ self.ความแข็งแรง = ความแข็งแรง self.ความอดทน = ความอดทน self.hpสูงสุด = hpสูงสุด self.hp = hpสูงสุด self.mpสูงสุด = mpสูงสุด self.mp = mpสูงสุด เสื้อผ้า = เสื้อผ้า(\u0026#39;ชุดจอมเวทย์ฝึกหัด\u0026#39;,2,5) อาวุธ = อาวุธ(\u0026#39;คฑาฝึกหัด\u0026#39;,0,5,5) def พลังโจมตีเวทย์(self): return self.พลังเวทย์ + self.อาวุธ.พลังโจมตีเวทย์ จะเห็นว่ามีการสร้างคลาสขึ้นใหม่ ๓ คลาส คือ \u0026ldquo;อาวุธ\u0026rdquo;, \u0026ldquo;เสื้อผ้า\u0026rdquo; และ \u0026ldquo;ผู้กล้า\u0026rdquo; ซึ่งใกล้เคียงกับบทที่แล้วแต่ต่างไปเล็กน้อย จากนั้นก็สร้างคลาสใหม่ขึ้นอีก ๒ คลาสโดยวิธีการรับทอด นั่นคือ \u0026ldquo;นักรบ\u0026rdquo; และ \u0026ldquo;จอมเวทย์\u0026rdquo; ซึ่งจะเห็นได้ว่ามีวงเล็บ \u0026ldquo;ผู้กล้า\u0026rdquo; อยู่ข้างหลัง ซึ่งแสดงถึงว่าทั้ง ๒ คลาสนี้รับทอดมาจาก \u0026ldquo;ผู้กล้า\u0026rdquo; นั่นเอง\nในคลาส \u0026ldquo;นักรบ\u0026rdquo; ไม่ได้มีการเพิ่มหรือแก้ไขเมธอด แต่มีแค่การใส่ค่าแอตทริบิวต์ในคลาส นั่นคือ \u0026ldquo;อาวุธ\u0026rdquo; และ \u0026ldquo;เสื้อผ้า\u0026rdquo; ใหม่ ซึ่งแอตทริบิวต์นี้จะไปทับของที่มีอยู่แล้วในคลาส \u0026ldquo;ผู้กล้า\u0026rdquo; ส่วนคลาส \u0026ldquo;จอมเวทย์\u0026rdquo; ก็มีการเปลี่ยน \u0026ldquo;อาวุธ\u0026rdquo; และ \u0026ldquo;เสื้อผ้า\u0026rdquo; เหมือนกัน และยังมีการนิยามเมธอด __init__ ขึ้นใหม่ ซึ่งเมธอดนี้จะไปทับ __init__ ทำให้ใช้อันใหม่นี้แทน ซึ่งข้อแตกต่างจะเห็นว่ามีการเพิ่ม \u0026ldquo;พลังเวทย์\u0026rdquo; และ \u0026ldquo;mpสูงสุด\u0026rdquo; ขึ้นมา\nนอกจากนี้ยังเพิ่มเมธอด \u0026ldquo;พลังโจมตีเวทย์\u0026rdquo; ซึ่งไม่ได้ถูกนิยามขึ้นในคลาส \u0026ldquo;ผู้กล้า\u0026rdquo; ตั้งแต่แรก เมธอดนี้จึงถูกสร้างขึ้นใหม่และใช้ได้เฉพาะออบเจ็กต์ของคลาส \u0026ldquo;จอมเวทย์\u0026rdquo; เท่านั้น คลาส \u0026ldquo;นักรบ\u0026rdquo; ไม่มีการนิยาม __init__ ขึ้นมาใหม่ ดังนั้นจึงมีเมธอด init ที่เหมือนกับคลาส \u0026ldquo;ผู้กล้า\u0026rdquo; ทุกประการ จะเห็นว่า __init__ ของ \u0026ldquo;จอมเวทย์\u0026rdquo; นั้นต่างจากของ \u0026ldquo;ผู้กล้า\u0026rdquo; ไม่มาก แค่เพิ่มพารามิเตอร์ขึ้นมาเท่านั้น ในกรณีแบบนี้เราอาจไม่ต้องเขียนใหม่ทั้งหมดแต่ใช้ฟังก์ชัน __init__ ของ \u0026ldquo;ผู้กล้า\u0026rdquo; ได้ สามารถทำได้โดยเขียนใหม่เป็น\nclass จอมเวทย์(ผู้กล้า): def __init__(self,ชื่อ,เลเวล=1,ความแข็งแรง=4,พลังเวทย์=4,ความอดทน=4,hpสูงสุด=10,mpสูงสุด=10): ผู้กล้า.__init__(self,ชื่อ,เลเวล,ความแข็งแรง,ความอดทน,hpสูงสุด) self.พลังเวทย์ = พลังเวทย์ self.mpสูงสุด = mpสูงสุด self.mp = mpสูงสุด จะเห็นว่ามีการเรียกใช้ __init__ ของ \u0026ldquo;ผู้กล้า\u0026rdquo; ภายในเมธอด __init__ ของ \u0026ldquo;จอมเวทย์\u0026rdquo; อีกที โดยพารามิเตอร์ก็ต้องใส่ให้สัมพันธ์กันด้วย พารามิเตอร์ที่ซ้ำกับคลาส \u0026ldquo;ผู้กล้า\u0026rdquo; จะถูกป้อนค่าให้กับแอตทริบิวต์ของออบเจ็กต์ด้วย __init__ ด้านในนี้ ส่วนพารามิเตอร์ที่เหลือซึ่งเพิ่มเข้ามาก็ค่อยมาป้อนให้กับแอตทริบิวต์ของออบเจ็กต์อีกที นอกนี้ยังมีวิธีเขียนอีกแบบ นั่นคือใช้ฟังก์ชัน super\nclass จอมเวทย์(ผู้กล้า): def __init__(self,ชื่อ,เลเวล=1,ความแข็งแรง=4,พลังเวทย์=4,ความอดทน=4,hpสูงสุด=10,mpสูงสุด=10): super(จอมเวทย์,self).__init__(ชื่อ,เลเวล,ความแข็งแรง,ความอดทน,hpสูงสุด) self.พลังเวทย์ = พลังเวทย์ self.mpสูงสุด = mpสูงสุด self.mp = mpสูงสุด ฟังก์ชัน super ต้องการอาร์กิวเมนต์ ๒ ตัว ตัวแรกคือคลาส ตัวหลังคือออบเจ็กต์ ในที่นี้ออบเจ็กต์ถูกแทนด้วย self ผลที่ได้คือเป็นการที่ออบเจ็กต์ของคลาสนี้เรียกเมธอดของซุเปอร์คลาสของคลาส มัน ในที่นี้คืออบเจ็กต์ของคลาส \u0026ldquo;จอมเวทย์\u0026rdquo; เรียกใช้เมธอดของคลาส \u0026ldquo;ผู้กล้า\u0026rdquo; ซึ่งเป็นซูเปอร์คลาส สังเกตได้ว่าพอใช้ super แล้ว ในอาร์กิวเมนต์ของ init ก็ไม่ต้องมี self แล้ว อย่างไรก็ตามกรณีที่ฟังก์ชัน super นี้ถูกใช้ในโครงสร้างคลาสจะสามารถละอาร์กิวเมนต์ได้ ดังนั้นจึงเขียนแค่นี้ได้\nclass จอมเวทย์(ผู้กล้า): def __init__(self,ชื่อ,เลเวล=1,ความแข็งแรง=4,พลังเวทย์=4,ความอดทน=4,hpสูงสุด=10,mpสูงสุด=10): super().__init__(ชื่อ,เลเวล,ความแข็งแรง,ความอดทน,hpสูงสุด) self.พลังเวทย์ = พลังเวทย์ self.mpสูงสุด = mpสูงสุด self.mp = mpสูงสุด ***การละแบบนี้ทำได้เฉพาะในไพธอน 3 ส่วนในไพธอน 2 ไม่สามารถละอาร์กิวเมนต์แบบนี้ได้ ต้องเขียนเต็มเท่านั้น รายละเอียด ลองสร้างออบเจ็กต์มาทดสอบการใช้กันดูได้เลย\nผู้เล่นA = จอมเวทย์(\u0026#39;มานะ\u0026#39;,1,5,8,4,12,11) ผู้เล่นB = นักรบ(\u0026#39;พากเพียร\u0026#39;,1,7,6,14) print(ผู้เล่นA.เสื้อผ้า.ชื่อ) # ได้ ชุดจอมเวทย์ฝึกหัด  print(ผู้เล่นB.เสื้อผ้า.ชื่อ) # ได้ ชุดนักรบฝึกหัด  print(ผู้เล่นA.hp) # ได้ 12  ผู้เล่นA.ถูกโจมตี(10) print(ผู้เล่นA.hp) # ได้ 8 การรับทอดหลายต่อ การรับทอดสามารถทำได้หลายต่อเป็นทอดๆกี่ครั้งก็ได้ เช่นนักรบก็อาจแบ่งเป็นนักดาบและนักธนู จอมเวทย์ก็อาจแบ่งเป็นจอมเวทมนตร์ขาวและจอมเวทมนตร์ดำ เป็นต้น\nclass นักดาบ(นักรบ): 0 class นักธนู(นักรบ): อาวุธ = อาวุธ(\u0026#39;ธนูฝึกหัด\u0026#39;,6,0,5) class จอมเวทมนตร์ดำ(จอมเวทย์): 0 class จอมเวทมนตร์ขาว(จอมเวทย์): 0 ในที่นี้ขอละการเขียนรายละเอียดของคลาสใหม่นี้เพิ่มเติม แต่หลักการก็คล้ายๆเดิม คือ \u0026ldquo;นักดาบ\u0026rdquo; และ \u0026ldquo;นักธนู\u0026rdquo; จะรับทอดเมธอดและแอตทริบิวต์ของ \u0026ldquo;นักรบ\u0026rdquo; ซึ่งรับทอดแอตทริบิวต์ของ \u0026ldquo;ผู้กล้า\u0026rdquo; มาอีกต่อ ซับคลาสของซับคลาสของคลาสหนึ่งก็ถือเป็นซับคลาสของคลาสนั้นด้วย ดังนั้น \u0026ldquo;นักดาบ\u0026rdquo; ถือเป็นซับคลาสของ \u0026ldquo;ผู้กล้า\u0026rdquo; ไปด้วย และออบเจ็กต์ของคลาส \u0026ldquo;นักดาบ\u0026rdquo; ก็จะเป็นอินสแตนซ์ของคลาส \u0026ldquo;นักรบ\u0026rdquo; แล้วก็เป็นอินสแตนซ์ของคลาส \u0026ldquo;ผู้กล้า\u0026rdquo; ไปด้วย ความจริงแล้วคลาสที่เราสร้างขึ้นมาจากเริ่มต้นโดยไม่ได้ใส่วงเล็บไว้ข้างหลัง นั้นก็ถือเป็นการรับทอดคลาสที่ชื่อว่า \u0026ldquo;object\u0026rdquo; อยู่แล้วในตัว เพียงแต่สามารถละได้เท่านั้น โดยทั่วไปจึงไม่ต้องเขียนวงเล็บ แต่ถ้าจะเขียนก็จะเห็น\nclass ผู้กล้า(object): ซึ่งก็มีค่าเหมือนเขียน\nclass ผู้กล้า: นั่นหมายความว่าจริงๆแล้วคลาสทุกชนิดเป็นซับคลาสของคลาสที่ชื่อ object นั่นเพราะในไพธอนนั้นข้อมูลทุกอย่างล้วนเป็นออบเจ็กต์ ดังนั้นไม่ว่าอะไรก็ตามจึงเป็นอินสแตนซ์ของคลาสที่ชื่อ object นั่นเอง หากเรียงลำดับการรับทอดในตัวอย่างนี้ก็จะเป็น\nobject \u0026gt; ผู้กล้า \u0026gt; นักรบ \u0026gt; นักดาบ การรับทอดจากหลายคลาส ในการรับทอดนั้นที่จริงอาจสามารถรับทอดจากหลายๆคลาสพร้อมกันได้ ไม่จำกัดว่ารับทอดได้แค่คลาสเดียว หากจะรับทอดจากหลายคลาสก็แค่ใส่หลายๆคลาสลงในวงเล็บข้างหลังชื่อคลาสตอน ประกาศสร้างคลาส เช่น ลองสร้างคลาส \u0026ldquo;นักรบเวทย์\u0026rdquo; ขึ้นมาเป็นซับคลาสของ \u0026ldquo;นักรบ\u0026rdquo; กับ \u0026ldquo;นักเวทย์\u0026rdquo;\nclass นักรบเวทย์(นักรบ,จอมเวทย์): 0 กรณีที่คลาสทั้งสองที่รับทอดมานั้นมีการนิยามเมธอดหรือแอตทริบิวต์เหมือนกันจะยึดตามตัวที่ชื่อขึ้นก่อน ในที่นี้แอตทริบิวต์ \u0026ldquo;เสื้อผ้า\u0026rdquo; กับ \u0026ldquo;อาวุธ\u0026rdquo; ต่างก็ถูกนิยามใหม่ในคลาส \u0026ldquo;นักรบ\u0026rdquo; และ \u0026ldquo;จอมเวทย์\u0026rdquo; แต่ \u0026ldquo;นักรบ\u0026rdquo; ขึ้นก่อน ดังนั้นแอตทริบิวต์นี้จะถูกนิยามตาม \u0026ldquo;นักรบ\u0026rdquo; ในขณะที่ \u0026ldquo;จอมเวทย์\u0026rdquo; มีนิยามเมธอด __init__ ขึ้นมาใหม่แต่ \u0026ldquo;นักรบ\u0026rdquo; ไม่มี ดังนั้นเมธอด __init__ ของ \u0026ldquo;นักรบเวทย์\u0026rdquo; ก็จะรับทอด __init__ ของ \u0026ldquo;จอมเวทย์\u0026rdquo;\nผู้เล่นD = นักรบเวทย์(\u0026#39;หรรษา\u0026#39;) print(นักรบเวทย์.เสื้อผ้า.ชื่อ) # ได้ ชุดนักรบฝึกหัด  print(นักรบเวทย์.อาวุธ.ชื่อ) # ได้ ดาบฝึกหัด  print(ผู้เล่นD.mpสูงสุด) # ได้ 10 อนึ่ง ที่จริงแล้วการรับทอดจาก ๒ คลาสขึ้นไปพร้อมกันนั้นในบางภาษาเช่นภาษาจาวาจะไม่สามารถทำได้ และนักเขียนโปรแกรมบางคนก็ไม่สนับสนุนการทำแบบนี้เพราะอาจทำให้เกิดปัญหาได้ในกรณีที่ชื่อตัวแปรหรือเมธอดมีการซ้อนทับกัน กรณีแบบนี้จะต้องมีอย่างใดอย่างหนึ่งหายไปและทำให้มีการทำงานไม่สมบูรณ์ ในกรณีของ C++ หากมีเมธอดชื่อซ้ำกันแล้วไม่ได้ระบุไว้ว่าจะให้เหลือของฝ่ายไหนก็จะเกิดข้อผิดพลาดขึ้น ดังนั้นแม้ว่าภาษาไพธอนจะสามารถรับทอดจาก ๒ คลาสขึ้นไปได้ แต่ก็ไม่ควรจะทำโดยไม่มีความจำเป็นและต้องระวังด้วยว่า ๒ คลาสนั้นไม่มีเมธอดหรือแอตทริบิวต์ที่ชื่อซ้ำ ไม่มีผลข้างเคียงอะไรหากรับทอดมาพร้อมกัน\nเมธอดหรือแอตทริบิวต์ที่ชื่อขึ้นต้นด้วย __ โดยทั่วไปแล้วเมธอดและแอตทริบิวต์จะตั้งชื่อเป็นอะไรก็ได้ หลักการตั้งชื่อก็เหมือนตัวแปรทั่วไป แต่ว่าจะมีกรณีพิเศษเกิดขึ้นหากตั้งชื่อโดยมีขีดล่างสองอันนำหน้า\nเมธอดหรือแอตทริบิวต์ที่ชื่อขึ้นต้นด้วย __ จะไม่สามารถเข้าถึงได้โดยตรงจากภายนอกคลาส ยกตัวอย่าง ประกาศคลาส \u0026quot;ผู้กล้า\u0026quot; ใหม่โดยเปลี่ยนแค่ให้แอตทริบิวต์ \u0026ldquo;เงินเดือน\u0026rdquo; มี __ นำหน้า\nclass ผู้กล้า: def __init__(self,ชื่อ): self.ชื่อ = ชื่อ __เงินเดือน = 500 จากนั้นลองสร้างออบเจ็กต์แล้วเข้าถึงค่า\nผู้เล่นJ = ผู้กล้า(\u0026#39;เจ\u0026#39;) print(ผู้เล่นJ.__เงินเดือน) จะขึ้นว่า\nAttributeError: \u0026#39;ผู้กล้า\u0026#39; object has no attribute \u0026#39;__เงินเดือน\u0026#39; หรือแม้แต่เข้าถึงผ่านคลาสก็ได้ผลแบบเดียวกัน คือจะขึ้นว่าไม่มีแอตทริบิวต์นี้\nprint(ผู้กล้า.__เงินเดือน) โดยปกติแล้วเป็นธรรมเนียมปฏิบัติที่จะตั้งชื่อแอตทริบิวต์หรือเมธอดที่ไม่ต้องการให้มีการเข้าถึงโดยตรงจากภายนอกโดยขึ้นต้นด้วยขีดล่าง แต่การใส่ขีดล่างเพียงขีดเดียวไม่มีผลอะไรในทางปฏิบัติ จึงเป็นเพียงแค่ธรรมเนียมปฏิบัติ* ส่วนการใส่ขีดล่างสองขีดจึงจะมีผลจริงๆ (*ความจริงแล้วมีผลอยู่เล็กน้อย แต่ไม่ได้สำคัญดังนั้นจะยังไม่พูดถึงในตอนนี้) แต่การเข้าถึงโดยใช้จากภายในยังสามารถทำได้ตามปกติ เช่นลองสร้างเมธอดที่ใช้ค่า \u0026quot;__เงินเดือน\u0026quot; ขึ้นมา\nclass ผู้กล้า: def __init__(self,ชื่อ): self.ชื่อ = ชื่อ __เงินเดือน = 500 def แสดงเงินเดือน(self): return self.__เงินเดือน ผู้เล่นK = ผู้กล้า(\u0026#39;เค\u0026#39;) print(ผู้เล่นK.แสดงเงินเดือน()) # ได้ 500 จะเห็นว่าจากภายนอกเข้าถึงโดยตรงไม่ได้แต่สามารถเห็นผลของค่านั้นได้โดยอ้อมเช่นผ่านเมธอด ในที่นี้ใช้เมธอด \u0026ldquo;แสดงเงินเดือน\u0026rdquo; อย่างไรก็ตามจริงๆแล้วไม่ใช่ว่าจะเข้าถึงโดยตรงไม่ได้ หากต้องการก็สามารถทำได้เช่นกัน แต่ชื่อจะถูกเปลี่ยนโดยต้องขึ้นต้นด้วยขีดล่างหนึ่งขีดตามด้วยชื่อคลาส ในที่นี้จะเป็น _ผู้กล้า__เงินเดือน ดังนั้นลอง\nprint(ผู้เล่นK._ผู้กล้า__เงินเดือน) # ได้ 500 จะพบว่าแสดงค่าได้ตามปกติไม่เกิดปัญหา ดังนั้นก็ไม่ใช่ว่าจะสามารถซ่อนค่าแอตทริบิวต์ได้สมบูรณ์จริงๆอยู่ดีแม้จะตั้ง ชื่อแบบนี้ เพราะแค่เขียนชื่อยาวโดยเพิ่มชื่อคลาสขึ้นมาก็เข้าถึงโดยตรงได้แล้ว ในบางภาษาอาจมีการซ่อนแอตทริบิวต์หรือเมธอดจากการเข้าถึงจากภายนอก แต่ในไพธอนไม่สามารถทำแบบนั้นได้ เพียงแต่วิธีนี้มักถูกเปรียบเทียบว่าเสมือนคล้ายการซ่อนซึ่งทำได้ในบางภาษา (บางคนก็เข้าใจผิดว่านี่เป็นการซ่อน) แต่ประโยชน์จริงๆของการทำแบบ นี้คือในกรณีที่มีการสืบทอดคลาส สามารถป้องกันไม่ให้มีการเขียนทับได้แม้จะนิยามแอตทริบิวต์หรือเมธอดที่ชื่อ ซ้ำกันขึ้นมา\nclass ผู้กล้า: def __init__(self,ชื่อ): self.ชื่อ = ชื่อ __เงินเดือน = 500 def แสดงเงินเดือน(self): return self.__เงินเดือน class นักรบ(ผู้กล้า): __เงินเดือน = 1000 ผู้เล่นL = นักรบ(\u0026#39;แอล\u0026#39;) print(ผู้เล่นL.แสดงเงินเดือน()) # ได้ 500 จะเห็นว่าเมธอด \u0026ldquo;แสดงเงินเดือน\u0026rdquo; ซึ่งมีไว้ใช้คืนค่า __เงินเดือน นั้นคืนค่าเงินเดือน 500 ซึ่งเป็นค่าของคลาส \u0026ldquo;ผู้กล้า\u0026rdquo; ทั้งๆที่โดยปกติแล้วหากรับทอดมาแล้วมีการนิยามแอตทริบิวต์ซ้ำมันก็น่าจะถูก เขียนทับ ดังนั้นจึงควรได้ค่า 1000 ซึ่งเป็นค่าใหม่ นั่นเป็นเพราะว่าแอตทริบิวต์หรือเมธอดที่ขึ้นต้นด้วย __ จะไม่ถูกเขียนทับคลาสที่รับทอดมา เพราะชื่อจริงๆของมันจะต้องมีชื่อคลาสนำหน้า ดังนั้นจึงแบ่งแยกกันชัดเจน\nprint(ผู้เล่นL._ผู้กล้า__เงินเดือน) # ได้ 500  print(ผู้เล่นL._นักรบ__เงินเดือน) # ได้ 1000 เท่ากับว่ามีเงินเดือนของผู้กล้าแล้วก็ยังมีเงินเดือนของนักรบอีกแยกต่างหาก เมธอด \u0026ldquo;แสดงเงินเดือน\u0026rdquo; ถูกประกาศในคลาส \u0026ldquo;ผู้กล้า\u0026rdquo; ดังนั้นจึงใช้ \u0026quot;__เงินเดือน\u0026quot; ของคลาส \u0026ldquo;ผู้กล้า\u0026rdquo; แต่หากนิยามเมธอดใหม่ในคลาส \u0026quot;นักรบ\u0026quot; ค่า \u0026quot;__เงินเดือน\u0026quot; ในคลาส \u0026ldquo;นักรบ\u0026rdquo; จะถูกใช้แทน ลองเขียนใหม่โดยเปลี่ยนจาก \u0026quot;__เงินเดือน\u0026quot; เป็น \u0026ldquo;เงินเดือน\u0026rdquo; ซึ่งไม่มีขีดล่างสองขีดนำหน้า หรือจะมีขีดเดียว หรือจะเป็นชื่ออื่นก็ได้ จะพบว่าผลลัพธ์ที่ได้นั้นจะต่างกันออกไป โดยจะได้ค่า 1000 แทนที่จะเป็น 500\nclass ผู้กล้า: def __init__(self,ชื่อ): self.ชื่อ = ชื่อ เงินเดือน = 500 def แสดงเงินเดือน(self): return self.เงินเดือน class นักรบ(ผู้กล้า): เงินเดือน = 1000 ผู้เล่นM = นักรบ(\u0026#39;เอ็ม\u0026#39;) print(ผู้เล่นM.แสดงเงินเดือน()) # ได้ 1000  print(ผู้เล่นM.เงินเดือน) # ได้ 1000 ตัวอย่างข้างต้นเป็นกรณีของแอตทริบิวต์ สำหรับเมธอดเองก็สามารถทำได้ในลักษณะเดียวกัน\nclass ผู้กล้า: def __init__(self,ชื่อ): self.ชื่อ = ชื่อ def __แสดงเงินเดือน(self): return 500 class นักรบ(ผู้กล้า): def __แสดงเงินเดือน(self): return 1000 ผู้เล่นN = นักรบ(\u0026#39;เอ็น\u0026#39;) print(ผู้เล่นN._ผู้กล้า__แสดงเงินเดือน()) # ได้ 500  print(ผู้เล่นN._นักรบ__แสดงเงินเดือน()) # ได้ 1000 อนึ่ง หากชื่อเมธอดลงท้ายด้วย __ ต่อให้ขึ้นต้นด้วย __ ก็จะไม่มีคุณสมบัติดังที่ว่านี้ เช่นพวกเมธอดพิเศษอย่าง __init__ จะเข้าถึงได้ด้วยชื่อเมธอดตามปกติ\nอ้างอิง\nhttp://docs.python.jp/3/reference/datamodel.html\nhttp://www.lifewithpython.com/2014/01/python-super-function.html\nhttp://shin.hateblo.jp/entry/2013/11/01/211716\nhttp://methane.hatenablog.jp/entry/20081227/1230400144\nhttp://yut.hatenablog.com/entry/20110120/1295533994\nhttp://qiita.com/icoxfog417/items/e8f97a6acad07903b5b0\nhttp://www.geocities.jp/m_hiroi/light/abcruby12.html\n Reference : https://phyblas.hinaboshi.com/tsuchinoko23\n "
},
{
	"uri": "https://yo-sarawut.github.io/tutorials/learning-python/24_date-time/",
	"title": "24. Date &amp; Time (วันที่และเวลา)",
	"tags": [],
	"description": "",
	"content": "ในบทนี้ คุณจะได้เรียนรู้เกี่ยวกับวันที่และเวลาในภาษา Python เราจะพูดถึงการทำงานพื้นฐานเกี่ยวกับวันที่และเวลา เช่น การแสดงเวลาปัจจุบัน การบวกลบเวลา เขตเวลา และแนะนำคลาสและเมธอดเกีี่ยวกับวันที่และเวลา นี่เป็นเนื้อหาในบทนี้\n วันที่และเวลาปัจจุบัน การสร้างออบเจ็ควันที่และเวลา Unix timestamp การบวกลบวันที่และเวลา คลาสและโมดูลเกี่ยวกับวันที่และเวลา  วันที่และเวลาปัจจุบัน ในการเขียนโปรแกรมเกี่ยวกับเวลา สิ่งแรกที่เรามักทำคือการแสดงวันที่และเวลาปัจจุบันออกทางหน้าจอเพื่อแจ้งให้ผู้ใช้งานโปรแกรมได้ทราบ สำหรับตัวอย่างแรกในบทนี้ เราจะมาเขียนโปรแกรมเพื่อแสดงวันที่และเวลาปัจจุบันออกทางหน้าจอในภาษา Python\ncurrent_time.py\nfrom datetime import datetime # Get current date and time now = datetime.today() # Display using difference formats print(now) print(now.isoformat()) print(now.ctime()) นี่เป็นผลลัพธ์การทำงานของโปรแกรม\n2020-11-05 02:23:48.841250 2020-11-05T02:23:48.841250 Thu Nov 5 02:23:48 2020 ในตัวอย่างนี้ เราได้แสดงวันที่และเวลาปัจจุบันของระบบออกทางหน้าจอ เมื่อคุณรันตัวอย่างนี้ เวลาที่ได้จะเป็นเวลาปัจจุบันบนคอมพิวเตอร์ของคุณ\nfrom datetime import datetime เพื่อเข้าถึงวันที่และเวลาในภาษา Python เราสามารถใช้คลาส datetime ซึ่งเป็นคลาสจากโมดูล datetime คลาสนี้เป็นคลาสที่เราสามารถนำมาสร้างออบเจ็คของวันที่ที่ประกอบไปด้วยข้อมูลของวันที่และเวลาที่สามารถนำมาใช้งานในโปรแกรมได้\nnow = datetime.today() ในคำสั่งนี้เป็นการสร้างออบเจ็คของวันที่โดยการใช้คลาสเมธอด datetime.today() เมธอดนี้ส่งค่ากลับเป็นออบเจ็คของวันที่ของเวลาปัจจุบันในระบบหรือคอมพิวเตอร์ของเรา\nprint(now) print(now.isoformat()) print(now.ctime()) จากนั้นเป็นการรับเอาค่าของเวลาในรูปแบบ String จากการเรียกใช้เมธอดบนออบเจ็ค ถ้าหากเราแสดงค่าออบเจ็คด้วยฟังก์ชัน print() โดยตรง ค่าที่ได้จะเป็นเวลาในรูปแบบ ISO หรือเราสามารถเรียกผ่านเมธอด isoformat() ตรงๆ ก็ได้ ส่วนเมธอด ctime() ส่งค่ากลับเป็นวันที่ในรูปแบบวันที่มาตฐานของภาษา C\nนอกจากนี้ เรายังสามารถเรียกใช้งานเมธอดอื่นบนออบเจ็คของวันที่เพื่ออ่านค่าอื่นๆ เกี่ยวกับเวลาได้ ยกตัวอย่างเช่น เราสามารถอ่านค่า Timestamp หรือจัดรูปแบบการแสดงผลของเวลาได้\ntimeinfo.py\nfrom datetime import datetime now = datetime.today() print(now.timestamp()) print(now.strftime(\u0026#34;%d/%m/%Y %H:%M:%S\u0026#34;)) print(now.timetuple()) นี่เป็นผลลัพธ์การทำงานของโปรแกรม สำหรับการใช้งานเมธอดเพื่อเรียกดูข้อมูลเพิ่มเติมเกี่ยวกับออบเจ็คของวันทีี่\n1604518694.336215 05/11/2020 02:38:14 time.struct_time(tm_year=2020, tm_mon=11, tm_mday=5, tm_hour=2, tm_min=38, tm_sec=14, tm_wday=3, tm_yday=310, tm_isdst=-1) ในตัวอย่าง เราสามารถใช้เมธอด timestamp() เพื่อรับเอาค่าเวลาในรูปแบบ Timestamp จากออบเจ็ควันที่ได้ ส่วนเมธอด strftime() ใช้สำหรับจัดรูปแบบการแสดงของเวลาตามตัวจัดรูปแบบที่ระบุ หรือการใช้เมธอด struct_time() ที่จะส่งค่ากลับเป็น Time tuple ที่ประกอบไปด้วยส่วนประกอบต่างๆ ของเวลา\nเราจะพูดเกี่ยวกับ Timestamp และการจัดรูปแบบการแสดงผลของเวลาอีกครั้งในอีกไม่ช้านี้ สำหรับตอนนี้มาดูเพิ่มเติมเกี่ยวกับการสร้างออบเจ็คของวันที่และเวลาในภาษา Python กันต่อ\nการสร้างออบเจ็คของวันที่และเวลา ในตัวอย่างก่อนหน้าเราได้พูดถึงการรับเอาวันที่และเวลาปัจจุบันด้วยเมธอด today() ในตัวอย่างนี้ เราจะพูดถึงการสร้างออบเจ็คจากวันที่และเวลาที่กำหนด โดยการใช้คอนสตรัคเตอร์ของคลาส datetime ซึ่งนี่อาจมีประโยชน์เมื่อเรามีค่าของวันที่อยู่แล้วอาจจากฐานข้อมูลหรือไฟล์ และต้องการนำมาสร้างเป็นออบเจ็ควันที่เพื่อใช้งานในโปรแกรม\nในตัวอย่างนี้แสดงการสร้างออบเจ็คของวันที่โดยการระบุส่วนของวันที่และเวลาเป็นตัวเลขด้วยคลาสคอนสตรัคเตอร์ datetime\ncreate_date.py\nfrom datetime import datetime birthDay = datetime(1980, 3, 12, 10, 0, 0) chrismasDay = datetime(2020, 12, 25) print(\u0026#34;My birth day: %s\u0026#34; % birthDay.ctime()) print(\u0026#34;Christmas day: %s\u0026#34; % chrismasDay.ctime()) นี่เป็นผลลัพธ์การทำงานของโปรแกรม\nMy birth day: Wed Mar 12 10:00:00 1980 Christmas day: Fri Dec 25 00:00:00 2020 ในตัวอย่างนี้ เป็นการสร้างออบเจ็คของวันที่จากคลาส datetime สำหรับเก็บค่าวันเกิดและวันคริสมาสต์โดยการใช้คลาสคอนสตรัคเตอร์ ในการสร้างวันที่ด้วยวิธีนี้ จะทำให้เราสามารถสร้างออบเจ็คของวันที่สำหรับช่วงเวลาใดๆ ก็ได้ ซึ่งคอนสตรัคเตอร์จะรับพารามิเตอร์โดยมีรูปแบบดังนี้\ndatetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0) เราจะต้องระบุส่วนต่างๆ ของเวลาที่ต้องการสร้างโดยเรียงจาก ปี เดือน และวัน ตามลำดับ ซึ่งค่าของวันที่ในสามพารามิเตอร์แรกจะต้องถูกส่งเสมอ ส่วนพารามิเตอร์ที่เหลือสามาารถที่จะละเว้นได้ ถ้าหากเราไม่ส่งค่าเริ่มต้นที่เป็น 0 จะถูกใช้แทนเหมือนกับในออบเจ็ค chrismasDay\nในบางกรณี คุณอาจต้องการสร้างวันที่จากรูปแบบอื่นๆ นอกจากตัวเลข ยกตัวอย่างเช่น เราอาจมีค่าของวันที่ที่เป็น String ในรูปแบบของ ISO หรือค่าเวลา Timestamp ซึ่งคลาส datetime มีเมธอดสนับสนุนการสร้างวันที่จากรูปแบบดังกล่าว ยกตัวอย่างเช่น\ncreate_date2.py\nfrom datetime import datetime birthDay = datetime.fromisoformat(\u0026#34;1980-03-12T10:00:00\u0026#34;) chrismasDay = datetime.fromtimestamp(1608829200) print(\u0026#34;My birth day: %s\u0026#34; % birthDay.ctime()) print(\u0026#34;Christmas day: %s\u0026#34; % chrismasDay.ctime()) นี่เป็นผลลัพธ์การทำงานของโปรแกรม\nMy birth day: Wed Mar 12 10:00:00 1980 Christmas day: Fri Dec 25 00:00:00 2020 ในตัวอย่างนี้ เป็นการสร้างออบเจ็คของวันที่ที่เป็นวันเดียวกันกับในตัวอย่างก่อนหน้า แต่เราได้สร้างวันที่จากค่าของเวลาในรูปแบบ String และ Timestamp แทน และแนะนำการใช้งานสองเมธอดใหม่ที่ใช้ในการสร้าง\nbirthDay = datetime.fromisoformat(\u0026#34;1980-03-12T10:00:00\u0026#34;) เมธอด datetime.fromisoformat() นั้นเป็นคลาสเมธอดที่ใช้สำหรับสร้างวันที่จาก String ของวันที่ในรูปแบบ ISO เราสามารถใช้มันกับค่าวันที่เพียงอย่างเดียวหรือวันที่ในรูปแบบเต็มก็ได้\nchrismasDay = datetime.fromtimestamp(1608829200) ส่วนเมธอด datetime.fromtimestamp() ก็เป็นคลาสเมธอดเช่นเดียวกัน แต่เมธอดนี้ใช้สำหรับสร้างออบเจ็คของวันที่จากค่าเวลา Timestamp\nในการใช้งานทั้งสองเมธอดสำหรับสร้างออบเจ็ค เราจะได้ออบเจ็คของวันที่ที่สามารถนำมาใช้งานได้ในโปรแกรมเหมือนกับการรับค่าเวลาจากเมธอด today() และการสร้างวันที่จากคลาสคอนสตรัคเตอร์ datetime\nUnix timestamp Unix timestamp หรือ Timestamp นั้นเป็นค่าของเวลาในรูปแบบของตัวเลขในหน่วยวินาที ที่เริ่มนับจาก Unix epoch หรือวันที่ 1 มกราคม 1970 เนื่องจาก Timestamp เป็นตัวเลข ดังนั้นเราสามารถใช้มันในการคำนวณ เช่น การบวกลบ หรือการหาผลต่างของเวลาได้\nในตัวอย่างนี้ เราจะมาเขียนโปรแกรมเพื่อรับเอาค่า Timestamp ของเวลาปัจจุบันและจากออบเจ็คของวันที่เพื่อนำมาใช้งานในโปรแกรม\ncurrent_timestamp.py\nfrom datetime import datetime from time import time # Get current timestamp ts1 = datetime.today().timestamp() ts2 = time() print(\u0026#34;Current timestamp\u0026#34;) print(ts1) print(ts2) # Creating date from timestamp # Mon Jun 18 05:28:00 2007 date = datetime.fromtimestamp(1182119280) print(date) นี่เป็นผลลัพธ์การทำงานของโปรแกรม\nCurrent timestamp 1604522143.585108 1604522143.5851078 2007-06-18 05:28:00 ในตัวอย่างนี้ เป็นการรับเอาค่า Timestamp ปัจจุบันและการสร้างออบเจ็คของวันที่จาก Timestamp ในภาษา Python\nts1 = datetime.today().timestamp() ts2 = time() ในการรับเอาค่า Timestamp ปัจจุบันในภาษา Python นั้นสามารถทำได้สองวิธีคือการใช้เมธอด timestamp() บนออบเจ็คของวันที่ หรือจะใช้ฟังก์ชัน time() จากโมดูล time ก็ได้ ทั้งสองรูปแบบให้ผลลัพธ์ที่เหมือนกัน\ndate = datetime.fromtimestamp(1182119280) นอกจากนี้เรายังสามารถสร้างออบเจ็คของวันที่จาก Timestamp ได้โดยการใช้คลาสเมธอด datetime.fromtimestamp() เมธอดนี้ส่งค่ากลับเป็นออบเจ็ควันที่จากค่า Timestamp ดังกล่าว\nเราสามารถเรียกใช้งานเมธอด timestamp() บนออบเจ็คของวันที่ใดๆ เพื่อรับเอาค่าเวลา Timestamp บนออบเจ็คนั้นได้\nการบวกลบวันที่และเวลา เวลาในภาษา Python นั้นสนับสนุนการดำเนินการกับเวลา เช่น การบวกและการลบกันของเวลา สำหรับการดำเนินการเหล่านี้เกี่ยวกับเวลา เราจำเป็นต้องแนะนำให้คุณรู้จักกับ timedelta ออบเจ็ค\ntimedelta ออบเจ็คเป็นออบเจ็คที่ใช้เก็บระยะเวลา หรือความแตกต่างระหว่างสองวันที่หรือช่วงเวลาใดๆ ยกตัวอย่างเช่น เพลงๆ หนึ่งมีความยาว 3 นาที 20 วินาที หรือแสงเดินทางจากดวงอาทิตย์มายังโลกใช้เวลาประมาณ 8 นาที ข้อมูลเหล่านี้สามารถแสดงได้ในรูปแบบของ timedelta ในภาษา Python นี่เป็นตัวอย่าง\ndelta_time.py\nfrom datetime import timedelta dt1 = timedelta(minutes = 3, seconds = 20) dt2 = timedelta(minutes = 8) print(\u0026#34;Duration of a song\u0026#34;) print(dt1) print(\u0026#34;Light travel from the sun to the earth\u0026#34;) print(dt2) นี่เป็นผลลัพธ์การทำงานของโปรแกรม\nDuration of a song 0:03:20 Light travel from the sun to the earth 0:08:00 ในตัวอย่างนี้ เราได้สร้างสอง timedelta ออบเจ็คสำหรับเก็บระยะเวลาของเพลง และระยะเวลาการเดินทางของแสงจากดวงอาทิตย์มายังโลก ในการสร้าง timedelta ออบเจ็ค เราสามารถระบุเพียง Keyword อาร์กิวเมนต์สำหรับส่วนของเวลาที่ต้องการได้ สำหรับอาร์กิวเมนต์อื่นๆ ที่ไม่ได้ถูกส่งจะมีค่าเริ่มต้นเป็น 0\nนี่เป็นรูปแบบเต็มของการสร้าง timedelta ออบเจ็คในภาษา Python\ntimedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0) ในรูปแบบการประกาศออบเจ็ค จะเห็นว่ามีพารามิเตอร์สำหรับหน่วยเวลาต่างๆ ที่สามารถใช้สร้างออบเจ็คได้ อย่างไรก็ตาม สำหรับการเก็บข้อมูลภายในของ timedelta ออบเจ็คนั้น ค่าที่ถูกเก็บจริงๆ จะมีเพียงแค่ days, seconds และ microseconds เท่านั้น นี่เป็นอีกตัวอย่าง\ntimedelta_internal_data.py\nfrom datetime import timedelta dt1 = timedelta(weeks = 2, minutes = 3, seconds = 20) print(\u0026#34;dt1.days: %d\u0026#34; % dt1.days) print(\u0026#34;dt1.seconds: %d\u0026#34; % dt1.seconds) print(\u0026#34;dt1.microseconds: %d\u0026#34; % dt1.microseconds) print(\u0026#34;dt1 Total second: %d\u0026#34; % dt1.total_seconds()) นี่เป็นผลลัพธ์การทำงานของโปรแกรม\ndt1.days: 14 dt1.seconds: 200 dt1.microseconds: 0 dt1 Total second: 1209800 ในตัวอย่างนี้ แสดงให้เห็นว่า timedelta ออบเจ็คแปลงอาร์กิวเมนต์ที่เราใช้ในตอนสร้างให้เหลือเพียง days, seconds และ microseconds เท่านั้น เราสามารถเรียกใช้เมธอด total_seconds() เพื่อรับเอาจำนวนวินาทีทั้งหมดของ timedelta ออบเจ็คได้\nในภาษา Python การบวกลบออบเจ็คของเวลาจะเกี่ยวกับข้องกับ timedelta ออบเจ็ค ถ้าหากเราบวกเวลาเข้ากับ timedelta ออบเจ็ค เราจะได้ผลลัพธ์ของเวลาข้างหน้าตามระยะที่ถูกบวกเข้าไป ในทางกลับกัน เมื่อเราลบเวลาด้วย timedelta ออบเจ็ค เราจะได้เวลาที่ถอยหลังไปตามระยะเวลาที่ถูกลบออก\nในตัวอย่างนี้มาดูการหาเวลาสิ้นสุดของการเล่นเพลง โดยที่เราทราบเวลาเริ่มต้นและความยาวของเพลงโดยการใช้การบวกวันที่เข้ากับ timedelta ออบเจ็ค\ntime_addition.py\nfrom datetime import datetime, timedelta start = datetime(2020, 11, 1, 10, 5, 0) duration = timedelta(minutes = 3, seconds = 20) # Result is a new date object end = start + duration print(\u0026#34;A song started playing at %s\u0026#34; % start.ctime()) min = int(duration.total_seconds() / 60) sec = duration.total_seconds() % 60 print(\u0026#34;With duration of %dminutes and %dseconds\u0026#34; % (min, sec)) print(\u0026#34;Time when the song end is %s\u0026#34; % end.ctime()) นี่เป็นผลลัพธ์การทำงานของโปรแกรม\nA song started playing at Sun Nov 1 10:05:00 2020 With duration of 3 minutes and 20 seconds Time when the song end is Sun Nov 1 10:08:20 2020 ในตัวอย่างนี้ เป็นการบวกออบเจ็คของเวลาเข้ากับ timedelta ออบเจ็คซึ่งได้จะผลลัพธ์เป็นออบเจ็คของเวลาใหม่ที่เลื่อนเวลาไปข้างหน้าตามช่วงเวลาที่กำหนดใน timedelta ออบเจ็ค\nstart = datetime(2020, 11, 1, 10, 5, 0) duration = timedelta(minutes = 3, seconds = 20) เราได้สร้างออบเจ็คของวันที่สำหรับเก็บเวลาเริ่มต้นของการเล่นเพลงๆ หนึ่ง จากนั้นสร้าง timedelta ออบเจ็คสำหรับเก็บความยาวของเพลงซึ่งมีระยะเวลาเป็น 3 นาทีกับ 20 วินาที\nend = start + duration จากนั้นเป็นการบวกเวลาเริ่มต้นการเล่นกับระยะเวลาของเพลงเข้าด้วยกัน นี่จะทำให้เราได้ออบเจ็คใหม่ซึ่งเป็นเวลาในตอนที่เพลงจบพอดี\nนี่เป็นวิธีสำหรับการบวกวันที่และเวลากับ timedelta ออบเจ็คในภาษา Python เพื่อให้ได้เวลาใหม่โดยอ้างอิงจากออบเจ็คของเวลาที่ต้องการ\nตัวอย่างต่อมาเป็นการลบออบเจ็คของวันที่ด้วย timedelta นี่จะทำให้เราได้เวลาใหม่ถอยหลังไปจากช่วงของเวลาที่ลบออกไป นี่เป็นตัวอย่างของโปรแกรมเพื่อหาว่าการก่อสร้างอาคารนี้ได้เริ่มต้นเมื่อไหร่\ntime_subtraction.py\nfrom datetime import datetime, timedelta completed_date = datetime(2014, 6, 10, 12, 0, 0) duration = timedelta(days = 453, hours = 4) started_date = completed_date - duration print(\u0026#34;The construction completed at %s\u0026#34; % completed_date.ctime()) print(\u0026#34;The construction started at %s\u0026#34; % started_date.ctime()) นี่เป็นผลลัพธ์การทำงานของโปรแกรม\nThe construction completed at Tue Jun 10 12:00:00 2014 The construction started at Thu Mar 14 08:00:00 2013 ในตัวอย่างนี้ เป็นโปรแกรมสำหรับคำนวณหาว่าการก่อสร้างเริ่มต้นขึ้นเมื่อไหร่ โดยสิ่งที่เราทราบคือวันที่ที่การก่อสร้างเสร็จสิ้น และระยะเวลาในการก่อสร้าง ดังนั้นการนำสองค่านี้มาลบกันจะทำให้เราได้รับวันที่เริ่มก่อสร้าง\ncompleted_date = datetime(2014, 6, 10, 12, 0, 0) duration = timedelta(days = 453, hours = 4) ก่อนอื่นเราได้สร้างออบเจ็คของวันที่สำหรับเก็บวันที่ที่การก่อสร้างเสร็จสิ้นในตัวแปร completed_date จากนั้นสร้างออบเจ็ค duration สำหรับเก็บระยะเวลาการก่อสร้างที่ใช้ระยะเวลาทั้งสิ้น 453 วันกับอีก 4 ชั่วโมง\nstarted_date = completed_date - duration จากนั้นเป็นการลบวันที่ที่การก่อสร้างเสร็จสิ้นด้วยระยะเวลาในการก่อสร้าง จะทำได้เราได้รับเวลาเริ่มต้นของการก่อสร้างอาคารนี้\nในการลบวันที่ด้วยออบเจ็คของ timedelta ผลลัพธ์ที่ได้จะเป็นออบเจ็คของวันที่ใหม่ที่หักลบออกจากช่วงเวลาใน timedelta ออบเจ็ค อย่างไรก็ตามการลบเวลาในภาษา Python นั้น เราสามารถลบออบเจ็คของสองวันที่ออกจากกันได้ เมื่อทำเช่นนี้จะทำให้เราได้ผลต่างของเวลาในรูปแบบของ timedelta ออบเจ็ค\nในตัวอย่างต่อไปนี้ จะเป็นการแสดงวิธีการหาผลต่างของเวลาที่เกิดจากการลบกันระหว่างออบเจ็คของสองวันที่\nMateo ใช้เวลาในการทำข้อสอบเริ่มจาก 8 นาฬิกา 30 นาที และเสร็จสิ้นในตอน 12 นาฬิกา 45 นาที เราต้องการทราบว่าเขาใช้เวลาทั้งหมดในการทำข้อสอบเท่าไร นี่เป็นตัวอย่างของโปรแกรมสำหรับคำนวณหาระยะทั้งหมดที่ Mateo ใช้ในการทำข้อสอบครั้งนี้\ntime_difference.py\nfrom datetime import datetime, timedelta # Test started start = datetime(2020, 11, 5, 8, 30, 0) # Test ended end = datetime(2020, 11, 5, 12, 45, 0) # Result is a timedelta object diff = end - start print(\u0026#34;Time started %s\u0026#34; % start.ctime()) print(\u0026#34;Time finihsed %s\u0026#34; % end.ctime()) total_seconds = diff.total_seconds() print(\u0026#34;Time used to finish the test is %dseconds\u0026#34; % total_seconds) # Format time by ourselves hour = int(total_seconds / 3600) min = int(total_seconds % 3600 / 60) sec = int(total_seconds % 60) print(\u0026#34;Or %dhours %dmins %ssecs\u0026#34; % (hour, min, sec)) นี่เป็นผลลัพธ์การทำงานของโปรแกรม\nTime started Thu Nov 5 08:30:00 2020 Time finished Thu Nov 5 12:45:00 2020 Time used to finish the test is 15300 seconds Or 4 hours 15 mins 0 secs ในตัวอย่างนี้ เป็นการหาผลต่างของเวลาสองช่วงเวลาโดยการนำเวลามาลบกัน ผลลัพธ์ที่ได้จากการลบกันของออบเจ็คของเวลาคือ timedelta ออบเจ็ค\nstart = datetime(2020, 11, 5, 8, 30, 0) end = datetime(2020, 11, 5, 12, 45, 0) เรามีออบเจ็คของวันที่สำหรับเก็บเวลาเริ่มต้นและสิ้นสุดของการทำข้อสอบ เนื่องจากวันเริ่มต้นและวันสิ้นสุดเป็นวันเดียวกัน เราสามารถกำหนดวันที่เป็นอะไรก็ได้\ndiff = end - start จากนั้นเป็นการนำออบเจ็คของเวลาทั้งสองมาลบกัน นี่จะได้ผลลัพธ์เป็น timedelta ออบเจ็คที่เป็นผลต่างระหว่างวันที่ทั้งสอง นั่นคือเวลาทั้งหมดที่ Mateo ใช้ในการทำข้อสอบนั่นเอง\ntotal_seconds = diff.total_seconds() print(\u0026#34;Time used to finish the test is %dseconds\u0026#34; % total_seconds) เราสามารถใช้เมธอด total_seconds() เพื่อดูผลต่างของเวลาในหน่วยวินาที แต่เนื่องจากการแสดงเวลาในหน่วยของนาทีนั้นยากต่อการอ่าน เราจึงจัดรูปแบบการแสดงผลของเวลาโดยเริ่มจากหน่วยที่ใหญ่ที่สุดก่อนดังนี้\nhour = int(total_seconds / 3600) min = int(total_seconds % 3600 / 60) sec = int(total_seconds % 60) print(\u0026#34;Or %dhours %dmins %ssecs\u0026#34; % (hour, min, sec)) เนื่องจากเรามีเวลาทั้งหมดเป็นวินาที เราสามารถนำมันแยกออกเป็นหน่วยของชั่วโมง นาที และวินาทีได้ ซึ่งการแสดงผลแบบนี้จะทำให้เข้าใจง่ายกว่า\nคลาสและโมดูลเกี่ยวกับวันที่และเวลา ในภาษา Python ยังมีคลาสอื่นๆ เกี่ยวกับวันที่และเวลาที่ยังไม่ได้พูดถึงในบทนี้ แต่จะแนะนำให้คุณรู้จักกับคลาสเหล่านั้นไว้ก่อน นี่เป็นรายชื่อของคลาสส่วนหนึ่งที่สามารถใช้ได้เมื่อต้องการทำงานกับวันที่และเวลาในภาษา Python\n คลาส timedelta เป็นออบเจ็คสำหรับเก็บระยะเวลาหรือผลต่างของเวลา คลาส date เป็นออบเจ็คที่เก็บข้อมูลเกี่ยวกับวันที่เท่านั้น คุณสามารถใช้คลาสนี้ได้เมื่อไม่ต้องการข้อมูลเกี่ยวกับเวลา คลาส time เป็นออบเจ็คที่เก็บข้อมูลเกี่ยวกับเวลาเท่านั้น คุณสามารถใช้คลาสนี้ได้เมื่อไม่ต้องการข้อมูลเกี่ยวกับวันที่ คลาส datetime เป็นออบเจ็คที่เก็บข้อมูลทั้งวันที่และเวลา ซึ่งเป็นคลาสที่ใช้บ่อยและคุณได้รู้จักกับมันแล้วในบทนี้ คลาส timezone เป็นออบเจ็คของเขตเวลาที่ใช้กำหนดเขตเวลาให้กับออบเจ็ควันที่และเวลา  ในการเขียนโปรแกรม โดยทั่วไปแล้วมักใช้งานคลาส datetime เป็นหลัก แต่ในบางกรณี คุณอาจต้องการทำงานกับวันที่หรือเวลาเท่านั้น ในกรณีดังกล่าว คุณสามารถอ่านเพิ่มเติมเกี่ยวกับคลาสเฉพาะเหล่านี้ได้ที่นี่ https://docs.python.org/3/library/datetime.html\nในบทนี้ คุณได้เรียนรู้เกี่ยวกับวันที่และเวลาในภาษา Python เราได้พูดถึงการนำค่าวันที่และเวลาปัจจุบันในระบบมาใช้ในโปรแกรมเพื่อแสดงผลหรือคำนวณ การสร้างออบเจ็คของเวลากับค่าวันที่และเวลาแบบกำหนดเอง และการดำเนินการกับเวลาเช่น การบวกและการลบเวลา\nReference : http://marcuscode.com/lang/python/date-and-time\n"
},
{
	"uri": "https://yo-sarawut.github.io/404.html",
	"title": "Whoops! Page not found",
	"tags": [],
	"description": "This is a 404 page",
	"content": "That page can\u0026rsquo;t be found.\nOur latest content is on the homepage.\nPhoto by Aron Visuals on Unsplash"
}]